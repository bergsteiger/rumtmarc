////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/CommonTemplates/CommonLang/InterfaceTypes/Struct.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAClass::Class>> MDProcess$Templates::CommonTemplates::CommonLang::InterfaceTypes::Struct
//
// Структура
// ---
// Элемент аграгации других типов. Структура не может иметь бизнесс-операций, только данные.
// Дополнительно (через пользовательское свойство) может быть указанно что для структуоры
// необходимо сгенерировать стандартные операторы.
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//: Struct::Class
implementation @ <<Struct>>
//? Структура
//? Элемент аграгации других типов. Структура не может иметь бизнесс-операций, только данные. Дополнительно (через пользовательское свойство) может быть указанно что для структуоры необходимо сгенерировать стандартные операторы.
//> Enum::Class

//= WikiImplClass::Class
//= InterfaceGeneratorWithJava::MDAGenerator
//= Генерация JavaScript::MDAGenerator

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Параметры стереотипа
//v +#-
// - типы видимости
//Y code_struct.gif
//L code_struct
// Параметры визуализации
//$ C 240,230,210
//$ l 100,75,35
//$ f 100,75,35
//B -2
// - вес форвард декларации

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Пользовательские свойства

//p need UC:b=false ? явно включает генерацию дополнительных секций Юзер-Кода
//p need dctor:b=false ? включает генерацию деструктора
//p Need copy ctor:b=false ? включает генерацию копирующего конструктора и оператора присваивания
//p Need init ctor:b=false ? включает генерацию конструктора инициализации
//p force usage:b=false ? явно определяет, что элемент будет кем-то использован (нужно для проверки)
//p packed:b=false ? определяет упакованность структуры

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функции стереотипа

//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'

//%f _wiki_up_print
; // st_space_key

: wiki_up_print OBJECT IN %S
//	%S#[inherited][{"%S{need UC}"!="%S{!need UC}"}%f_up_prefix(%S) *need UC* = *%S{need UC}* - явно включает генерацию дополнительных секций Юзер-Кода
 ?inherited
 %IF ( ( %S get_up ( 'need UC' ) ) %!= ( %S get_up_def ( 'need UC' ) ) ) 
  [%f] up_prefix %( %S )% ' *need UC* = *'
  %S get_up ( 'need UC' ) '* - явно включает генерацию дополнительных секций Юзер-Кода'
//	][{"%S{need dctor}"!="%S{!need dctor}"}%f_up_prefix(%S) *need dctor* = *%S{need dctor}* - включает генерацию деструктора
 %END-IF
 %IF ( ( %S get_up ( 'need dctor' ) ) %!= ( %S get_up_def ( 'need dctor' ) ) ) 
  [%f] up_prefix %( %S )% ' *need dctor* = *'
  %S get_up ( 'need dctor' ) '* - включает генерацию деструктора'
//	][{"%S{Need copy ctor}"!="%S{!Need copy ctor}"}%f_up_prefix(%S) *Need copy ctor* = *%S{Need copy ctor}* - включает генерацию копирующего конструктора и оператора присваивания
 %END-IF
 %IF ( ( %S get_up ( 'Need copy ctor' ) ) %!= ( %S get_up_def ( 'Need copy ctor' ) ) ) 
  [%f] up_prefix %( %S )% ' *Need copy ctor* = *'
  %S get_up ( 'Need copy ctor' ) '* - включает генерацию копирующего конструктора и оператора присваивания'
//	][{"%S{Need init ctor}"!="%S{!Need init ctor}"}%f_up_prefix(%S) *Need init ctor* = *%S{Need init ctor}* - включает генерацию конструктора инициализации
 %END-IF
 %IF ( ( %S get_up ( 'Need init ctor' ) ) %!= ( %S get_up_def ( 'Need init ctor' ) ) ) 
  [%f] up_prefix %( %S )% ' *Need init ctor* = *'
  %S get_up ( 'Need init ctor' ) '* - включает генерацию конструктора инициализации'
//	][{"%S{force usage}"!="%S{!force usage}"}%f_up_prefix(%S) *force usage* = *%S{force usage}* - явно определяет, что элемент будет кем-то использован (нужно для проверки)
 %END-IF
 %IF ( ( %S get_up ( 'force usage' ) ) %!= ( %S get_up_def ( 'force usage' ) ) ) 
  [%f] up_prefix %( %S )% ' *force usage* = *'
  %S get_up ( 'force usage' ) '* - явно определяет, что элемент будет кем-то использован (нужно для проверки)'
//	][{"%S{packed}"!="%S{!packed}"}%f_up_prefix(%S) *packed* = *%S{packed}* - определяет упакованность структуры
 %END-IF
 %IF ( ( %S get_up ( 'packed' ) ) %!= ( %S get_up_def ( 'packed' ) ) ) 
  [%f] up_prefix %( %S )% ' *packed* = *'
  %S get_up ( 'packed' ) '* - определяет упакованность структуры'
//	]
 %END-IF

// базовый класс для структуры
//%f _base_class
; // wiki_up_print

: base_class OBJECT IN %S
//#UC START# *470F357C03D8for470F33CD0242*
//	[{%XU=java&<{}{%f_used_as_compare_func(%s)=true}{%sC}>!=0}%f_set_var(COMP_KEY,"")<{}{%f_used_as_compare_func(%s)=true}{%s}%f_set_compare_key_type(%s)> implements java.util.Comparator\<%f_type(%{COMP_KEY}%T)\>]
 %IF ( ( %X |U ) %== 'java' %&& 
   ( 
  %FOR %ITEM-CONDITION ( ( [%f] used_as_compare_func %( %s )% ) %==  true ) 
   ( %s |C ) 
  %END-FOR
  %!= 0  ) ) 
  [%f] set_var %( 'COMP_KEY' %, '' )% 
  %FOR %ITEM-CONDITION ( ( [%f] used_as_compare_func %( %s )% ) %==  true ) 
   ( %s ) 
   [%f] set_compare_key_type %( %s )% 
  %END-FOR
  ' implements java.util.Comparator<'
  [%f] type %( ( get_global_var ( 'COMP_KEY' )  ->T ) )% '>' 
 %END-IF
//#UC END# *470F357C03D8for470F33CD0242*
; // base_class


// возвращает true, если для структуры нужен файл реализации (cpp)
//%f _struct_need_impl
: struct_need_impl OBJECT IN %S
//#UC START# *470F35A0036Bfor470F33CD0242*
//	[{%S{Need copy ctor}=true|%S{Need init ctor}=true|%S{Need assign op}=true|<{}{"%CC"="Operation"&"%CS"="ctor"}{%CC}>!=0|%S{need dctor}=true}{false}true]
 %IF ( ( %S get_up ( 'Need copy ctor' ) ) %==  true %|| 
   ( ( %S get_up ( 'Need init ctor' ) ) %==  true  ) %|| 
   ( ( %S get_up ( 'Need assign op' ) ) %==  true  ) %|| 
   ( 
  %FOR %ITEM-CONDITION ( ( %C |C ) %== 'Operation' %&& 
    ( ( %C |S ) %== 'ctor'  ) ) 
   ( %C |C ) 
  %END-FOR
  %!= 0  ) %|| 
   ( ( %S get_up ( 'need dctor' ) ) %==  true  ) ) 
  %ELSE
    false 
  %THEN
   true 
 %END-IF
//#UC END# *470F35A0036Bfor470F33CD0242*
; // struct_need_impl


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for470F33CD0242*
//c                                                                      {}
//r {<{}{%PS=ServerLibrary}{C}>!=0&%f_to_lower(%PN)=%f_to_lower(%SN)}:   {имя %SS, используемой в качестве серверного типа, не должно совпадать с именем родителя}
//r {%M{force usage}=false&%S{force usage}=false&%ax=false}:             {%SS ни кем не используется}
//r {%Gx=true|%Rx=true}:                                                  {%SS не может ни от кого наследоваться и никого реализовывать}
//#UC END# *4704C0E30186for470F33CD0242*
; // constraint


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Стереотип является структурой
//%f _IsStruct
: IsStruct OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *4B6C49DA0023for470F33CD0242*
//	true
 true
//#UC END# *4B6C49DA0023for470F33CD0242*
; // IsStruct


// перекрытие базового стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
//%f _wiki_up_add_gen
: wiki_up_add_gen OBJECT IN %S
//#UC START# *470484D50138for470F33CD0242*
//	[{%S{Need init ctor}=true}* конструктор инициализации
 %IF ( ( %S get_up ( 'Need init ctor' ) ) %==  true ) 
  '* конструктор инициализации'
//	][{%S{Need copy ctor}=true}* копирующий конструктор
 %END-IF
 %IF ( ( %S get_up ( 'Need copy ctor' ) ) %==  true ) 
  '* копирующий конструктор'
//	][{%S{need dctor}=true}* деструктор для финальных классов
 %END-IF
 %IF ( ( %S get_up ( 'need dctor' ) ) %==  true ) 
  '* деструктор для финальных классов'
//	]
 %END-IF
//#UC END# *470484D50138for470F33CD0242*
; // wiki_up_add_gen


// реализация абстрактного стереотипа C++ интерфейсы и реализация::MDAGenerator
// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor470F33CD0242*
//	%f_set_var(__SCOPE,P)%f_set_var(STRUCT,S)%f_dump_cpp_functors_cpp(%S)[{%S{need dctor}=true}\
 [%f] set_var %( '__SCOPE' %, 'P' )% [%f] set_var %( 'STRUCT' %, 'S' )% [%f] dump_cpp_functors_cpp %( %S )% %IF ( ( %S get_up ( 'need dctor' ) ) %==  true ) 
//	%f_templ_header(%S)%f_function_scope(%S)~%SN () {
  [%f] templ_header %( %S )% [%f] function_scope %( %S )% '~'
  %S |N ' () {'
//		%U[{_DCTOR}
  '	'
  %U%IF ( '_DCTOR' ) 

//		]
   '	' 
  %END-IF
 //	}
  '}'
//	][{%S{Need init ctor}=true}\
 %END-IF
 %IF ( ( %S get_up ( 'Need init ctor' ) ) %==  true ) 
//	%f_struct_init_ctor_header_cpp(%S)
  [%f] struct_init_ctor_header_cpp %( %S )% 
//	%U[{_INIT_CTOR_BASE_INIT!cpp!}
  %U%IF ( '_INIT_CTOR_BASE_INIT!cpp!' ) 

//	]
  %END-IF
 //	{
  '{'
//		%U[{_INIT_CTOR!cpp!}
  '	'
  %U%IF ( '_INIT_CTOR!cpp!' ) 

//		throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);
   '	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);'
//		]
   '	' 
  %END-IF
 //	}
  '}'
//	][{%S{Need copy ctor}=true}\
 %END-IF
 %IF ( ( %S get_up ( 'Need copy ctor' ) ) %==  true ) 
//	%f_templ_header(%S)%f_function_scope(%S)%SN (const %SN& copy) 
  [%f] templ_header %( %S )% [%f] function_scope %( %S )% %S |N ' (const '
  %S |N '& copy) '
//	%U[{_COPY_CTOR_BASE_INIT!cpp!}
  %U%IF ( '_COPY_CTOR_BASE_INIT!cpp!' ) 

//	]
  %END-IF
 //	{
  '{'
//		%U[{_COPY_CTOR!cpp!}
  '	'
  %U%IF ( '_COPY_CTOR!cpp!' ) 

//		throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);
   '	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);'
//		]
   '	' 
  %END-IF
 //	}
  '}'
//	

//	%f_templ_header(%S)%t_ret(%S,"cached") %f_function_scope(%S)operator = (const %SN& copy) {
  [%f] templ_header %( %S )% [%t] ret %( %S %, 'cached' )% ' '
  [%f] function_scope %( %S )% 'operator = (const '
  %S |N '& copy) {'
//		%U[{_ASSIGN_OP!cpp!}
  '	'
  %U%IF ( '_ASSIGN_OP!cpp!' ) 

//		throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);
   '	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);'
//		]
   '	' 
  %END-IF
 //		return *this;
  '	return *this;'
//	}
  '}'
//	][<{}{"%CC"="Operation"&"%CS"="ctor"}
 %END-IF
 %IF-NOT-EMPTY
  %FOR %ITEM-CONDITION ( ( %C |C ) %== 'Operation' %&& 
    ( ( %C |S ) %== 'ctor'  ) ) 

//	%CX
   %C |X 
//	>]
  %END-FOR
 %END-IF
//#UC END# *47022CB8034Bfor470F33CD0242*
; // cpp


// реализация абстрактного стереотипа C++ интерфейсы и реализация::MDAGenerator
// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor470F33CD0242*
//F struct %SN;
//	[#%S%f_open_ifdef()
 %IF-NOT-EMPTY
  out_indent %S %f open_ifdef %( )% 
//	][<#%FF
 %END-IF
 %IF-NOT-EMPTY
  %FOR out_indent %F |F 
//	>]%f_dump_cpp_functors_h_fd(%S)[{"%PM"="Interfaces::Category"}\#pragma pack (push, 1)
  %END-FOR
 %END-IF
 [%f] dump_cpp_functors_h_fd %( %S )% %IF ( ( %P |M ) %== 'Interfaces::Category' ) 
  '#pragma pack (push, 1)'
//	

//	]%f_set_var(STRUCT,S)%f_docs(%S)\
 %END-IF
 [%f] set_var %( 'STRUCT' %, 'S' )% [%f] docs %( %S )% 
//	#struct %SN%S%f_base_class() {
 out_indent 'struct '
 %S |N %S %f base_class %( )% ' {'
//	<{}{"%CC"!="Operation"}%f_docs(%C)\
 %FOR %ITEM-CONDITION ( ( %C |C ) %!= 'Operation' ) 
  [%f] docs %( %C )% 
//	#	%f_attr(%C) [{}{%f_to_omg(%C%TN)}%CN];
  out_indent '	'
  [%f] attr %( %C )% ' '
  %IF ( ) 
   %ELSE
    [%f] to_omg %( %C ->T |N  )% 
   %THEN
   %C |N 
  %END-IF
  ';'
//	>%f_dump_def_init_ctor(%S)[{%S{need dctor}=true}
 %END-FOR
 [%f] dump_def_init_ctor %( %S )% %IF ( ( %S get_up ( 'need dctor' ) ) %==  true ) 

//	#	~%SN ();
  out_indent '	~'
  %S |N ' ();'
//	][{%S{Need init ctor}=true}
 %END-IF
 %IF ( ( %S get_up ( 'Need init ctor' ) ) %==  true ) 

//	%f_struct_init_ctor_header_h(%S)
  [%f] struct_init_ctor_header_h %( %S )% 
//	][{%S{Need copy ctor}=true}
 %END-IF
 %IF ( ( %S get_up ( 'Need copy ctor' ) ) %==  true ) 

//	#	%SN (const %SN& copy);
  out_indent '	'
  %S |N ' (const '
  %S |N '& copy);'
//	

//	#	%SN& operator = (const %SN& copy);
  out_indent '	'
  %S |N '& operator = (const '
  %S |N '& copy);'
//	][<{}{"%CC"="Operation"&"%CS"="ctor"}
 %END-IF
 %IF-NOT-EMPTY
  %FOR %ITEM-CONDITION ( ( %C |C ) %== 'Operation' %&& 
    ( ( %C |S ) %== 'ctor'  ) ) 

//	%CX
   %C |X 
//	>]%f_dump_cpp_functors_h(%S)[{"%S{need UC}"="true"}#	%U[
  %END-FOR
 %END-IF
 [%f] dump_cpp_functors_h %( %S )% %IF ( ( %S get_up ( 'need UC' ) ) %== true ) 
  out_indent '	'
  %U%IF-NOT-EMPTY

//	#	]
   out_indent '	' 
  %END-IF
 //	]#};[{"%PM"="Interfaces::Category"}
 %END-IF
 out_indent '};'
 %IF ( ( %P |M ) %== 'Interfaces::Category' ) 

//	

//	\#pragma pack (pop)][
  '#pragma pack (pop)' 
 %END-IF
 %IF-NOT-EMPTY

//	#%S%f_close_ifdef()]
  out_indent %S %f close_ifdef %( )% 
 %END-IF
//#UC END# *47022C88029Ffor470F33CD0242*
; // h


// реализация абстрактного стереотипа CORBA IDL::MDAGenerator
// генератор idl спецификаций (.idl)
//+ idl
<<generator>> idl OBJECT IN %S
//#UC START# *47022BBE0261for470F33CD0242*
//F struct <%NN::>%SN;
//	<#%FF
 %FOR out_indent %F |F 
//	>%f_docs(%S)\
 %END-FOR
 [%f] docs %( %S )% 
//	#struct %SN {<{}{"%CC"!="Operation"}
 out_indent 'struct '
 %S |N ' {'
 %FOR %ITEM-CONDITION ( ( %C |C ) %!= 'Operation' ) 

//	%CX>
  %C |X 
 %END-FOR
//	#};
 out_indent '};'
//#UC END# *47022BBE0261for470F33CD0242*
; // idl


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor470F33CD0242*
//R  
//	<{\n}%CX>
 %FOR %ITEM-SEPARATOR #13#10 ; // %ITEM-SEPARATOR 
  %C |X 
 %END-FOR
//#UC END# *470F15B800CBfor470F33CD0242*
; // impl.pas


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor470F33CD0242*
//R  
//	[{%f_exists_in_list(GENERATED_INTF,"%f_pas_TypeName(%S)")!=true}\
 %IF ( ( [%f] exists_in_list %( 'GENERATED_INTF' %, [%f] pas_TypeName %( %S )% )% ) %!=  true ) 
//	%f_add_to_list(GENERATED_INTF,"%f_pas_TypeName(%S)")\
  [%f] add_to_list %( 'GENERATED_INTF' %, [%f] pas_TypeName %( %S )% )% 
//	%f_pas_OpenType(%S)\
  [%f] pas_OpenType %( %S )% 
//	<{}{%C#f_IsDefine()=true}[%CX\n]>\
  %FOR %ITEM-CONDITION ( ( %C %?f IsDefine %( )% ) %==  true ) 
   %IF-NOT-EMPTY
    %C |X #13#10 
   %END-IF
  %END-FOR
//	[#%S#f_open_ifdef()\n]\
  %IF-NOT-EMPTY
   out_indent %S %?f open_ifdef %( )% #13#10 
  %END-IF
//	#%f_pas_TypeName(%S) = [{%S{packed}=true}packed ]record\
  out_indent [%f] pas_TypeName %( %S )% ' = '
  %IF ( ( %S get_up ( 'packed' ) ) %==  true ) 
   'packed ' 
  %END-IF
  'record'
//	[\n# \{* %f_Doc(%S) \}]
  %IF-NOT-EMPTY
   #13#10
   out_indent ' {* '
   [%f] Doc %( %S )% ' }' 
  %END-IF
//	[#  <{\n#  }{%C#f_IsDefine()!=true&%C#f_IsConstructor()!=true}%CX>\n]\
  %IF-NOT-EMPTY
   out_indent '  '
   %FOR %ITEM-SEPARATOR #13#10
    out_indent '  ' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C %?f IsDefine %( )% ) %!=  true %&& 
     ( ( %C %?f IsConstructor %( )% ) %!=  true  ) ) 
    %C |X 
   %END-FOR
   #13#10 
  %END-IF
//	#end;//%f_pas_TypeName(%S)\
  out_indent 'end;//'
  [%f] pas_TypeName %( %S )% 
//	[\n#%S#f_close_ifdef()]\
  %IF-NOT-EMPTY
   #13#10
   out_indent %S %?f close_ifdef %( )% 
  %END-IF

//	[\n\n<{\n}{%C#f_IsConstructor()=true}%CX>]\
//	]
 %END-IF
//#UC END# *470F1571031Cfor470F33CD0242*
; // intf.pas


// реализация абстрактного стереотипа Java::MDAGenerator
// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for470F33CD0242*
//O [{%t_nested_scope_def(%P)=false&%f_is_server_type(%S)=false}%SN.java]
//	%f_output_constraint(%S)\
 [%f] output_constraint %( %S )% 
//	[{%f_is_server_type(%S)=false}[{%t_nested_scope_def(%P)=false}\
 %IF ( ( [%f] is_server_type %( %S )% ) %==  false ) 
  %IF ( ( [%t] nested_scope_def %( %P )% ) %==  false ) 
//	%f_header(%S)
   [%f] header %( %S )% 
//	package %f_dump_java_package(%S);
   'package '
   [%f] dump_java_package %( %S )% ';'
//	

//	[%f_java_dump_import_block(%S)
   %IF-NOT-EMPTY
    [%f] java_dump_import_block %( %S )% 
//	]%f_includes_by_contents_java(%S)
   %END-IF
   [%f] includes_by_contents_java %( %S )% 
//	%U[{_CUSTOM_IMPORT}
   %U%IF ( '_CUSTOM_IMPORT' ) 

//	]
   %END-IF
 //	

//	%U[{_CUSTOM_CLASS_DEFINITION}
   %U%IF ( '_CUSTOM_CLASS_DEFINITION' ) 

//	]
   %END-IF
 //	]%f_set_var(STRUCT,S)%f_docs(%S)\
  %END-IF
  [%f] set_var %( 'STRUCT' %, 'S' )% [%f] docs %( %S )% 
//	#%t_visibility(%S,"%XU")[{%t_nested_scope_def(%P)=false&%f_is_server_type(%S)=false}{static }]class %SN%S%f_base_class() {
  out_indent [%t] visibility %( %S %, %X |U )% %IF ( ( [%t] nested_scope_def %( %P )% ) %==  false %&& 
    ( ( [%f] is_server_type %( %S )% ) %==  false  ) ) 
   %ELSE
    'static ' 
   %THEN
  %END-IF
  'class '
  %S |N %S %f base_class %( )% ' {'
//	<{}{"%CC"!="Operation"}
  %FOR %ITEM-CONDITION ( ( %C |C ) %!= 'Operation' ) 

//	%CX
   %C |X 
//	>%f_dump_def_init_ctor_java(%S)[{%S{need dctor}=true}
  %END-FOR
  [%f] dump_def_init_ctor_java %( %S )% %IF ( ( %S get_up ( 'need dctor' ) ) %==  true ) 

//	#	protected void finalize () {
   out_indent '	protected void finalize () {'
//	#		%U[{_DTOR}
   out_indent '		'
   %U%IF ( '_DTOR' ) 

//	#		]
    out_indent '		' 
   %END-IF
 //	#	}
   out_indent '	}'
//	][{%S{Need init ctor}=true}
  %END-IF
  %IF ( ( %S get_up ( 'Need init ctor' ) ) %==  true ) 

//	#	public %SN (<{, }{%CC=Attribute}[{%Cl!=lnk}{%f_attr(%C)}%t_arg(%C%T,"in")] %CN_>) {
   out_indent '	public '
   %S |N ' ('
   %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |C ) %== 'Attribute' ) 
    %IF ( ( %C |l ) %!= 'lnk' ) 
     %ELSE
      [%f] attr %( %C )% 
     %THEN
     [%t] arg %( %C ->T  %, 'in' )% 
    %END-IF
    ' '
    %C |N '_' 
   %END-FOR
   ') {'
//	#		%U[{_CTOR}
   out_indent '		'
   %U%IF ( '_CTOR' ) 

//	#		]
    out_indent '		' 
   %END-IF
 //	#	}
   out_indent '	}'
//	][{%S{Need copy ctor}=true}
  %END-IF
  %IF ( ( %S get_up ( 'Need copy ctor' ) ) %==  true ) 

//	#	public %SN (final %SN copy) {
   out_indent '	public '
   %S |N ' (final '
   %S |N ' copy) {'
//	#		%U[{_COPY_CTOR}
   out_indent '		'
   %U%IF ( '_COPY_CTOR' ) 

//	#		]
    out_indent '		' 
   %END-IF
 //	#	}
   out_indent '	}'
//	][{%S{Need assign op}=true}
  %END-IF
  %IF ( ( %S get_up ( 'Need assign op' ) ) %==  true ) 

//	][<{}{"%CC"="Operation"&"%CS"="ctor"}%f_docs(%C)\
  %END-IF
  %IF-NOT-EMPTY
   %FOR %ITEM-CONDITION ( ( %C |C ) %== 'Operation' %&& 
     ( ( %C |S ) %== 'ctor'  ) ) 
    [%f] docs %( %C )% 
//	#	public %SN (%C<{, }%f_arg_full_decl(%C)>) {
    out_indent '	public '
    %S |N ' ('
    %C
    %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
     [%f] arg_full_decl %( %C )% 
    %END-FOR
     ') {'
//	#		%U[{_%CU_CTOR_BODY!java!}
    out_indent '		'
    %U%IF ( '_( '
     %C |U ) '_CTOR_BODY!java!' ) 

//	#		]
     out_indent '		' 
    %END-IF
 //	#	}
    out_indent '	}'
//	>]%f_dump_functors_java(%S)[{"%S{need UC}"="true"}#	%U[
   %END-FOR
  %END-IF
  [%f] dump_functors_java %( %S )% %IF ( ( %S get_up ( 'need UC' ) ) %== true ) 
   out_indent '	'
   %U%IF-NOT-EMPTY

//	#	]
    out_indent '	' 
   %END-IF
 //	]#} // class %SN][{%f_is_server_type(%S)=false}\
  %END-IF
  out_indent '} // class '
  %S |N 
 %END-IF
 %IF ( ( [%f] is_server_type %( %S )% ) %==  false ) 
//	[{%t_nested_scope_def(%P)=false}
  %IF ( ( [%t] nested_scope_def %( %P )% ) %==  false ) 

//	%f_footer(%S)
   [%f] footer %( %S )% 
//	]]
  %END-IF
 %END-IF

//f _dump_functors_java
; // java

end. // <<Struct>>

: dump_functors_java OBJECT IN %S
//	[%f_set_var(COMP_KEY,"")<{}{%f_used_as_compare_func(%s)=true}{%s}%f_set_compare_key_type(%s)>[{"%{COMP_KEY}U"!=""}
 %IF-NOT-EMPTY
  [%f] set_var %( 'COMP_KEY' %, '' )% 
  %FOR %ITEM-CONDITION ( ( [%f] used_as_compare_func %( %s )% ) %==  true ) 
   ( %s ) 
   [%f] set_compare_key_type %( %s )% 
  %END-FOR
  %IF ( ( ( get_global_var ( 'COMP_KEY' ) |U ) ) %!= '' ) 

//	#	public int compare (%f_type(%{COMP_KEY}%T) o1, %f_type(%{COMP_KEY}%T) o2) {
   out_indent '	public int compare ('
   [%f] type %( ( get_global_var ( 'COMP_KEY' )  ->T ) )% ' o1, '
   [%f] type %( ( get_global_var ( 'COMP_KEY' )  ->T ) )% ' o2) {'
//	#		%U[{_%{COMP_KEY}U_COMPARE}
   out_indent '		'
   %U%IF ( '_( '
    ( get_global_var ( 'COMP_KEY' ) |U ) ) '_COMPARE' ) 

//	#		throw new ru.garant.shared.Core.Root.MDAGenNotImplemented ();
    out_indent '		throw new ru.garant.shared.Core.Root.MDAGenNotImplemented ();'
//	#		]
    out_indent '		' 
   %END-IF
 //	#	}
   out_indent '	}'
//	]]
  %END-IF
 %END-IF
//#UC END# *470321950119for470F33CD0242*
; // dump_functors_java


// реализация абстрактного стереотипа Дельфи-DLL Адаптер::MDAGenerator
// С++ TIE-обвязка для DLL (_tie.h)
//+ dll.h
implementation @ <<Struct>>
<<generator>> dll.h OBJECT IN %S
//#UC START# *47032EC4032Cfor470F33CD0242*
//F struct %f_type(%S);
//	[{%f_has_empty_ctor(%S)=false}%f_error("For export struct (%f_type(%S)) from DLL it must have empty ctor")]\
 %IF ( ( [%f] has_empty_ctor %( %S )% ) %==  false ) 
  [%f] error %( 'For export struct ('
  [%f] type %( %S )% ') from DLL it must have empty ctor' )% 
 %END-IF
//	[{"%f_need_tie(%S)"="true"}\#pragma pack (push, 1)
 %IF ( ( [%f] need_tie %( %S )% ) %== true ) 
  '#pragma pack (push, 1)'
//	

//	struct %f_type(%S) {
  'struct '
  [%f] type %( %S )% ' {'
//	<{\n}{%CC!=Operation}	[{%t_is_container(%C%T)=true}{%t_pointer_attr(%C%T)}%f_tn(%C%T)*] %CN;>
  %FOR %ITEM-SEPARATOR #13#10 ; // %ITEM-SEPARATOR 
   %ITEM-CONDITION ( ( %C |C ) %!= 'Operation' ) 
   '	'
   %IF ( ( [%t] is_container %( %C ->T  )% ) %==  true ) 
    %ELSE
     [%t] pointer_attr %( %C ->T  )% 
    %THEN
    [%f] tn %( %C ->T  )% '*' 
   %END-IF
   ' '
   %C |N ';' 
  %END-FOR
//		
  '	'
//		static void make_cpp (const %SN_tie& obj, %SN& ret_);
  '	static void make_cpp (const '
  %S |N '_tie& obj, '
  %S |N '& ret_);'
//	

//		static void make_tie (const %SN& obj, %t_arg(%S,"inout") ret_);
  '	static void make_tie (const '
  %S |N '& obj, '
  [%t] arg %( %S %, 'inout' )% ' ret_);'
//	};[{%f_used_in_callback(%S)=true}
  '};'
  %IF ( ( [%f] used_in_callback %( %S )% ) %==  true ) 

//	

//	struct %f_type(%S)_for_callback {
   'struct '
   [%f] type %( %S )% '_for_callback {'
//	<{\n}{%CC!=Operation}	[{%t_is_container(%C%T)=true}{%t_pointer_attr(%C%T)}%f_tn(%C%T)*] %CN;>
   %FOR %ITEM-SEPARATOR #13#10 ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |C ) %!= 'Operation' ) 
    '	'
    %IF ( ( [%t] is_container %( %C ->T  )% ) %==  true ) 
     %ELSE
      [%t] pointer_attr %( %C ->T  )% 
     %THEN
     [%f] tn %( %C ->T  )% '*' 
    %END-IF
    ' '
    %C |N ';' 
   %END-FOR
//		
   '	'
//		~%f_type(%S)_for_callback ();
   '	~'
   [%f] type %( %S )% '_for_callback ();'
//		
   '	'
//		static void make_cpp (const %f_type(%S)_for_callback& obj, %SN& ret_);
   '	static void make_cpp (const '
   [%f] type %( %S )% '_for_callback& obj, '
   %S |N '& ret_);'
//	

//		static void make_tie (const %SN& obj, %f_type(%S)_for_callback& ret_);
   '	static void make_tie (const '
   %S |N '& obj, '
   [%f] type %( %S )% '_for_callback& ret_);'
//	};]
   '};' 
  %END-IF
//	

//	\#pragma pack (pop)]
  '#pragma pack (pop)' 
 %END-IF

//+ dll.cpp
; // dll.h

<<generator>> dll.cpp OBJECT IN %S
//	[{%f_has_empty_ctor(%S)=false}%f_error("For export struct (%f_type(%S)) from DLL it must have empty ctor")]\
 %IF ( ( [%f] has_empty_ctor %( %S )% ) %==  false ) 
  [%f] error %( 'For export struct ('
  [%f] type %( %S )% ') from DLL it must have empty ctor' )% 
 %END-IF
//	[{"%f_need_tie(%S)"="true"}\
 %IF ( ( [%f] need_tie %( %S )% ) %== true ) 
//	void %f_type(%S)::make_cpp (const %SN_tie& obj, %SN& ret_) {
  'void '
  [%f] type %( %S )% '::make_cpp (const '
  %S |N '_tie& obj, '
  %S |N '& ret_) {'
//	<{}{%CC!=Operation}		[{"%f_need_tie(%C%T)"="true"}{ret_.%CN = obj.%CN}\
  %FOR %ITEM-CONDITION ( ( %C |C ) %!= 'Operation' ) 
   '		'
   %IF ( ( [%f] need_tie %( %C ->T  )% ) %== true ) 
    %ELSE
     'ret_.'
     %C |N ' = obj.'
     %C |N 
    %THEN
//	[{%t_is_container(%C%T)=true}{%f_type_tie(%C%T)::make_cpp ([{%t_tie_should_be_dereferenced(%C%T)=true}*]obj.%CN, ret_.%CN[{%t_interface(%C%T)=true}.out (), true])}\
    %IF ( ( [%t] is_container %( %C ->T  )% ) %==  true ) 
     %ELSE
      [%f] type_tie %( %C ->T  )% '::make_cpp ('
      %IF ( ( [%t] tie_should_be_dereferenced %( %C ->T  )% ) %==  true ) 
       '*' 
      %END-IF
      'obj.'
      %C |N ', ret_.'
      %C |N %IF ( ( [%t] interface %( %C ->T  )% ) %==  true ) 
       '.out (), true' 
      %END-IF
      ')' 
     %THEN
//	%f_cpp_type(%C%T)* ret_%CN_;
     [%f] cpp_type %( %C ->T  )% '* ret_'
     %C |N '_;'
//			%f_type_tie(%C%T)::make_cpp (obj.%CN, ret_%CN_);
     '		'
     [%f] type_tie %( %C ->T  )% '::make_cpp (obj.'
     %C |N ', ret_'
     %C |N '_);'
//			ret_.%CN = *ret_%CN_]];
     '		ret_.'
     %C |N ' = *ret_'
     %C |N '_' 
    %END-IF
   %END-IF
   ';'
//	>}
  %END-FOR
  '}'
//	

//	void %f_type(%S)::make_tie (const %SN& obj, %t_arg(%S,"inout") ret_) {
  'void '
  [%f] type %( %S )% '::make_tie (const '
  %S |N '& obj, '
  [%t] arg %( %S %, 'inout' )% ' ret_) {'
//	<{}{%CC!=Operation}\
  %FOR %ITEM-CONDITION ( ( %C |C ) %!= 'Operation' ) 
//	[{"%f_need_tie(%C%T)"="true"}{		ret_.%CN = obj.%CN;}[{%t_interface(%C%T)=true|%t_is_container(%C%T)=true}		ret_.%CN = 0;
   %IF ( ( [%f] need_tie %( %C ->T  )% ) %== true ) 
    %ELSE
     '		ret_.'
     %C |N ' = obj.'
     %C |N ';' 
    %THEN
    %IF ( ( [%t] interface %( %C ->T  )% ) %==  true %|| 
      ( ( [%t] is_container %( %C ->T  )% ) %==  true  ) ) 
     '		ret_.'
     %C |N ' = 0;'
//	]		%f_type_tie(%C%T)::make_tie (obj.%CN[{"%t_interface(%C%T)"="true"}.in ()], [{%t_tie_should_be_dereferenced(%C%T)=true}*]ret_.%CN[{%t_interface(%C%T)=true}, true]);]
    %END-IF
    '		'
    [%f] type_tie %( %C ->T  )% '::make_tie (obj.'
    %C |N %IF ( ( [%t] interface %( %C ->T  )% ) %== true ) 
     '.in ()' 
    %END-IF
    ', '
    %IF ( ( [%t] tie_should_be_dereferenced %( %C ->T  )% ) %==  true ) 
     '*' 
    %END-IF
    'ret_.'
    %C |N %IF ( ( [%t] interface %( %C ->T  )% ) %==  true ) 
     ', true' 
    %END-IF
    ');' 
   %END-IF
//	>}
  %END-FOR
  '}'
//	[{%f_used_in_callback(%S)=true}
  %IF ( ( [%f] used_in_callback %( %S )% ) %==  true ) 

//	%f_type(%S)_for_callback::~%f_type(%S)_for_callback () {
   [%f] type %( %S )% '_for_callback::~'
   [%f] type %( %S )% '_for_callback () {'
//	<{}{%CC=Attribute&%t_interface(%C%T)=true}\
   %FOR %ITEM-CONDITION ( ( %C |C ) %== 'Attribute' %&& 
     ( ( [%t] interface %( %C ->T  )% ) %==  true  ) ) 
//		if (%CN) {
    '	if ('
    %C |N ') {'
//			%CN-\>release ();
    '		'
    %C |N '->release ();'
//		}
    '	}'
//	>
   %END-FOR
//	}
   '}'
//	

//	void %f_type(%S)_for_callback::make_cpp (const %f_type(%S)_for_callback& obj, %SN& ret_) {
   'void '
   [%f] type %( %S )% '_for_callback::make_cpp (const '
   [%f] type %( %S )% '_for_callback& obj, '
   %S |N '& ret_) {'
//	<{}{%CC!=Operation}		[{"%f_need_tie(%C%T)"="true"}{ret_.%CN = obj.%CN}\
   %FOR %ITEM-CONDITION ( ( %C |C ) %!= 'Operation' ) 
    '		'
    %IF ( ( [%f] need_tie %( %C ->T  )% ) %== true ) 
     %ELSE
      'ret_.'
      %C |N ' = obj.'
      %C |N 
     %THEN
//	[{%t_is_container(%C%T)=true}{%f_type_tie(%C%T)::make_cpp (obj.%CN, ret_.%CN[{"%t_interface(%C%T)"="true"}.out ()], true)}\
     %IF ( ( [%t] is_container %( %C ->T  )% ) %==  true ) 
      %ELSE
       [%f] type_tie %( %C ->T  )% '::make_cpp (obj.'
       %C |N ', ret_.'
       %C |N %IF ( ( [%t] interface %( %C ->T  )% ) %== true ) 
        '.out ()' 
       %END-IF
       ', true)' 
      %THEN
//	%f_cpp_type(%C%T)* ret_%CN_;
      [%f] cpp_type %( %C ->T  )% '* ret_'
      %C |N '_;'
//			%f_type_tie(%C%T)::make_cpp (obj.%CN, ret_%CN_);
      '		'
      [%f] type_tie %( %C ->T  )% '::make_cpp (obj.'
      %C |N ', ret_'
      %C |N '_);'
//			ret_.%CN = *ret_%CN_]];
      '		ret_.'
      %C |N ' = *ret_'
      %C |N '_' 
     %END-IF
    %END-IF
    ';'
//	>}
   %END-FOR
   '}'
//	

//	void %f_type(%S)_for_callback::make_tie (const %SN& obj, %f_type(%S)_for_callback& ret_) {
   'void '
   [%f] type %( %S )% '_for_callback::make_tie (const '
   %S |N '& obj, '
   [%f] type %( %S )% '_for_callback& ret_) {'
//	<{}{%CC!=Operation}\
   %FOR %ITEM-CONDITION ( ( %C |C ) %!= 'Operation' ) 
//	[{"%f_need_tie(%C%T)"="true"}{		ret_.%CN = obj.%CN;}		ret_.%CN = 0;
    %IF ( ( [%f] need_tie %( %C ->T  )% ) %== true ) 
     %ELSE
      '		ret_.'
      %C |N ' = obj.'
      %C |N ';' 
     %THEN
     '		ret_.'
     %C |N ' = 0;'
//			%f_type_tie(%C%T)::make_tie (obj.%CN[{"%t_interface(%C%T)"="true"}.in ()], ret_.%CN[{%t_interface(%C%T)=true}, true]);]
     '		'
     [%f] type_tie %( %C ->T  )% '::make_tie (obj.'
     %C |N %IF ( ( [%t] interface %( %C ->T  )% ) %== true ) 
      '.in ()' 
     %END-IF
     ', ret_.'
     %C |N %IF ( ( [%t] interface %( %C ->T  )% ) %==  true ) 
      ', true' 
     %END-IF
     ');' 
    %END-IF
//	>}
   %END-FOR
   '}'
//	]]
  %END-IF
 %END-IF

//t _struct_tie_var_attr
; // dll.cpp

end. // <<Struct>>

<<transformator>> struct_tie_var_attr OBJECT IN %S
//c                                         {}
//r "%t_is_container(%S)"="true":           {Core::Var\<%f_tn_prefix(%S)%f_tn(%S)\>}
//r "%f_is_fixed_simple(%S)"="true":        {[{%SS=Typedef}%f_tn_prefix(%S)]%f_tn(%S)}
//r "%f_is_fixed_complex(%S)"="true":       {%f_tn_prefix(%S)%f_tn(%S)}
//r "%SN"="string":                         {%f_tn(%S)}
//r "%SN"="pointer":                        {%f_tn(%S)}
//r "%f_is_not_fixed_simple(%S)"="true":    {%f_var(%S)}
//r "%f_is_not_fixed_complex(%S)"="true":   {%f_var(%S)}
//r "%t_refcounted(%S)"="true":             {%f_var(%S)}
//f _used_in_callback
; // struct_tie_var_attr

: used_in_callback OBJECT IN %S
//	[{<{}{%aC=Parameter&%a%PC=Operation&%a%P%P{call way}=back}{%aC}>!=0}{false}true]
 %IF ( 
  %FOR %ITEM-CONDITION ( ( %a |C ) %== 'Parameter' %&& 
    ( ( %a ->P |C  ) %== 'Operation'  ) %&& 
    ( ( %a ->P ->P get_up ( 'call way' )   ) %== 'back'  ) ) 
   ( %a |C ) 
  %END-FOR
  %!= 0 ) 
  %ELSE
    false 
  %THEN
   true 
 %END-IF

//f _has_empty_ctor
; // used_in_callback

: has_empty_ctor OBJECT IN %S
//	[{%f_count_ctor(%S)=0&%S{Need init ctor}=false&%S{Need copy ctor}=false}{[{<{}{%CC=Operation&%CS=ctor&"%C<%f_arg_full_decl(%C)>"=""}{C}>!=0}{false}true]}true]
 %IF ( ( [%f] count_ctor %( %S )% ) %== 0 %&& 
   ( ( %S get_up ( 'Need init ctor' ) ) %==  false  ) %&& 
   ( ( %S get_up ( 'Need copy ctor' ) ) %==  false  ) ) 
  %ELSE
   %IF ( 
    %FOR %ITEM-CONDITION ( ( %C |C ) %== 'Operation' %&& 
      ( ( %C |S ) %== 'ctor'  ) %&& 
      ( ( %C
     %FOR [%f] arg_full_decl %( %C )% 
     %END-FOR
 )      %== ''  ) ) 
     ( 'C' ) 
    %END-FOR
    %!= 0 ) 
    %ELSE
      false 
    %THEN
     true 
   %END-IF
  %THEN
   true 
 %END-IF
//#UC END# *47032EC4032Cfor470F33CD0242*
; // has_empty_ctor


// реализация абстрактного стереотипа Дельфи-DLL Адаптер::MDAGenerator
// Delphi интерфейсы для адаптера (.pas)
//+ pas
implementation @ <<Struct>>
<<generator>> pas OBJECT IN %S
//#UC START# *470F152700FAfor470F33CD0242*
//	[%f_pas_OpenType(%S)\n]\
 %IF-NOT-EMPTY
  [%f] pas_OpenType %( %S )% #13#10 
 %END-IF
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	#P%SN = ^T%SN;
 out_indent 'P'
 %S |N ' = ^T'
 %S |N ';'
//	#T%SN = packed record
 out_indent 'T'
 %S |N ' = packed record'
//	<{\n}{%CC=Attribute}#	r%f_to_borland(%CN): %f_type(%C%T);[ // %f_str_replace(%f_Doc(%C),\n,%f_space())]>
 %FOR %ITEM-SEPARATOR #13#10 ; // %ITEM-SEPARATOR 
  %ITEM-CONDITION ( ( %C |C ) %== 'Attribute' ) 
  out_indent '	r'
  [%f] to_borland %( %C |N )% ': '
  [%f] type %( %C ->T  )% ';'
  %IF-NOT-EMPTY
   ' // '
   [%f] str_replace %( [%f] Doc %( %C )% %, #13#10 %, [%f] space %( )% )% 
  %END-IF
 %END-FOR
//	#end;
 out_indent 'end;'
//#UC END# *470F152700FAfor470F33CD0242*
; // pas


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Вложенные стереотипы

//: Struct::Class::Attribute
end. // <<Struct>>

implementation @ :: <<Struct>> <<Attribute>> ;
//? Атрибут
//= InterfaceGeneratorWithJava::MDAGenerator

// Параметры стереотипа
//v +#-
// - типы видимости
//a fr
// - тип абстракции
//Y code_attr.gif
//L code_attr
//A const|ref|const,ref
// - стереотипы "цели" (типа/результата)
//l arl
// - возможные типы связи атрибута

// Генераторы
// генератор idl спецификаций (.idl)
//+ idl
<<generator>> idl OBJECT IN %S
//#UC START# *47022BBE0261for470F3680003E*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	#[{"%SS"="sequence"}{%T<%NN::>%TN}sequence \<%T<%NN::>%TN\>] %SN;
 out_indent %IF ( ( %S |S ) %== 'sequence' ) 
  %ELSE
   %T
   %FOR %N |N '::' 
   %END-FOR
    %T |N 
  %THEN
  'sequence <'
  %T
  %FOR %N |N '::' 
  %END-FOR
   %T |N '>' 
 %END-IF
 ' '
 %S |N ';'
//#UC END# *47022BBE0261for470F3680003E*
; // idl


// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor470F3680003E*
//#UC END# *47022C88029Ffor470F3680003E*
; // h


// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor470F3680003E*
//#UC END# *47022CB8034Bfor470F3680003E*
; // cpp


// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for470F3680003E*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	#private %f_attr(%S) [{}{%f_to_java(%TN)}%f_to_java(%SN)_][{%f_can_be_init(%S)=true}{[ = %f_init(%S)];} = %f_to_java(init_%SN) ();
 out_indent 'private '
 [%f] attr %( %S )% ' '
 %IF ( ) 
  %ELSE
   [%f] to_java %( %T |N )% 
  %THEN
  [%f] to_java %( %S |N )% '_' 
 %END-IF
 %IF ( ( [%f] can_be_init %( %S )% ) %==  true ) 
  %ELSE
   %IF-NOT-EMPTY
    ' = '
    [%f] init %( %S )% 
   %END-IF
   ';' 
  %THEN
  ' = '
  [%f] to_java %( 'init_'
  %S |N )% ' ();'
//	

//	#static private %f_attr(%S) %f_to_java(init_%SN) () {
  out_indent 'static private '
  [%f] attr %( %S )% ' '
  [%f] to_java %( 'init_'
  %S |N )% ' () {'
//	#	%U[{_INIT_%SN}
  out_indent '	'
  %U%IF ( '_INIT_( '
   %S |N ) ) 

//	#	return %f_attr_init_java(%S);
   out_indent '	return '
   [%f] attr_init_java %( %S )% ';'
//	#	]
   out_indent '	' 
  %END-IF
 //	#}]
  out_indent '}' 
 %END-IF
//	
//	#final public %f_attr(%S) %f_to_java(get_%SN) () {
 out_indent 'final public '
 [%f] attr %( %S )% ' '
 [%f] to_java %( 'get_'
 %S |N )% ' () {'
//	#	return %f_to_java(%SN)_;
 out_indent '	return '
 [%f] to_java %( %S |N )% '_;'
//	#}
 out_indent '}'
//	
//	#final public void %f_to_java(set_%SN) (final %f_attr(%S) %f_to_java(%SN)) {
 out_indent 'final public void '
 [%f] to_java %( 'set_'
 %S |N )% ' (final '
 [%f] attr %( %S )% ' '
 [%f] to_java %( %S |N )% ') {'
//	#	%f_to_java(%SN)_ = %f_to_java(%SN);
 out_indent '	'
 [%f] to_java %( %S |N )% '_ = '
 [%f] to_java %( %S |N )% ';'
//	#}
 out_indent '}'
//#UC END# *470321950119for470F3680003E*
; // java


// С++ TIE-обвязка для DLL (_tie.h)
//+ dll.h
<<generator>> dll.h OBJECT IN %S
//#UC START# *47032EC4032Cfor470F3680003E*
//#UC END# *47032EC4032Cfor470F3680003E*
; // dll.h


// Delphi интерфейсы для адаптера (.pas)
//+ pas
<<generator>> pas OBJECT IN %S
//#UC START# *470F152700FAfor470F3680003E*
//#UC END# *470F152700FAfor470F3680003E*
; // pas


// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor470F3680003E*
//R  
//	[%S%f_open_ifdef()
 %IF-NOT-EMPTY
  %S %f open_ifdef %( )% 
//	# ]\
  out_indent ' ' 
 %END-IF
//	%f_N(%S) : %f_pas_TypeName(%S%T);[ // %f_Doc(%S)]\
 [%f] N %( %S )% ' : '
 [%f] pas_TypeName %( %S ->T  )% ';'
 %IF-NOT-EMPTY
  ' // '
  [%f] Doc %( %S )% 
 %END-IF
//	[
 %IF-NOT-EMPTY

//	# %S%f_close_ifdef()]
  out_indent ' '
  %S %f close_ifdef %( )% 
 %END-IF
//#UC END# *470F1571031Cfor470F3680003E*
; // intf.pas


// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor470F3680003E*
//#UC END# *470F15B800CBfor470F3680003E*
; // impl.pas


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
; // st_space_key

<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for470F3680003E*
//c                              {}
//r {<{}{%PS=ServerLibrary}{C}>!=0&%f_to_lower(%PN)=%f_to_lower(%SN)}: {имя %SS не должно совпадать с именем родителя}
//#UC END# *4704C0E30186for470F3680003E*
; // constraint


// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor470F3680003E*
//	attr
 'attr'
//#UC END# *4705CBD6003Efor470F3680003E*
; // wiki_child_kind


//: Struct::Class::ctor::Operation
end. // :: <<Struct>> <<Attribute>> ;

implementation @ :: <<Struct>> <<ctor>> ;
//? Конструктор
//= InterfaceGeneratorWithJava::MDAGenerator

// Параметры стереотипа
//v +#-
// - типы видимости
//Y code_factory.gif
//L code_factory
//T 
// - может не иметь "цели" (типа/результата)

// Генераторы
// генератор idl спецификаций (.idl)
//+ idl
<<generator>> idl OBJECT IN %S
//#UC START# *47022BBE0261for470F36C70128*
//#UC END# *47022BBE0261for470F36C70128*
; // idl


// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor470F36C70128*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	%f_set_var(CTOR,"#%{STRUCT}N (<{, }%f_arg_full_decl(%C)>);")\
 [%f] set_var %( 'CTOR' %, out_indent ( get_global_var ( 'STRUCT' ) |N ) ' ('
 %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
  [%f] arg_full_decl %( %C )% 
 %END-FOR
 ');' )% 
//	%f_set_var(OP_LEN,"%f_string_length("%{CTOR}N")")\
 [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'CTOR' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
 [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 120 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{CTOR}N}#%{STRUCT}N (\n\t\t<{\n\t\t, }%f_arg_full_decl(%C)>\n\t);]
 %IF ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true %&& 
   ( ( %C |x ) %==  true  ) ) 
  %ELSE
   ( get_global_var ( 'CTOR' ) |N ) 
  %THEN
  out_indent ( get_global_var ( 'STRUCT' ) |N ) ' ('#13#10#9#9
  %FOR %ITEM-SEPARATOR #13#10#9#9', ' ; // %ITEM-SEPARATOR 
   [%f] arg_full_decl %( %C )% 
  %END-FOR
  #13#10#9');' 
 %END-IF

//#UC END# *47022C88029Ffor470F36C70128*
; // h


// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor470F36C70128*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	%f_set_var(CTOR,"%f_templ_header(%{STRUCT})%f_function_scope(%{STRUCT})%{STRUCT}N (<{, }%f_arg_full_decl(%C)>)[ : %{STRUCT}<{, }{"%CI"!=""}m_%CN (%CI)>]")\
 [%f] set_var %( 'CTOR' %, [%f] templ_header %( ( get_global_var ( 'STRUCT' ) ) )% [%f] function_scope %( ( get_global_var ( 'STRUCT' ) ) )% ( get_global_var ( 'STRUCT' ) |N ) ' ('
 %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
  [%f] arg_full_decl %( %C )% 
 %END-FOR
 ')'
 %IF-NOT-EMPTY
  ' : '
  ( get_global_var ( 'STRUCT' ) ) 
  %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
   %ITEM-CONDITION ( ( %C |I ) %!= '' ) 
   'm_'
   %C |N ' ('
   %C |I ')' 
  %END-FOR
 %END-IF
)% //	%f_set_var(OP_LEN,"%f_string_length("%{CTOR}N")")\
 [%f] set_var %( 'OP_LEN' %, [%f] string_length %( ( get_global_var ( 'CTOR' ) |N ) )% )% 
//	%f_set_var(NEED_WRAP,"%f_number_cmp("%{OP_LEN}N","120","\>")")\
 [%f] set_var %( 'NEED_WRAP' %, [%f] number_cmp %( ( get_global_var ( 'OP_LEN' ) |N ) %, 120 %, '>' )% )% 
//	[{%f_true(%{NEED_WRAP})=true&%Cx=true}{%{CTOR}N}%f_templ_header(%{STRUCT})%f_function_scope(%{STRUCT})%{STRUCT}N (\n\t<{\n\t, }%f_arg_full_decl(%C)>\n)[ :\n\t%{STRUCT}<{\n\t, }{"%CI"!=""}m_%CN (%CI)>]]
 %IF ( ( [%f] true %( ( get_global_var ( 'NEED_WRAP' ) ) )% ) %==  true %&& 
   ( ( %C |x ) %==  true  ) ) 
  %ELSE
   ( get_global_var ( 'CTOR' ) |N ) 
  %THEN
  [%f] templ_header %( ( get_global_var ( 'STRUCT' ) ) )% [%f] function_scope %( ( get_global_var ( 'STRUCT' ) ) )% ( get_global_var ( 'STRUCT' ) |N ) ' ('#13#10#9
  %FOR %ITEM-SEPARATOR #13#10#9', ' ; // %ITEM-SEPARATOR 
   [%f] arg_full_decl %( %C )% 
  %END-FOR
  #13#10')'
  %IF-NOT-EMPTY
   ' :'#13#10#9
   ( get_global_var ( 'STRUCT' ) ) 
   %FOR %ITEM-SEPARATOR #13#10#9', ' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |I ) %!= '' ) 
    'm_'
    %C |N ' ('
    %C |I ')' 
   %END-FOR
  %END-IF
 %END-IF
//	%U[{_INIT_CTOR_BASE_INIT!cpp!}
 %U%IF ( '_INIT_CTOR_BASE_INIT!cpp!' ) 

//	]
 %END-IF
 //	{%f_start_func_cpp(%S,"%{STRUCT}N::%{STRUCT}N")
 '{'
 [%f] start_func_cpp %( %S %, ( get_global_var ( 'STRUCT' ) |N ) '::'
 ( get_global_var ( 'STRUCT' ) |N ) )% 
//		%U[{_CTOR_BODY!cpp!}
 '	'
 %U%IF ( '_CTOR_BODY!cpp!' ) 

//		throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);
  '	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);'
//		]
  '	' 
 %END-IF
 //	%f_end_func_cpp(%S)}
 [%f] end_func_cpp %( %S )% '}'
//#UC END# *47022CB8034Bfor470F36C70128*
; // cpp


// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for470F36C70128*
//#UC END# *470321950119for470F36C70128*
; // java


// С++ TIE-обвязка для DLL (_tie.h)
//+ dll.h
<<generator>> dll.h OBJECT IN %S
//#UC START# *47032EC4032Cfor470F36C70128*
//#UC END# *47032EC4032Cfor470F36C70128*
; // dll.h


// Delphi интерфейсы для адаптера (.pas)
//+ pas
<<generator>> pas OBJECT IN %S
//#UC START# *470F152700FAfor470F36C70128*
//#UC END# *470F152700FAfor470F36C70128*
; // pas


// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor470F36C70128*
//R  
//	%f_pas_OutStaticCtorInterface(%S)
 [%f] pas_OutStaticCtorInterface %( %S )% 
//#UC END# *470F1571031Cfor470F36C70128*
; // intf.pas


// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor470F36C70128*
//R  
//	%f_pas_OutStaticCtorImplementation(%S)
 [%f] pas_OutStaticCtorImplementation %( %S )% 
//#UC END# *470F15B800CBfor470F36C70128*
; // impl.pas


// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
//+ intf2.pas
<<generator>> intf2.pas OBJECT IN %S
//R  
//#UC START# *477398E501C0for470F36C70128*
//#UC END# *477398E501C0for470F36C70128*
; // intf2.pas


// 3-я секция интерфейса. Например поле для свойства.
//+ intf3.pas
<<generator>> intf3.pas OBJECT IN %S
//R  
//#UC START# *4774D2A20372for470F36C70128*
//#UC END# *4774D2A20372for470F36C70128*
; // intf3.pas


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
; // st_space_key

: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor470F36C70128*
//	mng
 'mng'
//#UC END# *4705CBD6003Efor470F36C70128*
; // wiki_child_kind


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
//%f _IsConstructor
: IsConstructor OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *4AE025440082for470F36C70128*
//	true
 true
//#UC END# *4AE025440082for470F36C70128*
; // IsConstructor


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
//%f _pas_BeforeMethodBodyImplementation
: pas_BeforeMethodBodyImplementation OBJECT IN %S
// параметры: Implementator: void = %1, Modification: void = %2
// возвращаемый результат: a-string
//#UC START# *4B6C4DE70271for470F36C70128*
//	%S%[inherited]\
 inherited
//	%S%f_pas_StaticCtorBeforeMethodBodyImplementation(%1,%2)
 %S %f pas_StaticCtorBeforeMethodBodyImplementation %( %1 %, %2 )% 
//#UC END# *4B6C4DE70271for470F36C70128*
; // pas_BeforeMethodBodyImplementation


//: Struct::Class::sequence::Attribute
end. // :: <<Struct>> <<ctor>> ;

implementation @ :: <<Struct>> <<sequence>> ;
//? Атрибут-массив
//? Определяет атрибут как неограниченный массив элементов заданного типа
//= Struct::Class::Attribute

// Генераторы
// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for470F36E20261*
//#UC END# *46E6D4BB0339for470F36E20261*
; // wiki


// генератор idl спецификаций (.idl)
//+ idl
<<generator>> idl OBJECT IN %S
//#UC START# *47022BBE0261for470F36E20261*
//#UC END# *47022BBE0261for470F36E20261*
; // idl


// генератор idl спецификаций для AMI (.idl)
//+ idl_ami
<<generator>> idl_ami OBJECT IN %S
//#UC START# *47022C0F01E4for470F36E20261*
//#UC END# *47022C0F01E4for470F36E20261*
; // idl_ami


// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor470F36E20261*
//#UC END# *47022C88029Ffor470F36E20261*
; // h


// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor470F36E20261*
//#UC END# *47022CB8034Bfor470F36E20261*
; // cpp


// генератор inline файлов реализации C++ (.i.h)
//+ i.h
<<generator>> i.h OBJECT IN %S
//#UC START# *47022CCF00EAfor470F36E20261*
//#UC END# *47022CCF00EAfor470F36E20261*
; // i.h


// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for470F36E20261*
//#UC END# *470321950119for470F36E20261*
; // java


// генератор реализации фабрик интерфейсов на java (.java)
//+ fctr.java
<<generator>> fctr.java OBJECT IN %S
//#UC START# *470321C1038Afor470F36E20261*
//#UC END# *470321C1038Afor470F36E20261*
; // fctr.java


// С++ TIE-обвязка для DLL (_tie.h)
//+ dll.h
<<generator>> dll.h OBJECT IN %S
//#UC START# *47032EC4032Cfor470F36E20261*
//#UC END# *47032EC4032Cfor470F36E20261*
; // dll.h


// С++ TIE-обвязка для DLL (_tie.cpp)
//+ dll.cpp
<<generator>> dll.cpp OBJECT IN %S
//#UC START# *47032ED002DEfor470F36E20261*
//#UC END# *47032ED002DEfor470F36E20261*
; // dll.cpp


// Delphi интерфейсы для адаптера (.pas)
//+ pas
<<generator>> pas OBJECT IN %S
//#UC START# *470F152700FAfor470F36E20261*
//#UC END# *470F152700FAfor470F36E20261*
; // pas


// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor470F36E20261*
//#UC END# *470F1571031Cfor470F36E20261*
; // intf.pas


// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor470F36E20261*
//#UC END# *470F15B800CBfor470F36E20261*
; // impl.pas


// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
//+ intf2.pas
<<generator>> intf2.pas OBJECT IN %S
//R  
//#UC START# *477398E501C0for470F36E20261*
//#UC END# *477398E501C0for470F36E20261*
; // intf2.pas


// 3-я секция интерфейса. Например поле для свойства.
//+ intf3.pas
<<generator>> intf3.pas OBJECT IN %S
//R  
//#UC START# *4774D2A20372for470F36E20261*
//#UC END# *4774D2A20372for470F36E20261*
; // intf3.pas


// Генератор файлов форм (.dfm)
//+ dfm
<<generator>> dfm OBJECT IN %S
//R  
//#UC START# *49F5795900ECfor470F36E20261*
//#UC END# *49F5795900ECfor470F36E20261*
; // dfm


// Скрипты TC (.sd)
//+ sd
<<generator>> sd OBJECT IN %S
//R  
//#UC START# *4DE79AFC0030for470F36E20261*
//#UC END# *4DE79AFC0030for470F36E20261*
; // sd


// Хак для [$281531116]
//+ link_to_requests_hack
<<generator>> link_to_requests_hack OBJECT IN %S
//#UC START# *4E65F581015Afor470F36E20261*
//#UC END# *4E65F581015Afor470F36E20261*
; // link_to_requests_hack


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
//%f _wiki_up_add_gen
; // st_space_key

: wiki_up_add_gen OBJECT IN %S
//#UC START# *470484D50138for470F36E20261*
//#UC END# *470484D50138for470F36E20261*
; // wiki_up_add_gen



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

end. // :: <<Struct>> <<sequence>> ;

