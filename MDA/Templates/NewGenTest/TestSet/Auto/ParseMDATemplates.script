USES
 'W:\shared\models\NewSchool\Templates\MDATuning.tpl.script'
; 

: "Ничего не делаем"
; // "Ничего не делаем"

: log
 .
 //DROP
; // log

WORDWORKER "начинается с" W-STRING IN aStr
 WordToWork DO aStr WString:Starts
; // "начинается с"

// InitedVarProducer VAR-I

: "Обработать шаблоны MDA"

 ARRAY "Обработанные файлы"

 FORWARD "Обработать файл"

 : "Обработать файл" STRING IN "Имя входного файла"
 
  "Обработанные файлы" "Имя входного файла" array:HasText ? (
   [[ 'duplicated: ' "Имя входного файла" ' skipped' ]] strings:Cat log
   EXIT
  ) // "Обработанные файлы" "Имя входного файла" array:HasString ?
  
  "Имя входного файла" >>>[] "Обработанные файлы"
 
  STRING VAR "Путь к входному файлу"
  "Имя входного файла" sysutils:ExtractFilePath =: "Путь к входному файлу"
  "Путь к входному файлу" log
 
  VAR "Имя выходного файла" 
  "Имя входного файла" '.script' Cat =: "Имя выходного файла"
  
  CONST "Пробел" ' '
  CONST "Пустая строка" ''
  CONST "Кавычка" ''''
  CONST "Открывающаяся скобка" '('
  CONST "Закрывающаяся скобка" ')'
  CONST "Запятая" ','
  CONST "Знак процента" '%'
  CONST "Спецсимволы" '\%[]{}<>#()'
  CONST "Цифры" '1234567890'
  CONST "Разделитель частей стереотипа" '::'
  
  STRING VAR "Имя диска"
  "Имя выходного файла" sysutils:ExtractFileDrive =: "Имя диска"
  
  '\' string:SplitTo! "Имя выходного файла"
  "Имя диска" ?== 'Имя файла не содержит указание диска' ASSERTS
  
  [[ "Имя диска" '\NewSchool\' "Имя выходного файла" ]] strings:Cat =: "Имя выходного файла"
  
  "Имя выходного файла" log
  
  STRING VAR "Путь к выходному файлу"
  "Имя выходного файла" sysutils:ExtractFilePath =: "Путь к выходному файлу"
  "Путь к выходному файлу" log
  
  "Путь к выходному файлу" sysutils:ForceDirectories 'Не удалось создать директории' ASSERTS
  
  //script:FileName sysutils:ExtractFileName "Пустая строка"  "Пробел" Cat "Имя выходного файла" sysutils:ExtractFileName Cat =: "Имя выходного файла"
  
  FILE VAR "Входной файл"
  "Имя входного файла" file:OpenRead =: "Входной файл"
  TRY
   FILE VAR "Выходной файл"
   "Имя выходного файла" file:OpenWrite =: "Выходной файл"
   TRY
   
    W-STRING VAR "Текущая строка входного файла"
    
    : "Строка пустая"
     "Текущая строка входного файла" WString:IsNil
    ; // "Строка пустая"
    
    WORDWORKER "Строка начинается с"
     VAR l_Begin
     WordToWork DO =: l_Begin
     "Текущая строка входного файла" "начинается с" l_Begin
    ; // "Строка начинается с"
   
    WORDWORKER "Строка равна"
     VAR l_EQ
     WordToWork DO =: l_EQ
     "Текущая строка входного файла" l_EQ ?==
    ; // "Строка начинается с"
    
     BOOLEAN VAR "Накапливаемая строка пустая"
     BOOLEAN VAR "Была кавычка"
      
     : "Вывести строку"
      "Выходной файл" file:WriteStr
     ; // "Вывести строку"
    
     : "Вывести кавычку"
      "Кавычка" "Вывести строку"
     ; // "Вывести кавычку"
     
     : "Закрыть кавычку, если была"
      "Была кавычка" ? (
       "Вывести кавычку"
       false =: "Была кавычка"
      ) // "Была кавычка" ?
     ; // "Закрыть кавычку, если была"
      
     : "Вывести пробел"
      "Пробел" "Вывести строку"
     ; // "Вывести пробел"
     
     : "Сбросить накопленную строку без перевода"
      "Накапливаемая строка пустая" ! ? (
      
       "Закрыть кавычку, если была"
        
       "Вывести пробел" 
       true =: "Накапливаемая строка пустая"
       false =: "Была кавычка"
      ) // "Накапливаемая строка" string:Len !=0 ?
     ; // "Сбросить накопленную строку без перевода"
     
     BOOLEAN VAR "Был отступ"
     
     : "Перевести строку"
      "Закрыть кавычку, если была"
      "Пустая строка" "Выходной файл" file:WriteLn
      false =: "Был отступ"
      "Была кавычка" ! 'Похоже не закрыли кавычку' ASSERTS 
      //false =: "Была кавычка"
     ; // "Перевести строку"
     
     : "Сбросить накопленную строку"
      "Накапливаемая строка пустая" ! ? (
      
       "Закрыть кавычку, если была"
        
       "Перевести строку"
       true =: "Накапливаемая строка пустая"
      ) // "Накапливаемая строка" string:Len !=0 ?
     ; // "Сбросить накопленную строку"
     
     : "Сбросить накопленную строку, чтобы кавычка случайно не переехала на другую строку"
      "Сбросить накопленную строку"
     ; // "Сбросить накопленную строку, чтобы кавычка случайно не переехала на другую строку"
      
     : "Вывести строку как есть"
      "Текущая строка входного файла" "Выходной файл" file:WriteWStrLn
     ; // "Вывести строку как есть"
     
     : "Добавить к строке / и вывести"
      "Сбросить накопленную строку, чтобы кавычка случайно не переехала на другую строку"
      '/' "Вывести строку"
      "Вывести строку как есть"
     ; // "Добавить к строке / и вывести"
     
     : "Вывести строку как комментарий. Чтобы в конечном файле было с чем сравнивать"
      "Сбросить накопленную строку, чтобы кавычка случайно не переехала на другую строку"
      "Был отступ"  ? "Перевести строку"
      '//' "Вывести строку"
      "Вывести строку как есть"
      false =: "Был отступ"
     ; // "Вывести строку как комментарий. Чтобы в конечном файле было с чем сравнивать"
     
     BOOLEAN VAR "Был открыт стереотип" 
      false =: "Был открыт стереотип"
     STRING VAR "Имя стереотипа"
      "Пустая строка" =: "Имя стереотипа" 
     STRING VAR "Имя класса стереотипа"
      "Пустая строка" =: "Имя класса стереотипа" 
     STRING VAR "Имя под-стереотипа"
      "Пустая строка" =: "Имя под-стереотипа" 
     STRING VAR "Имя класса под-стереотипа"
      "Пустая строка" =: "Имя класса под-стереотипа" 
     STRING VAR "Имя под-под-стереотипа"
      "Пустая строка" =: "Имя под-под-стереотипа" 
     STRING VAR "Имя класса под-под-стереотипа"
      "Пустая строка" =: "Имя класса под-под-стереотипа"
     
     BOOLEAN VAR "Была открыта функция"
      false =: "Была открыта функция" 
     STRING VAR "Имя функции"
      "Пустая строка" =: "Имя функции"
     BOOLEAN VAR "Был открыт трансформатор"
      false =: "Был открыт трансформатор" 
     STRING VAR "Имя трансформатора"
      "Пустая строка" =: "Имя трансформатора"
     
     BOOLEAN VAR "Был открыт генератор"
      false =: "Был открыт генератор"
     STRING VAR "Имя генератора"
      "Пустая строка" =: "Имя генератора"
     
     CONST Разделители ' '
     CONST "Двойная кавычка" '"'
     CONST "Параметр Self" ' OBJECT IN %S'
     CONST "Скобка закрытия функции" '; // '
     CONST "Открываем строку стереотипа" '<<'
     CONST "Закрываем строку стереотипа" '>>'
     CONST "Табуляция" #9
     
     : "Вывести строку с переводом строки"
      "Вывести строку"
      "Перевести строку"
     ; // "Вывести строку с переводом строки"
     
     : "Вывести исходную строку"
      "Текущая строка входного файла" "Выходной файл" file:WriteWStr
     ; // "Вывести исходную строку"
     
     : "Записать имя стереотипа"
      "Имя под-стереотипа" string:Len !=0 IF
       ':: ' "Вывести строку"
       "Имя стереотипа" "Вывести строку"
       "Пробел" "Вывести строку"
       "Имя под-стереотипа" "Вывести строку"
       
       "Имя под-под-стереотипа" string:Len !=0 IF
        "Пробел" "Вывести строку"
        "Имя под-под-стереотипа" "Вывести строку"
       ENDIF // "Имя под-под-стереотипа" string:Len !=0 IF
       
       ' ;' "Вывести строку"
       
      ELSE
       "Имя стереотипа" "Вывести строку"
      ENDIF //  "Имя под-стереотипа" string:Len !=0
      "Перевести строку"
     ; // "Записать имя стереотипа"
     
     : "Записать имя функции"
      "Имя функции" "Вывести строку"
     ; // "Записать имя функции"
     
     : "Записать имя трансформатора"
      "Имя трансформатора" "Вывести строку"
     ; // "Записать имя трансформатора"
     
     : "Записать имя генератора"
      "Имя генератора" "Вывести строку"
     ; // "Записать имя генератора"
     
     FORWARD "Закрыть вложенные опеределения"
     
     : "Закрыть стереотип"
      "Был открыт стереотип" ?
       ( 
        "Закрыть вложенные опеределения"
        'end. // ' "Вывести строку" 
        "Записать имя стереотипа"
        "Перевести строку"
       ) // "Был открыт стереотип" ?
      false =: "Был открыт стереотип"
     ; // "Закрыть стереотип"
     
     INTEGER VAR "Отступ"
     INTEGER VAR "Количество открытых IF"
     INTEGER VAR "Количество открытых циклов"
     INTEGER VAR "Количество открытых скобок параметров функции"
      
     : "Закрыть все скобки"
      0 =: "Отступ"
      0 =: "Количество открытых IF"
      0 =: "Количество открытых циклов"
      0 =: "Количество открытых скобок параметров функции"
      "Закрыть вложенные опеределения"
      "Закрыть стереотип"
     ; // "Закрыть все скобки"
     
     : "Закавычить имя стереотипа"
      Разделители "Имя стереотипа" string:HasAnyOf ? (
       [[ "Двойная кавычка" "Имя стереотипа" "Двойная кавычка" ]]
        strings:Cat =: "Имя стереотипа"
      )
     
      "Имя класса стереотипа" 'MDAGenerator' ?!= ? (
       [[ "Открываем строку стереотипа" "Имя стереотипа" "Закрываем строку стереотипа" ]] 
        strings:Cat =: "Имя стереотипа"
      )
     ; // "Закавычить имя стереотипа"
     
     : "Закавычить имя под-стереотипа"
      "Имя под-стереотипа" string:Len !=0 ? (
       Разделители "Имя под-стереотипа" string:HasAnyOf ? (
        [[ "Двойная кавычка" "Имя под-стереотипа" "Двойная кавычка" ]]
         strings:Cat =: "Имя под-стереотипа"
       ) // Разделители "Имя под-стереотипа" string:HasAnyOf ?
      
       // "Имя класса стереотипа" 'MDAGenerator' ?!= 
       true ? (
        [[ "Открываем строку стереотипа" "Имя под-стереотипа" "Закрываем строку стереотипа" ]] 
         strings:Cat =: "Имя под-стереотипа"
       ) // true ?
      ) // "Имя под-стереотипа" string:Len !=0 ?
     ; // "Закавычить имя под-стереотипа"
     
     : "Открыть стереотип"
      "Был открыт стереотип" ! ? (
        'implementation @ ' "Вывести строку"
        
        "Записать имя стереотипа"
        true =: "Был открыт стереотип"
      ) // "Был открыт стереотип" !
     ; // "Открыть стереотип"
     
     : "Разобрать заголовок стереотипа"
     
      "Закрыть стереотип"
      
      2 WString:+! "Текущая строка входного файла"
      "Текущая строка входного файла" WString:ToString =: "Имя стереотипа"
      
      "Имя стереотипа" "Разделитель частей стереотипа" string:Split
      
      =: "Имя класса стереотипа"
      =: "Имя стереотипа"
      
      "Имя класса стереотипа" "Разделитель частей стереотипа" string:Split
      =: "Имя под-стереотипа"
      =: "Имя класса стереотипа"
      
      "Имя под-стереотипа" "Разделитель частей стереотипа" string:Split
      =: "Имя класса под-стереотипа"
      =: "Имя под-стереотипа"
      
      "Имя класса под-стереотипа" "Разделитель частей стереотипа" string:Split
      =: "Имя под-под-стереотипа"
      =: "Имя класса под-стереотипа"
      
      "Закавычить имя стереотипа"
      "Закавычить имя под-стереотипа"
      
      "Открыть стереотип"
      
     ; // "Разобрать заголовок стереотипа"
     
     : "Закрыть функцию"
      "Была открыта функция" ? ( "Скобка закрытия функции" "Вывести строку" "Записать имя функции" 
      "Перевести строку"
      "Перевести строку"
      )
      false =: "Была открыта функция"
     ; // "Закрыть функцию"
     
     : "Закрыть трансформатор"
      "Был открыт трансформатор" ? ( "Скобка закрытия функции" "Вывести строку" "Записать имя трансформатора" 
      "Перевести строку"
      "Перевести строку"
      )
      false =: "Был открыт трансформатор"
     ; // "Закрыть трансформатор"
     
     : "Закрыть генератор"
      "Был открыт генератор" ? ( "Скобка закрытия функции" "Вывести строку" "Записать имя генератора" 
      "Перевести строку"
      "Перевести строку"
      )
      false =: "Был открыт генератор"
     ; // "Закрыть генератор"
     
//     : "Было открыто хоть одно вложенное определение"
//      "Была открыта функция" %|| 
//      "Был открыт трансформатор" %|| 
//      "Был открыт генератор"
//     ; // "Было открыто хоть одно вложенное определение"
     
     : "Закрыть вложенные опеределения"
      "Закрыть генератор"
      "Закрыть функцию"
      "Закрыть трансформатор"
      false =: "Был отступ"
     ; // "Закрыть вложенные опеределения"
     
     : "Записать параметры функции" BOOLEAN IN aGlobal
      "Параметр Self" "Вывести строку"
     ; // "Записать параметры функции"
     
     : "Записать параметры трансформатора" BOOLEAN IN aGlobal
      "Параметр Self" "Вывести строку"
     ; // "Записать параметры трансформатора"
     
     : "Разобрать заголовок функции" BOOLEAN IN aGlobal
      "Закрыть вложенные опеределения"
      aGlobal IF
       "Закрыть стереотип"
      ELSE
       "Открыть стереотип"
      ENDIF 
      
      aGlobal IF
       2 WString:+! "Текущая строка входного файла"
       // - отрезаем f
      ELSE 
       3 WString:+! "Текущая строка входного файла"
       // - отрезаем %f
      ENDIF
       
      "Строка начинается с" '_' ? WString:++! "Текущая строка входного файла"
      // - отрезаем поддчёркивание
      "Текущая строка входного файла" WString:ToString =: "Имя функции"
      // - получаем имя текущей функции
      
      ': ' "Вывести строку"
      "Записать имя функции"
      
      aGlobal "Записать параметры функции"
      
      "Перевести строку"
      
      true =: "Была открыта функция"
     ; // "Разобрать заголовок функции"
     
     : "Разобрать заголовок трансформатора" IN aGlobal
      "Закрыть вложенные опеределения"
      aGlobal IF
       "Закрыть стереотип"
      ELSE
       "Открыть стереотип"
      ENDIF 
      
      aGlobal IF
       2 WString:+! "Текущая строка входного файла"
       // - отрезаем t
      ELSE 
       3 WString:+! "Текущая строка входного файла"
       // - отрезаем %t
      ENDIF
       
      "Строка начинается с" '_' ? WString:++! "Текущая строка входного файла"
      // - отрезаем поддчёркивание
      "Текущая строка входного файла" WString:ToString =: "Имя трансформатора"
      // - получаем имя текущего трансформатора
      
      '<<transformator>> ' "Вывести строку"
      "Записать имя трансформатора"
      
      aGlobal "Записать параметры трансформатора"
      
      "Перевести строку"
      
      true =: "Был открыт трансформатор"
     ; // "Разобрать заголовок трансформатора"
     
     : "Разобрать заголовок функции стереотипа"
      false "Разобрать заголовок функции"
     ; // "Разобрать заголовок функции стереотипа"
     
     : "Разобрать заголовок глобальной функции"
      true "Разобрать заголовок функции"
     ; // "Разобрать заголовок глобальной функции"
     
     : "Разобрать заголовок трансформатора стереотипа"
      false "Разобрать заголовок трансформатора"
     ; // "Разобрать заголовок трансформатора стереотипа"
     
     : "Разобрать заголовок глобального трансформатора"
      true "Разобрать заголовок трансформатора"
     ; // "Разобрать заголовок глобального трансформатора"
     
     : "Записать параметры генератора"
      "Параметр Self" "Вывести строку"
     ; // "Записать параметры генератора"
     
     : "Разобрать заголовок генератора"
      "Закрыть вложенные опеределения"
      
      2 WString:+! "Текущая строка входного файла"
      "Текущая строка входного файла" WString:ToString =: "Имя генератора"
      
      "Открыть стереотип"
      
      '<<generator>> ' "Вывести строку"
      "Записать имя генератора"
      
      "Записать параметры генератора"
      
      "Перевести строку"
      
      true =: "Был открыт генератор"
     ; // "Разобрать заголовок генератора"
     
     BOOLEAN FUNCTION "Обрабатываем незначащие строки" BOOLEAN IN "Надо переводить строку"
     
      : "Вывести комментарий, котрый был в исходном файле"
       "Сбросить накопленную строку, чтобы кавычка случайно не переехала на другую строку"
       "Надо переводить строку" IF
        "Перевести строку"
       ELSE
        "Был отступ"  ? "Перевести строку"
       ENDIF // "Надо переводить строку"
       "Вывести строку как есть"
      ; // "Вывести комментарий, котрый был в исходном файле"
     
      : "Сигнализировать о неуспехе"
       false =: Result
      ; // "Сигнализировать о неуспехе"
      
      true =: Result
      // - будем оптимистами
      RULES
       "Строка пустая"
        ( 
         "Закрыть кавычку, если была"
         "Надо переводить строку" ? "Перевести строку"
         "Вывести строку как есть"
        ) // "Строка пустая"
       "Строка начинается с" '//#UC END# *'
        (
         "Вывести комментарий, котрый был в исходном файле"
         "Закрыть вложенные опеределения"
          // - т.к. наверное функция, трансформатор или генератор - закончились
        ) 
       "Строка начинается с" '//'
        "Вывести комментарий, котрый был в исходном файле"
       "Строка начинается с" '/'
        (
         "Надо переводить строку" ? "Перевести строку"
         "Добавить к строке / и вывести"
        ) // "Строка начинается с" '/'
       DEFAULT
        "Сигнализировать о неуспехе"
      ; // RULES
     ; // "Обрабатываем незначащие строки"
     
     : "Обрабатываем незначащие строки без перевода строки перед ними"
      false "Обрабатываем незначащие строки"
     ; // "Обрабатываем незначащие строки без перевода строки перед ними"
     
     : "Обрабатываем незначащие строки с переводом строки перед ними"
      true "Обрабатываем незначащие строки"
     ; // "Обрабатываем незначащие строки с переводом строки перед ними"
     
     : "Разбираем код функции шаблона с начала строки"
     
      : "Увеличить отступ"
       1 +! "Отступ"
      ; // "Увеличить отступ"
      
      : "Уменьшить отступ"
       -1 +! "Отступ"
      ; // "Уменьшить отступ"
      
      : "Вывести отступ"
       "Был отступ" ! ? (
        "Отступ" "Пробел" char:Dupe "Вывести строку"
        true =: "Был отступ"
       ) // "Был отступ" ! ? 
      ; // "Вывести отступ"
      
      true =: "Накапливаемая строка пустая"
      false =: "Была кавычка"
      
      : "Открыть кавычку, если не было"
        "Была кавычка" ! ? (
         "Вывести кавычку"
         true =: "Была кавычка"
        ) // "Была кавычка" ! ?
      ; // "Открыть кавычку, если не было"  
        
      : "Вывести отступ, если накапливаемая строка пустая"
       "Накапливаемая строка пустая" ? "Вывести отступ"
      ; // "Вывести отступ, если накапливаемая строка пустая"
      
      : "Добавить спецстроку к накапливаемой строке" STRING IN aStr
      
       "Вывести отступ, если накапливаемая строка пустая"
       
       "Закрыть кавычку, если была"
       
       aStr "Вывести строку"
       // - пишем собственно спецстроку
       
       false =: "Накапливаемая строка пустая"
      
      ; // "Добавить спецстроку к накапливаемой строке"
      
      : "Выводим следующий символ как есть"
      
       "Текущая строка входного файла" WString:Len !=0 ? (
       
        "Вывести отступ, если накапливаемая строка пустая"
        
        "Открыть кавычку, если не было"
        
        WString:[]++! "Текущая строка входного файла"
        DUP "Кавычка" ?== ? "Вывести кавычку"
        // - удваиваем кавычку
        "Выходной файл" file:WriteChar
        // - кладём символ в стек и сдвигаем указатель и пишем символ в файл
        false =: "Накапливаемая строка пустая"
       ) // "Текущая строка входного файла" WString:Len !=0 ?
       
      ; // "Выводим следующий символ как есть"
      
      : "Выводим следующий символ после \"
      
       WString:++! "Текущая строка входного файла"
       // - отрезаем \
       
       "Текущая строка входного файла" WString:Len !=0 ? (
        RULES
         "Строка начинается с" 'n'
          ( 
            WString:++! "Текущая строка входного файла"
            
            '#13#10' "Добавить спецстроку к накапливаемой строке"
          )
         "Строка начинается с" 't'
          ( 
            WString:++! "Текущая строка входного файла"
            
            '#9' "Добавить спецстроку к накапливаемой строке"
          )
         DEFAULT
          "Выводим следующий символ как есть"
        ; // RULES   
       )  // "Текущая строка входного файла" WString:Len !=0 ?
      ; // "Выводим следующий символ после \"
       
      : "Сбросить накопленную строку и вывести отступ"
       "Сбросить накопленную строку"
       "Вывести отступ"
      ; // "Сбросить накопленную строку и вывести отступ"
      
      : "По любому пишем пробел, чтобы не слипалось с последующими строками"
       "Вывести пробел"
      ; // По любому пишем пробел, чтобы не слипалось с последующими строками"
      
      : "Вывести значение для пустой строки"
       "Вывести кавычку"
       "Вывести кавычку"
      ; // "Вывести значение для пустой строки"
      
      : "Увеличить количество открытых скобок параметров функции"
       1 +! "Количество открытых скобок параметров функции"
      ; // "Увеличить количество открытых скобок параметров функции"
      
      : "Уменьшить количество открытых скобок параметров функции"
       -1 +! "Количество открытых скобок параметров функции"
      ; // "Увеличить количество открытых скобок параметров функции"
      
      FORWARD "Обработать строку начинающуюся с % как начало цепочки"
      FORWARD "Обработать строку начинающуюся с % как вызов метода объекта"
      FORWARD "Один проход разбора остатка"
      
      : "Один проход разбора остатка без учёта его результата"
      "Один проход разбора остатка" DROP
      ; // "Один проход разбора остатка без учёта его результата"
      
      : "Увеличить количество открытых IF"
       1 +! "Количество открытых IF"
      ; // "Увеличить количество открытых IF"
      
      : "Уменьшить количество открытых IF"
       -1 +! "Количество открытых IF"
      ; // "Уменьшить количество открытых IF"
      
      : "Увеличить количество открытых циклов"
       1 +! "Количество открытых циклов"
      ; // "Увеличить количество открытых циклов"
      
      : "Уменьшить количество открытых циклов"
       -1 +! "Количество открытых циклов"
      ; // "Уменьшить количество открытых циклов"
      
      FORWARD "Разобрать фактические параметры условия"
      FORWARD "Разобрать параметры 1-й части цикла"
      FORWARD "Разобрать параметры 3-й части цикла"
      FORWARD "Разобрать код ветки ELSE"
      FORWARD "Обрабатываем END-IF"
      FORWARD "Обрабатываем конец цикла"
      
      : "Обрабатываем условие" BOOLEAN IN "Нужен ли отступ"
        WString:++! "Текущая строка входного файла"
        // - отрезаем {
        //"Перевести строку"
        "Нужен ли отступ" ? "Вывести отступ"
        //"Вывести пробел"
        '( ' "Вывести строку"
        "Разобрать фактические параметры условия"
        //"Перевести строку"
        //"Вывести отступ"
        ') ' "Вывести строку"
        "Перевести строку"
      ; // "Обрабатываем условие"
      
      : "Обрабатываем условие без отступа"
       false "Обрабатываем условие"
      ; // "Обрабатываем условие без отступа"
       
      : "Обрабатываем условие с отступом"
       false "Обрабатываем условие"
      ; // "Обрабатываем условие с отступом"
      
      FORWARD "Разобрать параметры тела IF"
      FORWARD "Обрабатываем тело END-IF"
      
      : "Обрабатываем IF"
       "Увеличить количество открытых IF"
       TRY
        WString:++! "Текущая строка входного файла"
        // - отрезаем [
        //"Был отступ" ? "Перевести строку"
        "Сбросить накопленную строку и вывести отступ"
        
        "Строка начинается с" '{' IF
         '%IF' "Вывести строку"
         // - пишем "наш" IF
         "По любому пишем пробел, чтобы не слипалось с последующими строками"
        ELSE
         '%IF-NOT-EMPTY' "Вывести строку"
         // - пишем "наш" IF, который будет проверять, что вычислились параметры
         "Перевести строку"
        ENDIF // "Строка начинается с" '{'
        
        "Увеличить отступ"
        
        "Строка начинается с" '{' ? 
         "Обрабатываем условие без отступа"
        
        "Строка начинается с" '{' ? (
         WString:++! "Текущая строка входного файла"
         // - отрезаем {
         //"Перевести строку"
         "Вывести отступ"
         //"Вывести пробел"
         '%ELSE' "Вывести строку"
         "Перевести строку"
         "Увеличить отступ"
         TRY
          "Разобрать код ветки ELSE"
          "Был отступ" ? ( 
           "Перевести строку"
          ) // "Был отступ" ?
         FINALLY
          "Уменьшить отступ"
         END // TRY..FINALLY 
         "Вывести отступ"
         '%THEN' "Вывести строку"
         "Перевести строку"
        ) // "Строка начинается с" '{'
        
        "Разобрать параметры тела IF"
       FINALLY
        "Обрабатываем тело END-IF"
       END // TRY..FINALLY 
      ; // "Обрабатываем IF"
      
      FORWARD "Обрабатываем тело конца цикла"
      FORWARD "Разобрать параметры тела цикла"
      
      : "Обрабатываем начало цикла"
       "Увеличить количество открытых циклов"
       TRY
        WString:++! "Текущая строка входного файла"
        // - отрезаем <
        
        "Накапливаемая строка пустая" IF
         "Был отступ" ? "Перевести строку"
         "Вывести отступ"
        ELSE
         "Сбросить накопленную строку и вывести отступ"
        ENDIF 
        
        '%FOR' "Вывести строку"
        // - пишем "наш" IF
        "По любому пишем пробел, чтобы не слипалось с последующими строками"
        
        "Увеличить отступ"
        
        "Строка начинается с" '{' ? 
         (
          1 "Текущая строка входного файла" WString:[i] '}' ?!= IF
           WString:++! "Текущая строка входного файла"
           // - отрезаем {
           '%ITEM-SEPARATOR ' "Вывести строку"
           "Разобрать параметры 1-й части цикла"
           '; // %ITEM-SEPARATOR ' "Вывести строку"
           "Перевести строку"
          ELSE
           2 WString:+! "Текущая строка входного файла"
           // - отрезаем {}
          ENDIF // 1 "Текущая строка входного файла" WString:[i] '}' ?!= IF 
         ) // "Строка начинается с" '{' ?
        
        "Строка начинается с" '{' ? 
         (
          1 "Текущая строка входного файла" WString:[i] '}' ?!= IF
           "Вывести отступ" '%ITEM-CONDITION ' "Вывести строку"
           "Обрабатываем условие с отступом"
          ELSE
           2 WString:+! "Текущая строка входного файла"
           // - отрезаем {}
          ENDIF // 1 "Текущая строка входного файла" WString:[i] '}' ?!= IF 
         ) // "Строка начинается с" '{' ?
        
        "Строка начинается с" '{' ? (
         WString:++! "Текущая строка входного файла"
         // - отрезаем {
         "Вывести отступ"
         '( ' "Вывести строку"
         "Разобрать параметры 3-й части цикла"
         ') ' "Вывести строку"
         "Перевести строку"
        ) // "Строка начинается с" '{'
        
        "Разобрать параметры тела цикла"
       
       FINALLY 
        "Обрабатываем тело конца цикла"
       END
      ; // "Обрабатываем начало цикла"
      
      : "Обрабатываем тело конца цикла"
       "Сбросить накопленную строку"
       
       "Уменьшить отступ"
       
       "Был отступ" ? "Перевести строку"
       "Вывести отступ"
       
       '%END-FOR' "Вывести строку"
       // - пишем "наш" END-FOR
       //"По любому пишем пробел, чтобы не слипалось с последующими строками"
       "Перевести строку"
       
       "Уменьшить количество открытых циклов"
      ; // "Обрабатываем тело конца цикла"
      
      BOOLEAN FUNCTION "Обрабатываем конец цикла"
       "Количество открытых циклов" =0 IF
       // - видимо это какая-то другая скобка, например от inherited
        false =: Result
       ELSE
        true =: Result
        WString:++! "Текущая строка входного файла"
        // - отрезаем >
        "Обрабатываем тело конца цикла"
       ENDIF // "Количество открытых IF" =0
      ; // "Обрабатываем конец цикла"
      
      : "Разобрать фактические параметры" 
        STRING IN "Закрывающаяся скобка" 
        BOOLEAN IN "Надо ли разбирать условие"
        BOOLEAN IN "Надо ли разбирать булевские значения"
        BOOLEAN IN "Надо ли разбирать цифры"
        BOOLEAN IN "Надо ли разбирать запятые"
        BOOLEAN IN "Надо ли считать скобки"
        
       BOOLEAN VAR "Первый проход разбора параметра" 
       true =: "Первый проход разбора параметра"
       BOOLEAN VAR "Следующее значение переменной Первый проход разбора параметра" 
       false =: "Следующее значение переменной Первый проход разбора параметра"
       
       BOOLEAN VAR "Встретилась закрывающаяся скобка"
       false =: "Встретилась закрывающаяся скобка"
       
       INTEGER VAR "Сохранённое количество открытых скобок параметров функции"

       "Количество открытых скобок параметров функции" =: "Сохранённое количество открытых скобок параметров функции"
       "Увеличить количество открытых скобок параметров функции"
       
       BOOLEAN VAR "Была открыта операторная скобка"
        false =: "Была открыта операторная скобка"
        
       : "Открыть операторную скобку"
        "Была открыта операторная скобка" ! ? (
         "Перевести строку" "Вывести отступ"
         ' ( ' "Вывести строку"
         true =: "Была открыта операторная скобка"
        ) // "Была открыта операторная скобка"
       ; // "Открыть операторную скобку" 
       
       : "Закрыть операторную скобку"
        "Была открыта операторная скобка" ? (
         ' ) ' "Вывести строку"
         false =: "Была открыта операторная скобка"
        ) // "Была открыта операторная скобка"
       ; // "Закрыть операторную скобку" 
       
       INTEGER VAR "Число дополнительных открытых скобок"
        0 =: "Число дополнительных открытых скобок"
        
       BOOLEAN VAR "Двойная кавычка была открыта"
        false =: "Двойная кавычка была открыта"
        //'Двойная кавычка была открыта' log "Двойная кавычка была открыта" log
        
       BOOLEAN VAR "Надо ли считать кавычки"
        false =: "Надо ли считать кавычки"
       
       "Надо ли считать скобки" ! ? (
        ( "Закрывающаяся скобка" %== ')' ) ? (
         true =: "Надо ли считать кавычки"
         //false =: "Надо ли считать кавычки"
        ) // "Закрывающаяся скобка" %== ')' ) ?
       )  // "Надо ли считать скобки" ! ?
       
       TRY 
        @ ( %! ( "Входной файл" file:EOF ) %&&
            // ( "Текущая строка входного файла" WString:Len !=0 ) %&& 
            %! "Встретилась закрывающаяся скобка" ) WHILE
        BEGIN
         false =: "Следующее значение переменной Первый проход разбора параметра"
         
         //"Текущая строка входного файла" WString:[] log
         
         RULES
          "Строка начинается с" '(' 
           (
            "Надо ли считать скобки" ? (
             ( "Закрывающаяся скобка" %== ')' ) ? (
              ++! "Число дополнительных открытых скобок"
             ) // ( "Закрывающаяся скобка" %== ')' ) ?
            ) // "Надо ли считать скобки" ? 
            "Один проход разбора остатка без учёта его результата"
           ) // "Строка начинается с" '(' 
          "Строка начинается с" "Знак процента"
           (
            "Надо ли разбирать условие" IF
             // - тут экранируем условие
             "Вывести отступ"
             '( ' "Вывести строку"
             "Обработать строку начинающуюся с % как начало цепочки"
             ') ' "Вывести строку"
            ELSE
             "Обработать строку начинающуюся с % как начало цепочки"
            ENDIF // "Надо ли разбирать условие" 
           ) // "Строка начинается с" "Знак процента"
          "Строка начинается с" "Закрывающаяся скобка"
           ( 
            BOOLEAN VAR "Скобка подходит"
             true =: "Скобка подходит"
             
             //'скобка' log
             //"Закрывающаяся скобка" log
             
             "Надо ли считать скобки" IF
              ( "Число дополнительных открытых скобок" %== 0 ) =: "Скобка подходит"
             ELSE
              //'Двойная кавычка была открыта' log "Двойная кавычка была открыта" log
              "Надо ли считать кавычки" IF
               ( "Двойная кавычка была открыта" ! ) =: "Скобка подходит"
              ELSE
               true =: "Скобка подходит"
              ENDIF 
             ENDIF
             
            //'Скобка подходит' log
            //"Скобка подходит" log
             
            "Скобка подходит" IF
             "Сбросить накопленную строку без перевода"
             WString:++! "Текущая строка входного файла"
             // - отрезаем скобку
             true =: "Встретилась закрывающаяся скобка"
             "Уменьшить количество открытых скобок параметров функции"
            ELSE 
             "Надо ли считать скобки" ? (
              --! "Число дополнительных открытых скобок"
             ) // "Надо ли считать скобки" ?
             "Один проход разбора остатка без учёта его результата"
            ENDIF 
           ) // "Строка начинается с" "Закрывающаяся скобка"
          (
           "Надо ли разбирать запятые" %&&
           "Строка начинается с" ',,'
          ) 
           ( 
            : "Пустой параметр"
             "Вывести значение для пустой строки"
            ; // "Пустой параметр"
            
            "Сбросить накопленную строку без перевода"
            2 WString:+! "Текущая строка входного файла"
            // - отрезаем ',,'
            //"Вывести пробел"
            '%, ' "Вывести строку"
            // - выводим такую хитрую запятую, которая будет склеивать все параметры перед ней в один
            "Пустой параметр"
            ' %, ' "Вывести строку"
            // - выводим такую хитрую запятую, которая будет склеивать все параметры перед ней в один
            true =: "Следующее значение переменной Первый проход разбора параметра"
           ) // "Строка начинается с" ',,'
          (
           "Надо ли разбирать запятые" %&&
           "Строка начинается с" "Запятая"
          ) 
           ( 
            "Сбросить накопленную строку без перевода"
            WString:++! "Текущая строка входного файла"
            // - отрезаем запятую
            //"Вывести пробел"
            '%, ' "Вывести строку"
            // - выводим такую хитрую запятую, которая будет склеивать все параметры перед ней в один
            true =: "Следующее значение переменной Первый проход разбора параметра"
           ) // "Строка начинается с" "Запятая"
          "Строка начинается с" '""'
           ( 
            2 WString:+! "Текущая строка входного файла"
            // - отрезаем две двойных кавычки
            "Вывести значение для пустой строки"
            "Вывести пробел"
           ) // "Строка начинается с" '""'
          "Строка начинается с" '"true"'
           ( 
            6 WString:+! "Текущая строка входного файла"
            // - отрезаем "true"
            'true ' "Вывести строку"
           ) // "Строка начинается с" '"true"'
          "Строка начинается с" '"false"'
           ( 
            7 WString:+! "Текущая строка входного файла"
            // - отрезаем "false"
            'false ' "Вывести строку"
           ) // "Строка начинается с" '"false"'
          "Строка начинается с" "Двойная кавычка"
           (
            //'got' log
            //'Двойная кавычка была открыта' log "Двойная кавычка была открыта" log
            "Двойная кавычка была открыта" ! =: "Двойная кавычка была открыта"
            //'Двойная кавычка была открыта' log "Двойная кавычка была открыта" log
            "Накапливаемая строка пустая" IF
             WString:++! "Текущая строка входного файла"
            ELSE 
             CHAR VAR "Следующий символ"
              ( 1 "Текущая строка входного файла" WString:[i] ) =: "Следующий символ"
             (
              ( "Следующий символ" %== "Закрывающаяся скобка" ) %||
              ( "Следующий символ" %== '=' ) %||
              ( "Надо ли разбирать условие" %&&
               (
                ( "Следующий символ" %== '|' ) %||
                ( "Следующий символ" %== '&' )
               ) 
              ) 
             ) IF
              "Сбросить накопленную строку без перевода"
              WString:++! "Текущая строка входного файла"
             ELSE
              //'got1' log
              "Один проход разбора остатка без учёта его результата"
             ENDIF 
            ENDIF
           ) // "Строка начинается с" "Двойная кавычка"
          "Строка начинается с" 'true'
           (
            "Надо ли разбирать булевские значения" %&& "Накапливаемая строка пустая" IF
             4 WString:+! "Текущая строка входного файла"
             "Сбросить накопленную строку без перевода"
             "Вывести отступ"
             ' true ' "Вывести строку"
            ELSE
             "Один проход разбора остатка без учёта его результата"
            ENDIF // "Надо ли разбирать условие"
           ) // "Строка начинается с" 'true'
          "Строка начинается с" 'false'
           (
            "Надо ли разбирать булевские значения" %&& "Накапливаемая строка пустая" IF
             5 WString:+! "Текущая строка входного файла"
             "Сбросить накопленную строку без перевода"
             "Вывести отступ"
             ' false ' "Вывести строку"
            ELSE
             "Один проход разбора остатка без учёта его результата"
            ENDIF // "Надо ли разбирать условие"
           ) // "Строка начинается с" 'false'
          "Строка начинается с" '!='
           (
            "Надо ли разбирать условие" IF
             2 WString:+! "Текущая строка входного файла"
             "Сбросить накопленную строку без перевода"
             "Вывести отступ"
             '%!= ' "Вывести строку"
             true =: "Следующее значение переменной Первый проход разбора параметра"
            ELSE
             "Один проход разбора остатка без учёта его результата"
            ENDIF // "Надо ли разбирать условие"
           ) // "Строка начинается с" '!='
          "Строка начинается с" '='
           (
            //'got 3' log
            //"Закрывающаяся скобка" log
            "Надо ли разбирать условие" IF
            //'got 4' log
             WString:++! "Текущая строка входного файла"
             "Сбросить накопленную строку без перевода"
             "Вывести отступ"
             '%== ' "Вывести строку"
             true =: "Следующее значение переменной Первый проход разбора параметра"
            ELSE
             //'got 5' log
             //"Текущая строка входного файла" WString:[] log
             "Один проход разбора остатка без учёта его результата"
             //"Текущая строка входного файла" WString:[] log
            ENDIF // "Надо ли разбирать условие"
           ) // "Строка начинается с" '='
          "Строка начинается с" '&'
           (
            "Надо ли разбирать условие" IF
             WString:++! "Текущая строка входного файла"
             "Сбросить накопленную строку без перевода"
             "Вывести отступ"
             "Закрыть операторную скобку"
             '%&& ' "Вывести строку" 
             "Открыть операторную скобку"
             true =: "Следующее значение переменной Первый проход разбора параметра"
             //"Перевести строку"
            ELSE
             "Один проход разбора остатка без учёта его результата"
            ENDIF // "Надо ли разбирать условие"
           ) // "Строка начинается с" '&'
          "Строка начинается с" '|'
           (
            "Надо ли разбирать условие" IF
             WString:++! "Текущая строка входного файла"
             "Сбросить накопленную строку без перевода"
             "Вывести отступ"
             "Закрыть операторную скобку"
             '%|| ' "Вывести строку" 
             "Открыть операторную скобку"
             true =: "Следующее значение переменной Первый проход разбора параметра"
             //"Перевести строку"
            ELSE
             "Один проход разбора остатка без учёта его результата"
            ENDIF // "Надо ли разбирать условие"
           ) // "Строка начинается с" '|'
          "Строка начинается с" '[' 
           (
//            "Накапливаемая строка пустая" ! ?
//             ( 0 =: "Число дополнительных открытых скобок" )
            "Один проход разбора остатка без учёта его результата"
           ) // "Строка начинается с" '['
          "Строка начинается с" '<' 
           (
//            "Накапливаемая строка пустая" ! ?
//             ( 0 =: "Число дополнительных открытых скобок" )
            "Один проход разбора остатка без учёта его результата"
           ) // "Строка начинается с" '['
          "Строка начинается с" ']' 
           ( 
            "Закрыть операторную скобку"
            "Обрабатываем END-IF" ! ?
             "Один проход разбора остатка без учёта его результата"
           ) // "Строка начинается с" ']'
          "Строка начинается с" '>' 
           ( 
            "Закрыть операторную скобку"
            "Обрабатываем конец цикла" ! ?
             "Один проход разбора остатка без учёта его результата"
           ) // "Строка начинается с" '>'
          ( 
           "Накапливаемая строка пустая" %&& 
           "Строка начинается с" '+1'
          ) 
           (
            2 WString:+! "Текущая строка входного файла"
            // - отрезаем +1
            "Вывести отступ"
            "Первый проход разбора параметра" IF
             '1 ' "Вывести строку"
            ELSE
             'integer:?++ ' "Вывести строку"
            ENDIF 
           ) // .. "Строка начинается с" '+1'
          ( 
           "Накапливаемая строка пустая" %&& 
           "Строка начинается с" '-1'
          ) 
           (
            2 WString:+! "Текущая строка входного файла"
            // - отрезаем -1
            "Вывести отступ"
            "Первый проход разбора параметра" IF
             '-1 ' "Вывести строку"
            ELSE
             'integer:?-- ' "Вывести строку"
            ENDIF 
           ) // .. "Строка начинается с" '+1'
          ( 
           "Накапливаемая строка пустая" %&& 
           "Строка начинается с" '1+'
          ) 
           (
            2 WString:+! "Текущая строка входного файла"
            // - отрезаем 1+
            "Вывести отступ"
            '1 %integer:?+ ' "Вывести строку"
           ) // .. "Строка начинается с" '1+'
          ( 
           "Надо ли разбирать цифры" %&&
           "Накапливаемая строка пустая" %&& 
           ( "Строка пустая" ! ) %&&
           ( "Цифры" "Текущая строка входного файла" WString:[] WString:HasAnyOf )
           //"Строка начинается с" '1'
          ) 
           (
            WString:[]++! "Текущая строка входного файла"
            // - отрезаем 1
            "Вывести отступ"
            "Выходной файл" file:WriteChar
            //'1 ' "Вывести строку"
            @ ( 
               ( "Строка пустая" ! ) %&&
               ( "Цифры" "Текущая строка входного файла" WString:[] WString:HasAnyOf )
              ) WHILE
             (
              WString:[]++! "Текущая строка входного файла"
              // - отрезаем 1
              "Выходной файл" file:WriteChar
             )
            "Вывести пробел"
           ) // .. "Строка начинается с" '1'
          DEFAULT
           "Один проход разбора остатка без учёта его результата"
         ; // RULES
         "Следующее значение переменной Первый проход разбора параметра" =: "Первый проход разбора параметра"
         ( "Встретилась закрывающаяся скобка" ! ) ? 
         (
          BOOLEAN VAR "Встретилась значащая строка"
          false =: "Встретилась значащая строка"
          @ ( %! ( "Входной файл" file:EOF ) %&&
            %! "Встретилась значащая строка" %&&
            ( "Строка пустая" )
            //( "Текущая строка входного файла" WString:Len =0 )
          ) WHILE ( 
           "Входной файл" file:ReadWStrLn =: "Текущая строка входного файла" 
           RULES
            "Обрабатываем незначащие строки с переводом строки перед ними"
             (
              "Текущая строка входного файла" WString:Len WString:+! "Текущая строка входного файла"
              // - сигнализируем остальным, что строка типа закончилась
              //false =: "Встретилась значащая строка"
             ) // "Обрабатываем незначащие строки с переводом строки перед ними"
            "Строка начинается с" "Табуляция"
             ( 
              "Вывести строку как комментарий. Чтобы в конечном файле было с чем сравнивать"
              WString:++! "Текущая строка входного файла" 
              true =: "Встретилась значащая строка"
             ) // "Строка начинается с" "Табуляция"
            DEFAULT
             (
              //EXIT
              // - это можно раскомментировать для целей отладки
              false 
               [[ 'Строка "' 
                  "Текущая строка входного файла" WString:ToString 
                  '" должна начинаться с табуляции' 
               ]] 
                strings:Cat 
                 ASSERTS 
             ) // DEFAULT   
           ; // RULES
          ) // ( "Строка пустая" ) ? ( 
         ) // ( "Встретилась закрывающаяся скобка" ! ) ? (
        END // "Текущая строка входного файла" WString:Len !=0
        // - типа копируем параметры, может быть понадобится и их синтаксический разбор
        
       FINALLY
        "Закрыть операторную скобку"
        ( "Количество открытых скобок параметров функции" %!= 
          "Сохранённое количество открытых скобок параметров функции" ) ?
         (
          EXIT
          false
          [[ 
           'Не дождались закрытия скобки: ' "Закрывающаяся скобка"
           ' Текущая строка: ' "Текущая строка входного файла" WString:ToString
          ]] strings:Cat 
           ASSERTS
         )  
       END // TRY..FINALLY 
      ; // "Разобрать фактические параметры"
      
      : "Разобрать фактические параметры функции" BOOLEAN IN "Надо ли считать скобки"
       //'Разобрать фактические параметры функции in' log
       "Закрывающаяся скобка" false false true true "Надо ли считать скобки" "Разобрать фактические параметры"
       //'Разобрать фактические параметры функции out' log
      ; // "Разобрать фактические параметры функции"
      
      : "Разобрать фактические параметры функции, без разбора цифр"  BOOLEAN IN "Надо ли считать скобки"
       //'Разобрать фактические параметры функции, без разбора цифр in' log
       "Закрывающаяся скобка" false false false true "Надо ли считать скобки" "Разобрать фактические параметры"
       //'Разобрать фактические параметры функции, без разбора цифр out' log
      ; // "Разобрать фактические параметры функции, без разбора цифр"
      
      : "Разобрать параметры 1-й части цикла"
       '}' false false false false false "Разобрать фактические параметры"
      ; // "Разобрать параметры 1-й части цикла"
      
      : "Разобрать параметры 3-й части цикла"
       '}' false false false false false "Разобрать фактические параметры"
      ; // "Разобрать параметры 3-й части цикла"
      
      : "Разобрать фактические параметры условия"
       //'Разобрать фактические параметры условия in' log
       '}' true true true false false "Разобрать фактические параметры"
       //'Разобрать фактические параметры условия out' log
      ; // "Разобрать фактические параметры условия"
      
      : "Разобрать имя переменной"
       //'Разобрать имя переменной in' log
       '}' false true false false false "Разобрать фактические параметры"
       //'Разобрать имя переменной out' log
      ; // "Разобрать имя переменной"
      
      : "Разобрать код ветки ELSE"
       '}' false true true false false "Разобрать фактические параметры"
      ; // "Разобрать код ветки ELSE"
      
      : "Разобрать параметры тела цикла"
       '>' false true true false false "Разобрать фактические параметры"
      ; // "Разобрать параметры тела цикла"
      
      : "Разобрать параметры тела IF"
       ']' false true true false false "Разобрать фактические параметры"
      ; // "Разобрать параметры тела IF"
      
      : "Разобрать сигнатуру функции"
        BOOLEAN VAR "Надо ли разбирать цифры"
        W-STRING VAR "Имя функции"
        "Открывающаяся скобка" WString:SplitTo! "Текущая строка входного файла"
         =: "Имя функции"
        "Имя функции" WString:IsNil ! 'Видимо не нашлась скобка, видимо она на другой строке' ASSERTS
        (
         ( "Имя функции" %!= 'find_element' ) %&&
         ( "Имя функции" %!= 'add_to_list' ) %&&
         ( "Имя функции" %!= 'exists_in_list' ) %&&
         ( "Имя функции" %!= 'consist_of' ) %&&
         ( "Имя функции" %!= 'clear_list' )
        ) 
         =: "Надо ли разбирать цифры"
         
        BOOLEAN VAR "Надо ли считать скобки" 
         (
          ( "Имя функции" %== 'add_operation' ) %||
          ( "Имя функции" %== 'set_uc_content' ) %||
          ( "Имя функции" %== 'set_documentation' ) %||
          ( "Имя функции" %== 'add_attribute' )
         ) 
           =: "Надо ли считать скобки" 
         
        "Имя функции" "Выходной файл" file:WriteWStr
        // - пишем имя функции
        "Вывести пробел"
        
        '%(' "Вывести строку"
        "Вывести пробел"
        
        "Надо ли разбирать цифры" IF
         "Надо ли считать скобки" "Разобрать фактические параметры функции"
        ELSE 
         "Надо ли считать скобки"  "Разобрать фактические параметры функции, без разбора цифр"
        ENDIF // "Надо ли разбирать цифры"
        
        //"Вывести пробел"
        ')%' "Вывести строку"
        // - выводим хитрые скобки, которые умею работать вместе с %,
      ; // "Разобрать сигнатуру функции"
      
      : "Разобрать вызов унаследованной функции по имени родительского стереотипа"
       ']' WString:SplitTo! "Текущая строка входного файла"
       DUP WString:IsNil ! 'Видимо не нашлась скобка, видимо она на другой строке' ASSERTS
       
       "Вывести кавычку"
       
       STRING W-STRING VAR "Имя родительского стереотипа"
        =: "Имя родительского стереотипа"
       
      "Имя родительского стереотипа" WString:IsNil ! 
       'Имя родительского стереотипа не может быть пустым' 
        ASSERTS
         
      "Разделитель частей стереотипа" WString:SplitTo! "Имя родительского стереотипа"
       STRING W-STRING VAR "Класс родительского стереотипа"
        "Имя родительского стереотипа" =: "Класс родительского стереотипа"
        =: "Имя родительского стереотипа"
        
      "Имя родительского стереотипа" WString:IsNil ! 
       'Имя родительского стереотипа не может быть пустым' 
        ASSERTS
       
       ( ':' "Класс родительского стереотипа" WString:HasAnyOf ) IF
        //( false 'С подстереотипами надо разбираться отдельно' ASSERTS )
        // - пока их обратно склеиваем
        "Имя родительского стереотипа" "Выходной файл" file:WriteWStr
        "Разделитель частей стереотипа" "Вывести строку"
        
        "Разделитель частей стереотипа" string:SplitTo! "Класс родительского стереотипа"
         DROP
         // =: "Класс родительского стереотипа"
        
        "Класс родительского стереотипа" "Выходной файл" file:WriteWStr
       ELSE 
        "Имя родительского стереотипа" "Выходной файл" file:WriteWStr
       ENDIF 
       // - пишем имя родительского стереотипа
       "Вывести кавычку"
       "Вывести пробел"
       
       "Строка начинается с" 'f_' ! IF
       
        : "Вывести спецзначение для одноимённой функции"
         'SAME_NAME %( )%' "Вывести строку"
        ; // "Вывести спецзначение для одноимённой функции"
        
        RULES
         "Строка равна" '\'
          (
           WString:++! "Текущая строка входного файла"
           // - отрезаем \
           "Вывести спецзначение для одноимённой функции"
          ) // "Строка равна" '\'
         "Строка пустая"
          "Вывести спецзначение для одноимённой функции"
         DEFAULT
          (
           false 
            [[ 'В строке ' "Текущая строка входного файла" WString:ToString ' ожидается f_' ]] 
             strings:Cat 
              ASSERTS 
          ) // DEFAULT
        ; // RULES  
       ELSE
        2 WString:+! "Текущая строка входного файла"
        // - отрезаем f_
        "Разобрать сигнатуру функции"
       ENDIF // "Строка начинается с" 'f_' ! IF
       "Перевести строку"
      ; // "Разобрать вызов унаследованной функции по имени родительского стереотипа"
      
      FORWARD "Обработать строку начинающуюся с % без отрезания %"
      
      BOOLEAN FUNCTION "Строка начинается с правильной буквы аргумента"
        "Строка начинается с" 'S' %||
        "Строка начинается с" 'D' %||
        "Строка начинается с" 'd' %||
        "Строка начинается с" 'C' %||
        "Строка начинается с" 'N' %||
        "Строка начинается с" 'U' %||
        "Строка начинается с" 'K' %||
        "Строка начинается с" 'I' %||
        "Строка начинается с" 'x' %||
        "Строка начинается с" 'n' %||
        "Строка начинается с" 'V' %||
        "Строка начинается с" 'F' %||
        "Строка начинается с" 'O' %||
        "Строка начинается с" 'A' %||
        "Строка начинается с" 'R' %||
        "Строка начинается с" 'G' %||
        "Строка начинается с" 'M' %||
        "Строка начинается с" 'o' %||
        "Строка начинается с" 'L' %||
        "Строка начинается с" 'Z' %||
        "Строка начинается с" 'a' %||
        "Строка начинается с" 'l' %||
        "Строка начинается с" 'f' %||
        "Строка начинается с" 'r' %||
        "Строка начинается с" 't' %||
        "Строка начинается с" 'e' %||
        "Строка начинается с" '+' %||
        "Строка начинается с" '?' %||
        "Строка начинается с" 'W' %||
        "Строка начинается с" 'b' %||
        "Строка начинается с" 'Y' %||
        "Строка начинается с" 's' %||
        "Строка начинается с" 'P' %||
        "Строка начинается с" 'p' %||
        "Строка начинается с" 'X' %||
        // - на самом деле это надо превратить во что-то вроде ==> execute_current_generator
        "Строка начинается с" 'T' IF
        true =: Result
       ELSE 
        false =: Result
       ENDIF 
      ; // "Строка начинается с правильной буквы аргумента"

      : "Разобрать UP"
        // - тут обрабатываем user property
        WString:++! "Текущая строка входного файла"
        // - отрезаем {
        
        '}' WString:SplitTo! "Текущая строка входного файла"
        W-STRING VAR "Имя UP"
        =: "Имя UP"
        "Имя UP" WString:IsNil ! 'Видимо не нашлась скобка, видимо она на другой строке' ASSERTS
        
        ( "Имя UP" "начинается с" '!' ) IF
         ' get_up_def ( ' "Вывести строку"
         WString:++! "Имя UP"
         // - отрезаем !
        ELSE
         ' get_up ( ' "Вывести строку"
        ENDIF 
        
        "Вывести кавычку"
        "Имя UP" "Выходной файл" file:WriteWStr
        // - пишем имя user property
        "Вывести кавычку"
        "Вывести пробел"
        ')' "Вывести строку"
      ; // "Разобрать UP"
        
      : "Разобрать переменную" BOOLEAN IN aGlobal
      
       aGlobal IF
        '( get_global_var ( ' "Вывести строку"
       ELSE
        '( get_object_var ( ' "Вывести строку"
       ENDIF
        
       "Разобрать имя переменной"
       
       //"Текущая строка входного файла" WString:[] log
       
       RULES
        "Строка начинается с" "Знак процента"
         (
          ') ' "Вывести строку"
          "Обработать строку начинающуюся с % как вызов метода объекта"
          ') ' "Вывести строку"
          EXIT
         ) // "Строка начинается с" "Знак процента"
        "Строка начинается с" ',' 
         NOP
        "Строка начинается с" '(' 
         NOP
        "Строка начинается с" ')'
         NOP
        "Строка начинается с" '<'
         NOP
         // - наверное это цикл с расшнирением для переменной
        "Строка начинается с" '=' 
         NOP
        "Строка начинается с" '"' 
         NOP
        "Строка начинается с" '{' 
         (
          ')' "Вывести строку"
          "Разобрать UP"
          ' ) ' "Вывести строку"
          EXIT
          //NOP
         ) // "Строка начинается с" '{'
        "Строка начинается с" '}' 
         NOP
        "Строка начинается с" '[' 
         NOP
         // - наверное это IF с расшнирением для переменной
        "Строка начинается с" ']' 
         NOP
//         ( 
//          "Обрабатываем END-IF" ! ?
//           "Один проход разбора остатка без учёта его результата"
//         ) // "Строка начинается с" ']'
        "Строка начинается с" '>'
         NOP
//         (
//          "Обрабатываем конец цикла" ! ?
//           "Один проход разбора остатка без учёта его результата"
//         ) //  "Строка начинается с" '>'
        "Строка начинается с правильной буквы аргумента"
         (
          // - тут пишем квалификатор того, чего хотят от переменной
          WString:[]++! "Текущая строка входного файла"
          ') ' "Вывести строку"
          '|' "Вывести строку"
          "Выходной файл" file:WriteChar
          "Вывести пробел"
          ') ' "Вывести строку"
          EXIT
         ) // DEFAULT
        DEFAULT
         (
//          // - тут пишем квалификатор того, чего хотят от переменной
//          WString:[]++! "Текущая строка входного файла"
//          "Вывести кавычку"
//          "Выходной файл" file:WriteChar
//          "Вывести кавычку"
//          "Вывести пробел"
         ) // DEFAULT
       ; // RULES
        
       ') ) ' "Вывести строку"
      ; //"Разобрать переменную"
      
      : "Разобрать глобальную переменную"
       true "Разобрать переменную"
      ; // "Разобрать глобальную переменную"
      
      : "Разобрать переменную объекта"
       false "Разобрать переменную"
      ; // "Разобрать переменную объекта"
      
      : "Обработать строку начинающуюся с % без отрезания %" BOOLEAN IN aGlobal
      
       "Сбросить накопленную строку и вывести отступ"
       
       RULES
        "Строка начинается с" 'S%[inherited]f_'
         (
          DROP
          // - убираем со стека %
          15 WString:+! "Текущая строка входного файла"
          // - отрезаем S%[inherited]f_
          'call-inherited ' "Вывести строку"
          
          "Разобрать сигнатуру функции"
          
          "Перевести строку"
          
         ) // "Строка начинается с" 'S%[inherited]'
        
        "Строка начинается с" 'S%[inherited]'
         (
          DROP
          // - убираем со стека %
          13 WString:+! "Текущая строка входного файла"
          // - отрезаем S%[inherited]
          'inherited' "Вывести строку"
          "Перевести строку"
         ) // "Строка начинается с" 'S%[inherited]'
       
        "Строка начинается с" 'S#[inherited]'
         (
          DROP
          // - убираем со стека %
          13 WString:+! "Текущая строка входного файла"
          // - отрезаем S#[inherited]
          '?inherited' "Вывести строку"
          "Перевести строку"
         ) // "Строка начинается с" 'S#[inherited]'
         
        "Строка начинается с" 'S%['
         (
          // - это вызов унаследованной функции по имени
          DROP
          // - убираем со стека %
          3 WString:+! "Текущая строка входного файла"
          // - отрезаем S%[
          'call-inherited::' "Вывести строку"
          "Вывести пробел"
          
          "Разобрать вызов унаследованной функции по имени родительского стереотипа"
         ) // "Строка начинается с" 'S%['
         
        "Строка начинается с" 'S#['
         (
          // - это вызов унаследованной функции по имени
          DROP
          // - убираем со стека %
          3 WString:+! "Текущая строка входного файла"
          // - отрезаем S#[
          '?call-inherited::' "Вывести строку"
          "Вывести пробел"
          
          "Разобрать вызов унаследованной функции по имени родительского стереотипа"
         ) // "Строка начинается с" 'S#['
         
        "Строка начинается с" 'f_'
         (
          // - это вызов глобальной функции
          DROP
          // - убираем со стека %
          2 WString:+! "Текущая строка входного файла"
          // - отрезаем 'f_'
          aGlobal IF
           '[%f] ' "Вывести строку"
          ELSE
           '%f ' "Вывести строку"
          ENDIF
          "Разобрать сигнатуру функции"
          "По любому пишем пробел, чтобы не слипалось с последующими строками"
         ) // "Строка начинается с" 'f_'
        "Строка начинается с" 't_'
         (
          // - это вызов глобального трансформатора
          DROP
          // - убираем со стека %
          2 WString:+! "Текущая строка входного файла"
          // - отрезаем 't_'
          aGlobal IF
           '[%t] ' "Вывести строку"
          ELSE
           '%t ' "Вывести строку"
          ENDIF
          "Разобрать сигнатуру функции"
          "По любому пишем пробел, чтобы не слипалось с последующими строками"
         ) // "Строка начинается с" 't_'
        "Строка начинается с" '{' 
         (
          // - это глобальная переменная
          DROP
          // - убираем со стека %
          WString:++! "Текущая строка входного файла"
          // - отрезаем {
          "Разобрать глобальную переменную"
         ) // "Строка начинается с" '{'
        DEFAULT
         (
          aGlobal IF
           "Выходной файл" file:WriteChar
           // - пишем собственно %
          ELSE
           DROP
           // - убираем со стека %
           ' ->' "Вывести строку"
           // - отделяем поля-подстановки, от реальных вызовов методов на стереотипах
           //   т.е. %S %P => %S %P, %S%P => %S ->P и т.п.
           //   т.к. для "моего мира" - они по сути - РАЗНЫЕ
          ENDIF 
          
          RULES
           ( 
            "Количество открытых скобок параметров функции" >0 %&&
            "Строка начинается с" "Закрывающаяся скобка"
           ) 
            (
             false 'После % закрывающаяся скобка недопустима' ASSERTS
             // "Ничего не делаем" // - чтобы отдать скобку тому, кто её ждёт
            ) // "Строка начинается с" "Закрывающаяся скобка" ..
           DEFAULT
            ( 
             WString:[]++! "Текущая строка входного файла"
             // - берём символ после %
             "Выходной файл" file:WriteChar 
             // - пишем символ после %
             
             RULES
              "Строка начинается с" "Знак процента"
               (
                WString:[]++! "Текущая строка входного файла"
                // - отрезаем %
                RULES
                 "Строка начинается с" 'f_'
                  (
                   // - это вызов функции объекта
                   DROP
                   2 WString:+! "Текущая строка входного файла"
                   // - отрезаем 'f_'
                   ' %f ' "Вывести строку"
                   "Разобрать сигнатуру функции"
                  ) // "Строка начинается с" 'f_'
                 "Строка начинается с" 't_'
                  (
                   // - это вызов функции объекта
                   DROP
                   2 WString:+! "Текущая строка входного файла"
                   // - отрезаем 'f_'
                   ' %t ' "Вывести строку"
                   "Разобрать сигнатуру функции"
                  ) // "Строка начинается с" 't_'
                 "Строка начинается с" '{' 
                  (
                   // - это переменная объекта
                   DROP
                   WString:++! "Текущая строка входного файла"
                   // - отрезаем {
                   "Вывести пробел"
                   "Разобрать переменную объекта"
                  ) // "Строка начинается с" '{'
                 DEFAULT 
                  (
                   //DROP
                   // - на самом деле нам этот символ там как раз нужен
                   false "Обработать строку начинающуюся с % без отрезания %"
                   //"Выходной файл" file:WriteChar
                   // - пишем собственно %
                  ) // 
                ; // RULES
               ) // "Строка начинается с" "Знак процента"
              "Строка начинается с" '#'
               (
                WString:[]++! "Текущая строка входного файла"
                // - отрезаем #
                RULES
                 "Строка начинается с" 'f_'
                  (
                   // - это вызов функции объекта, которой может не быть
                   DROP
                   2 WString:+! "Текущая строка входного файла"
                   // - отрезаем 'f_'
                   ' %?f ' "Вывести строку"
                   "Разобрать сигнатуру функции"
                  ) // "Строка начинается с" 'f_'
                 "Строка начинается с" 't_'
                  (
                   // - это вызов функции объекта, которой может не быть
                   DROP
                   2 WString:+! "Текущая строка входного файла"
                   // - отрезаем 't_'
                   ' %?t ' "Вывести строку"
                   "Разобрать сигнатуру функции"
                  ) // "Строка начинается с" 't_'
                 DEFAULT 
                  (
                   "Выходной файл" file:WriteChar
                   // - пишем собственно #
                  ) // 
                ; // RULES
               ) // "Строка начинается с" '#'
              "Строка начинается с" '['
              // - это IF с "расширением"
               "Обрабатываем IF"
              "Строка начинается с" '<'
              // - это цикл с "расширением"
               "Обрабатываем начало цикла"
              "Строка начинается с" '{'
               "Разобрать UP"
              "Строка начинается с правильной буквы аргумента" 
               (
                WString:[]++! "Текущая строка входного файла"
                // - отрезаем ВТОРУЮ БУКВУ после %БУКВА
                ' |' "Вывести строку"
                "Выходной файл" file:WriteChar
                // - пишем эту букву в файл
               ) // "Строка начинается с правильной буквы аргумента"
             ; // RULES
             // - тут разбираем строку после %БУКВА
             
            ) // DEFAULT
          ; // RULES  
          
          "По любому пишем пробел, чтобы не слипалось с последующими строками"
         ) // DEFAULT
       ; // RULES
       
      ; // "Обработать строку начинающуюся с % без отрезания %"
      
      : "Обработать строку начинающуюся с %" BOOLEAN IN aGlobal
      
       WString:[]++! "Текущая строка входного файла"
       // - отрезаем %
       aGlobal "Обработать строку начинающуюся с % без отрезания %"
       
      ; // "Обработать строку начинающуюся с %"
      
      : "Обработать строку начинающуюся с % как начало цепочки"
       true "Обработать строку начинающуюся с %"
      ; // "Обработать строку начинающуюся с % как начало цепочки"
      
      : "Обработать строку начинающуюся с % как вызов метода объекта"
       false "Обработать строку начинающуюся с %"
      ; // "Обработать строку начинающуюся с % как вызов метода объекта"
      
      : "Обрабатываем тело END-IF"
        "Сбросить накопленную строку"
        
        "Уменьшить отступ"
        
        "Был отступ" ? "Перевести строку"
        "Вывести отступ"
        
        '%END-IF' "Вывести строку"
        // - пишем "наш" END-IF
        //"По любому пишем пробел, чтобы не слипалось с последующими строками"
        "Перевести строку"
        
        "Уменьшить количество открытых IF"
      ; // "Обрабатываем тело END-IF"
      
      BOOLEAN FUNCTION "Обрабатываем END-IF"
       "Количество открытых IF" =0 IF
       // - видимо это какая-то другая скобка, например от inherited
        false =: Result
       ELSE
        true =: Result
        WString:++! "Текущая строка входного файла"
        // - отрезаем ]
        "Обрабатываем тело END-IF"
       ENDIF // "Количество открытых IF" =0
      ; // "Обрабатываем END-IF"
      
      BOOLEAN FUNCTION "Один проход разбора остатка"
      
       : "Вывести булевское значение без установки результата" IN aStr
        "Сбросить накопленную строку"
        "Вывести отступ" 
        aStr IsWString IF
         aStr "Выходной файл" file:WriteWStr
        ELSE
         aStr "Выходной файл" file:WriteStr
        ENDIF // aStr IsWString
       ; // "Вывести булевское значение без установки результата"
       
       : "Вывести булевское значение"
        "Текущая строка входного файла" "Вывести булевское значение без установки результата"
        "Перевести строку"
        true =: Result
       ; // "Вывести булевское значение"
       
       false =: Result
       
       RULES
        "Строка пустая"
         (
          "Сбросить накопленную строку"
          "Вывести строку как есть"
          true =: Result
         ) // "Строка пустая"
        ( "Строка равна" 'true'  %||
          "Строка равна" 'false' )
         ( 
          "Вывести булевское значение"
          "Текущая строка входного файла" WString:Len WString:+! "Текущая строка входного файла"
          // - сигнализируем остальным, что строка закончилась
         ) // "Строка равна" 'true'  %||..
         
        ( "Строка равна" 'true\'  %||
          "Строка равна" 'false\' )
         ( 
          WString:--Len! "Текущая строка входного файла"
          "Вывести булевское значение" 
          "Текущая строка входного файла" WString:Len WString:+! "Текущая строка входного файла"
          // - сигнализируем остальным, что строка закончилась
         ) // "Строка равна" 'true\'  %|| ..
         
        "Строка начинается с" 'true'
         (
          "Накапливаемая строка пустая" IF
           //"Сбросить накопленную строку без перевода"
           'true' "Вывести булевское значение без установки результата"
           "Вывести пробел"
           4 WString:+! "Текущая строка входного файла"
           //"Перевести строку"
          ELSE
           "Выводим следующий символ как есть"
          ENDIF // "Надо ли разбирать условие"
         ) // "Строка начинается с" 'true'
        "Строка начинается с" 'false'
         (
          "Накапливаемая строка пустая" IF
           //"Сбросить накопленную строку без перевода"
           'false' "Вывести булевское значение без установки результата"
           "Вывести пробел"
           5 WString:+! "Текущая строка входного файла"
           //"Перевести строку"
          ELSE
           "Выводим следующий символ как есть"
          ENDIF // "Надо ли разбирать условие"
         ) // "Строка начинается с" 'false'
         
        ( "Спецсимволы" "Текущая строка входного файла" WString:HasAnyOf ! )
         ( 
          //'got 100' log
          "Вывести отступ"
          "Открыть кавычку, если не было"
          "Вывести исходную строку" 
          "Закрыть кавычку, если была"
          "Перевести строку"
          true =: "Накапливаемая строка пустая"
          true =: Result
          "Текущая строка входного файла" WString:Len WString:+! "Текущая строка входного файла"
          // - сигнализируем остальным, что строка закончилась
         ) // ( "Спецсимволы" "Текущая строка входного файла" WString:HasAnyOf ! )
        "Строка начинается с" '\'
         "Выводим следующий символ после \"
        "Строка начинается с" "Знак процента" 
         "Обработать строку начинающуюся с % как начало цепочки"
        "Строка начинается с" '[' 
         "Обрабатываем IF"
        "Строка начинается с" '<' 
         "Обрабатываем начало цикла"
        "Строка начинается с" ']' 
         ( 
          "Обрабатываем END-IF" ! ?
           "Выводим следующий символ как есть"
         )
        "Строка начинается с" '>' 
         ( 
          "Обрабатываем конец цикла" ! ?
           "Выводим следующий символ как есть"
         )
        "Строка начинается с" '#'  
         (
          WString:++! "Текущая строка входного файла"
          // - отрезаем '#'
          "Сбросить накопленную строку"
          "Вывести отступ"
          'out_indent ' "Вывести строку"
         ) // "Строка начинается с" '#'
/*       "Строка начинается с" '='  
         (
          "Количество открытых скобок параметров функции" =0 IF
           "Выводим следующий символ как есть"
          ELSE 
           "Накапливаемая строка пустая" ! IF
            "Выводим следующий символ как есть"
           ELSE
            WString:++! "Текущая строка входного файла"
            '%== ' "Вывести строку"
           ENDIF 
          ENDIF 
         ) // "Строка начинается с" '=' */
        DEFAULT 
         (
          //"Текущая строка входного файла" WString:[] log
          "Выводим следующий символ как есть"
          //"Текущая строка входного файла" WString:[] log
         ) // DEFAULT
       ; // RULES
      ; // "Один проход разбора остатка"
      
      : "Разбираем остаток строки кода шаблона"
      
       BOOLEAN VAR l_Done
       false =: l_Done
       
       @ ( "Текущая строка входного файла" WString:Len !=0 %&& %! l_Done ) WHILE
       BEGIN
        "Один проход разбора остатка" =: l_Done
       END // @ ( "Текущая строка входного файла" WString:Len !=0 )
      ; // "Разбираем остаток строки кода шаблона"
      
      WString:++! "Текущая строка входного файла"
      // - отрезаем табуляцию
      
      "Увеличить отступ"
      TRY
       "Разбираем остаток строки кода шаблона"
       "Сбросить накопленную строку"
      FINALLY
       "Уменьшить отступ"
      END // TRY..FINALLY
      
     ; // "Разбираем код функции шаблона с начала строки"
     
     : "Обработать включение файла"
      STRING VAR "Новый файл"
      2 WString:+! "Текущая строка входного файла"
      // - отрезаем '# '
      "Текущая строка входного файла" WString:ToString =: "Новый файл"
      "Новый файл" log
      
      "Новый файл" '/' '\' string:Replace =: "Новый файл"
      "Новый файл" log
      
       WORDWORKER "Имя файла начинается с"
        WordToWork DO "Новый файл" StartsStr
       ; // "начинается с"
      
      : "Обработать новый файл"
      
       STRING VAR "Новый файл для включения"
       
       : "Обработать включение файла"
        "Новый файл" log
        
        "Закрыть все скобки"
        
        'USES' "Вывести строку с переводом строки"
         "Пробел" "Вывести строку"
         "Вывести кавычку"
         "Новый файл для включения" "Вывести строку"
         "Кавычка" "Вывести строку с переводом строки"
        ';' "Вывести строку с переводом строки"
        
        TRY
         "Новый файл" "Обработать файл"
        EXCEPT
         'Ошибка в ' "Новый файл" Cat log
         current:exception:ClassName log
         current:exception:Message log
         // - чтобы продолжить обработку файла
        END // TRY..EXCEPT 
       ; // "Обработать включение файла"
       
       : "Обрабатываем файл в той же директории"
        2 string:+! "Новый файл"
        // - отрезаем '.\'
        "Новый файл" log
        [[ "Путь к выходному файлу" "Новый файл" '.script' ]] strings:Cat =: "Новый файл для включения"
        [[ "Путь к входному файлу" "Новый файл" ]] strings:Cat =: "Новый файл"
        
        "Обработать включение файла"
       ; // "Обрабатываем файл в той же директории"
       
       : "Обработать файл в родительской директории"
       
        STRING VAR "Путь к выходному файлу на уровень выше"
         "Путь к выходному файлу" =: "Путь к выходному файлу на уровень выше"
        STRING VAR "Путь к входному файлу на уровень выше"
         "Путь к входному файлу" =: "Путь к входному файлу на уровень выше"
         
        '\' "Путь к выходному файлу на уровень выше" EndsStr ? (
         string:--Len! "Путь к выходному файлу на уровень выше"
        )
         
        '\' "Путь к входному файлу на уровень выше" EndsStr ? (
         string:--Len! "Путь к входному файлу на уровень выше"
        )
        
        "Новый файл" log
        '\' string:RSplitTo! "Путь к выходному файлу на уровень выше"
        DROP
        '\' string:RSplitTo! "Путь к входному файлу на уровень выше"
        DROP
        
        [[ "Путь к выходному файлу на уровень выше" "Новый файл" '.script' ]] strings:Cat =: "Новый файл для включения"
        [[ "Путь к входному файлу на уровень выше" "Новый файл" ]] strings:Cat =: "Новый файл"
        
        "Обработать включение файла"
       ; // "Обработать файл в родительской директории"
      
       RULES
        "Имя файла начинается с" '.\..\'
         (
          4 string:+! "Новый файл"
          // - отрезаем '.\..'
          "Обработать файл в родительской директории"
         ) 
        "Имя файла начинается с" '..\'
         (
          2 string:+! "Новый файл"
          // - отрезаем '..'
          "Обработать файл в родительской директории"
         ) 
        "Имя файла начинается с" '.\'
         "Обрабатываем файл в той же директории"
        //DEFAULT 
        // "Обработать включение файла"
       ; // RULES
      
      ; // "Обработать новый файл"
      
      "Обработать новый файл"
      
     ; // "Обработать включение файла"
     
     : "Обработать вызов другого генератора"
      2 WString:+! "Текущая строка входного файла"
      // - отрезаем '= '
      '%call-other-gen ( ' "Вывести строку"
      
      STRING W-STRING VAR "Имя стереотипа"
      "Текущая строка входного файла" =: "Имя стереотипа"
      
      "Разделитель частей стереотипа" WString:SplitTo! "Имя стереотипа"
      "Вывести кавычку"
      "Выходной файл" file:WriteWStr
      "Вывести кавычку"
      
      "Разделитель частей стереотипа" string:SplitTo! "Имя стереотипа"
      
      STRING VAR "Имя под-стереотипа"
      
      "Имя стереотипа" string:Len =0 IF
       =: "Имя стереотипа"
       
      ';' string:SplitTo! "Имя стереотипа"
       DROP
       "Пустая строка" =: "Имя под-стереотипа"
       
      ELSE 
       DROP
       
       ';' string:SplitTo! "Имя стереотипа"
        =: "Имя под-стереотипа"
       
      ENDIF 
      
      "Имя под-стереотипа" string:Len !=0 ? (
       "Вывести пробел"
       "Вывести кавычку"
       "Имя под-стереотипа" "Вывести строку"
       "Вывести кавычку"
      ) // "Имя под-стереотипа" string:Len !=0 ?
      
      "Имя стереотипа" string:Len !=0 ? (
       "Вывести пробел"
       "Вывести кавычку"
       "Имя стереотипа" "Вывести строку"
       "Вывести кавычку"
      ) // "Имя стереотипа" WString:IsNil ! ?
      
      ' )' "Вывести строку"
      "Перевести строку"
      
     ; // "Обработать вызов другого генератора"
     
     : "Обработать правило трансформатора"
      2 WString:+! "Текущая строка входного файла"
      // - отрезаем 'r '
     ; // "Обработать правило трансформатора"
     
     : "Тут разбираем синтаксис MDA"
     
       RULES
        "Строка начинается с" ': '
         "Разобрать заголовок стереотипа"
        "Строка начинается с" '%f '
         "Разобрать заголовок функции стереотипа"
        "Строка начинается с" '%t '
         "Разобрать заголовок трансформатора стереотипа"
        "Строка начинается с" '+ '
         "Разобрать заголовок генератора" 
        "Строка начинается с" 'f ' 
         "Разобрать заголовок глобальной функции"
        "Строка начинается с" 't '
         "Разобрать заголовок глобального трансформатора"
        "Строка начинается с" '# ' 
         "Обработать включение файла"
        (
         "Строка начинается с" ' ' %&&
         "Был открыт трансформатор"
        ) 
         "Обработать правило трансформатора"
        (
         "Строка начинается с" "Табуляция" %&&
         (
          "Была открыта функция" %||
          "Был открыт генератор"
         )
        ) 
         "Разбираем код функции шаблона с начала строки"
        (
         "Был открыт генератор" %&&
         "Строка начинается с" '= '
        ) 
         "Обработать вызов другого генератора"
       ; // RULES
     
     ; // "Тут разбираем синтаксис MDA"
     
    : "Обработать строку входного файла" W-STRING IN "Строка считанная из входного файла"
    
     "Строка считанная из входного файла" =: "Текущая строка входного файла"
     
     : "Обрабатываем значащие строки"
      "Вывести строку как комментарий. Чтобы в конечном файле было с чем сравнивать"
      "Тут разбираем синтаксис MDA"
     ; // "Обрабатываем значащие строки" 
     
     RULES
      "Обрабатываем незначащие строки без перевода строки перед ними"
       "Ничего не делаем"
      DEFAULT
       "Обрабатываем значащие строки"
     ; // RULES
     
    ; // "Обработать строку входного файла"
    
    : "Обработать все строки входного файла"
     "Входной файл" file:ReadLines "Обработать строку входного файла"
    ; // "Обработать все строки входного файла"

    false =: "Был открыт стереотип"
    false =: "Был открыт генератор"
    false =: "Была открыта функция"
    false =: "Был открыт трансформатор"
    0 =: "Отступ"
    0 =: "Количество открытых IF"
    0 =: "Количество открытых циклов"
    0 =: "Количество открытых скобок параметров функции"
    false =: "Был отступ"
    true =: "Накапливаемая строка пустая"
    false =: "Была кавычка"
    
    TRY
     "Обработать все строки входного файла"
    FINALLY
     "Закрыть все скобки"
    END // TRY..FINALLY 
   
   FINALLY
    nil =: "Выходной файл"
   END // TRY..FINALLY
  FINALLY 
   nil =: "Входной файл"
  END // TRY..FINALLY
  
  VAR "Имя эталона"
  "Имя выходного файла" '.etalon.script' Cat =: "Имя эталона"
  
  "Имя эталона" "Имя выходного файла" "Пустая строка" tests:CheckOutputWithInput 
  //"Имя выходного файла" "Пустая строка" tests:CheckEtalon
 ; // "Обработать файл"
 
 "Обработанные файлы" array:Clear
 
// 'G:\NewGenTest\TestSet\Auto\fuck.tpi' "Обработать файл"
// 'G:\MetaTemplate\Meta\Elements\MDAGenerator.tpi' "Обработать файл"
 'G:\F1Specific\F1Specific.tpl' "Обработать файл"

/* 'G:\VCMTemplates\VCMTemplates.tpl' "Обработать файл"
 'G:\CommonTemplates\CommonTemplates.tpl' "Обработать файл"
 
 'G:\CoreTemplates\Integrated\Root\Project.tpi' "Обработать файл"
 'G:\CommonTemplates\Integrated\Root\Project.tpi' "Обработать файл"
 'G:\CommonTemplates\AllGenerators\DelphiGens\Delphi интерфейсы и реализация.tpi' "Обработать файл"
 'G:\CommonTemplates\CommonLang\BaseTypes\PasUtils.tpi' "Обработать файл"
 'G:\CommonTemplates\CommonLang\InterfacesMetamodel\AbstractFacet.tpi' "Обработать файл"
 'G:\CommonTemplates\CommonLang\InterfacesMetamodel\Facet.tpi' "Обработать файл"
 'G:\CommonTemplates\CommonLang\InterfacesMetamodel\PureMixIn.tpi' "Обработать файл"
 'G:\VCMTemplates\VCMViewInterfacesLayer\FormOperations\VCMFacet.tpi' "Обработать файл"
 'G:\CommonTemplates\CommonLang\BaseTypes\ClassBase.tpi' "Обработать файл"
 'G:\CommonTemplates\CommonLang\ImplementationTypes\SimpleClass.tpi' "Обработать файл"
 //'G:\VCMTemplates\VCMTemplates.tpl' "Обработать файл"
 
 'G:\CommonTemplates\CommonLang\Library\Library.tpi' "Обработать файл"
 'G:\MetaTemplate\Meta\Elements\MDAGenerator.tpi' "Обработать файл"
 'G:\MetaTemplate\Meta\HighLayers\MDALibrary.tpi' "Обработать файл"
 'G:\MetaTemplate\Meta\HighLayers\MDATemplates.tpi' "Обработать файл"
// 'G:\CommonTemplates\Integrated\Root\Project.tpi' "Обработать файл"
 'G:\CoreTemplates\RequirementsLib\Requirements\Requirements.tpi' "Обработать файл"
 'G:\VCMTemplates\VCMSubsystemLayer\SubsystemLevel\VCMSubsystem.tpi' "Обработать файл" */
; // "Обработать шаблоны MDA"

"Обработать шаблоны MDA"