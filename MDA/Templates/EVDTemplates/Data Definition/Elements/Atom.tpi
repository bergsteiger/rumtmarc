////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/EVDTemplates/Data Definition/Elements/Atom.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAClass::Class>> MDProcess$ForDelphi::EVDTemplates::Data Definition::Elements::Atom
//
// Атом
// ---
// Атомарный элемент. Не может содержать атрибутов или дочерних элементов.
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

: Atom::Class
? Атом
? Атомарный элемент. Не может содержать атрибутов или дочерних элементов.
< *::Class,*::Category

= WikiImplClass::Class
= AttrValueSpeller::Class
= Delphi интерфейсы и реализация::MDAGenerator

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Параметры стереотипа
a ra
/ - тип абстракции
Y code_evd_atom.gif
L code_evd_atom
// Параметры визуализации
$ C 192,255,255
$ L 0,0,0
$ l 128,128,255
$ F 0,0,0
$ f 128,128,255

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Пользовательские свойства

p ID:s ? Идентификатор типа. Используется для записи EVD в бинарный поток
p Implementation=undef|list|leaf|none ? Тип класса реализации --- Определяет генерацию класса реализации: - undef - наследуется от родителя - list - список тегов - leaf - листьевой тег - none - никакого класса реализации не генерируется
p Parented:tribool=undefined ? Нужно ли хранить ссылку на родительский тег
p SmallTag:tribool=undefined ? Определяет, что элемент может иметь НЕ более 32 (включительно) атрибутов

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функции стереотипа

%f _st_space_key
	SHD

%f _wiki_up_print
	%S#[inherited][{"%S{ID}"!="%S{!ID}"}%f_up_prefix(%S) *ID* = *%S{ID}* - Идентификатор типа. Используется для записи EVD в бинарный поток
	][{"%S{Implementation}"!="%S{!Implementation}"}%f_up_prefix(%S) *Implementation* = *%S{Implementation}* - Тип класса реализации --- Определяет генерацию класса реализации: - undef - наследуется от родителя - list - список тегов - leaf - листьевой тег - none - никакого класса реализации не генерируется
	][{"%S{Parented}"!="%S{!Parented}"}%f_up_prefix(%S) *Parented* = *%S{Parented}* - Нужно ли хранить ссылку на родительский тег
	][{"%S{SmallTag}"!="%S{!SmallTag}"}%f_up_prefix(%S) *SmallTag* = *%S{SmallTag}* - Определяет, что элемент может иметь НЕ более 32 (включительно) атрибутов
	]

// Определяет, что объект является элементом схемы EVD.
%f _evd_IsSchemaElement
//#UC START# *484EAD6D02ECfor48492CB900AB*
	true
//#UC END# *484EAD6D02ECfor48492CB900AB*

// Количество элементов схемы, от которых наследуется тег.
%f _evd_SchemaElementAncestorCount
//#UC START# *484F892902D9for48492CB900AB*
@ %SU
	%f_evaluate(<{}{%G#f_evd_IsSchemaElement()=true}{C}>\
	+\
	<{}{%R#f_evd_IsSchemaElement()=true}{C}>)
//#UC END# *484F892902D9for48492CB900AB*

// нет документации
%f _evd_DefineType
//#UC START# *4860FEC5003Efor48492CB900AB*
	#t_%SN := DefineType([{"%S{ID}"!=""}{g_InnerTypeID}%S{ID} \{%SN\}], \[<{, }{%G#f_evd_IsSchemaElement()=true}t_%GN>[, <{, }{%R#f_evd_IsSchemaElement()=true}t_%RN>]\], '%SD', %f_pas_TypeName(%S)) As %f_pas_TypeName(%S);\
	[{"%S{ID}"=""} Inc(g_InnerTypeID);]\n
//#UC END# *4860FEC5003Efor48492CB900AB*

// Возвращает тип класса реализации с учётом наследования
%f _evd_Implementation
// возвращаемый результат: a-string
//#UC START# *4A64A41E0269for48492CB900AB*
@ %SU
	[{%S{Implementation}=undef}{%S{Implementation}}[{%Gx=true}{none}[{}{none}%G#f_evd_Implementation()]]]
//#UC END# *4A64A41E0269for48492CB900AB*

// Нужно ли хранить ссылку на родительский тег
%f _evd_Parented
// возвращаемый результат: boolean
//#UC START# *4A64A48B02F1for48492CB900AB*
@ %SU
	[{%S{Parented}=undefined}{%S{Parented}}[{%Gx=true}{false}[{}{false}%G#f_evd_Parented()]]]
//#UC END# *4A64A48B02F1for48492CB900AB*

// Предок класса реализации
%f _evd_ImplementationClassAncestor
// возвращаемый результат: a-string
//#UC START# *4A64ADC30232for48492CB900AB*
@ %SU
	Tk2[{%S%f_evd_Parented()=true}Parented]Typed\
	[{%S#f_evd_SmallTag()=false}{\
	Small\
	}\
	Huge\
	]\
	[{%S%f_evd_Implementation()=leaf}{List}Leaf]Tag
//#UC END# *4A64ADC30232for48492CB900AB*

// Выводит реализацию элемента
%f _evd_OutElementImplementation
//#UC START# *4BC4367C02DBfor48492CB900AB*
	[<%C#f_evd_OutElementImplementation()>]\
	[{%S%f_evd_Implementation()!=none}\
	%f_pas_OpenMethodImplementation("TagType",%S)\
	function %f_pas_TypeName(%S)Class.TagType: Tk2Type;
	begin
	 Result := k2_typ%SN;
	end;//%f_pas_TypeName(%S)Class.TagType]\
	%f_pas_OpenMethodImplementation("GetAsPCharLen",%S)\
	function %f_pas_TypeName(%S).GetAsPCharLen: Tl3PCharLenPrim;
	begin
	 Result := l3PCharLen(AnsiString('%SN'));
	end;\
	[{%S%f_evd_SchemaElementAncestorCount()!=0}%f_pas_OpenMethodImplementation("InheritsFrom",%S)\
	function %f_pas_TypeName(%S).InheritsFrom(anAtomType: Tk2TypePrim): Boolean;
	begin
	 Result := (Self = anAtomType) OR 
	           <{ OR \n           }{%G#f_evd_IsSchemaElement()=true}%f_pas_TypeName(%P)(TypeTable).t_%GN.InheritsFrom(anAtomType)>\
	[\n           OR
	           <{ OR \n           }{%R#f_evd_IsSchemaElement()=true}%f_pas_TypeName(%P)(TypeTable).t_%RN.InheritsFrom(anAtomType)>]\
	;
	end;]\
	%f_pas_OpenMethodImplementation("DoMakeTag",%S)\
	function %f_pas_TypeName(%S).DoMakeTag(aType: Tk2Type): Ik2Tag;
	[{%Sa!=abstract}{\
	begin
	 Result := nil;
	 Assert(false,'Невозможно создать абстрактный тег %SN');
	}\
	[{%S%f_evd_Implementation()=none}{\
	begin
	 Result := nil;
	 Pointer(Result) := Pointer(Ik2Tag(%f_pas_TypeName(%S)Class.Create(aType)));
	}\
	%f_set_var(ATOM_CLASS,"")\
	%f_set_var(TAG_CLASS,"")\
	%f_set_var(WRAPPER_CLASS,"")\
	<{}{%LS=Wrapper}%L<{}{%ON=New}%f_set_var(WRAPPER_CLASS,S)>>\
	[{"%{WRAPPER_CLASS}N"=""}{\
	begin
	 Result := Wrapper.New(aType);
	}\
	<{}{%LS=TagImplementator}\
	%f_set_var(ATOM_CLASS,"%f_pas_TypeName(%L%G)")\
	%L<{}{}{%g}%g<{}{%f_pas_TypeName(%R)=Ik2Tag}%f_set_var(TAG_CLASS,"%{ATOM_CLASS}N")>>\
	[{"%{TAG_CLASS}N"=""}\
	%L<{}{}{%r}%r<{}{%f_pas_TypeName(%R)=Ik2Tag}%f_set_var(TAG_CLASS,"%{ATOM_CLASS}N")>>\
	]\
	>\
	[{"%{TAG_CLASS}N"=""}{\
	begin
	 Result := nil;
	 Pointer(Result) := Pointer(Ik2Tag(%{TAG_CLASS}N.Create(aType)));
	}\
	[{"%{ATOM_CLASS}N"=""}{\
	var
	 l_Inst : %{ATOM_CLASS}N;
	begin
	 l_Inst := %{ATOM_CLASS}N.Create;
	 try
	  Result := TagFromIntRef(Integer(l_Inst));
	 finally
	  FreeAndNil(l_Inst);
	 end;//try..finally
	}\
	[{<{}{%G#f_evd_IsSchemaElement()=true}{C}>!=1}{\
	begin
	[{%Ga!=abstract}{\
// нельзя вызывать конструктор абстрактного родителя, поэтому выясняем его тип реализации
	%f_set_var(ATOM_CLASS,"")\
	%f_set_var(TAG_CLASS,"")\
	%f_set_var(WRAPPER_CLASS,"")\
	<{}{}{r}%g<{}{%LS=TagImplementator&"%{TAG_CLASS}N"=""}\
	%f_set_var(ATOM_CLASS,"%f_pas_TypeName(%L%G)")\
	%L<{}{}{%g}%g<{}{%f_pas_TypeName(%R)=Ik2Tag}%f_set_var(TAG_CLASS,"%{ATOM_CLASS}N")>>\
	[{"%{TAG_CLASS}N"=""}\
	%L<{}{}{%r}%r<{}{%f_pas_TypeName(%R)=Ik2Tag}%f_set_var(TAG_CLASS,"%{ATOM_CLASS}N")>>\
	]\
	>>\
	 Result := nil;
	 Pointer(Result) := Pointer(Ik2Tag(%{TAG_CLASS}N.Create(aType)))\
	}\
	 Result := %f_pas_TypeName(%P)(TypeTable).t_<{}{%G#f_evd_IsSchemaElement()=true}%GN>.DoMakeTag(aType)];
	}\
	begin
	 Result := inherited DoMakeTag(aType);
	]]]]]]\
	end;\

	[{%S{Defines CompareTags}=true|<{}{%g{Defines CompareTags}=true}{C}>!=0}\
	%f_pas_OpenMethodImplementation("CompareTags",%S)\
	function %f_pas_TypeName(%S).CompareTags(const A: Ik2Tag;
	    const B: Ik2Tag;
	    aSortIndex: Tl3SortIndex): Integer;
	    \{* Сравнивает теги \}
	[{%S{Defines CompareTags}=true}\
	%f_with_gen_id(intf.pas,%U[{CompareTags_var}\n])\
	\n]\
	begin
	[{%S{Defines CompareTags}=true}{\
	 Result := <{}{%G#f_evd_IsSchemaElement()=true}%f_pas_TypeName(%P)(TypeTable).t_%GN.CompareTags(A, B, aSortIndex)>;\
	}\
	%f_with_gen_id(intf.pas,%U[{CompareTags}\n !!!\n])\
	]
	end;\
	]\

	[{%S{Defines CompareTagWithInt}=true|<{}{%g{Defines CompareTagWithInt}=true}{C}>!=0}\
	%f_pas_OpenMethodImplementation("CompareTagWithInt",%S)\
	function %f_pas_TypeName(%S).CompareTagWithInt(const aTag: Ik2Tag;
	    aValue: Integer;
	    anIndex: Integer): Integer;
	    \{* Сравнивает тег с целым \}
	[{%S{Defines CompareTagWithInt}=true}\
	%f_with_gen_id(intf.pas,%U[{CompareTagWithInt_var}\n])\
	\n]\
	begin
	[{%S{Defines CompareTagWithInt}=true}{\
	 Result := <{}{%G#f_evd_IsSchemaElement()=true}%f_pas_TypeName(%P)(TypeTable).t_%GN.CompareTagWithInt(aTag, aValue, anIndex)>;\
	}\
	%f_with_gen_id(intf.pas,%U[{CompareTagWithInt}\n !!!\n])\
	]
	end;\
	]
//#UC END# *4BC4367C02DBfor48492CB900AB*

// Кладёт класс реализации в переменную PARENT
%f _ImplementationClassToVar
//#UC START# *4BCC78C10007for48492CB900AB*
	%f_set_var(PARENT,"")\

	<\
	%G<{}{%LS=TagImplementator}\
	%L<{}{%G#f_IsSimpleClass()=true}\
	[{"%{PARENT}N"=""}\
	%f_set_var(PARENT,G)\
	]\
	>\
	>\
	>\

	[{"%{PARENT}N"=""}\
	<%G#f_ImplementationClassToVar()>\
	]\

	[{"%{PARENT}N"=""}\
	[{%S#f_evd_SmallTag()=false}{\
	[{"%{Tk2SmallTagObject}N"=""}%f_find_element(Tk2SmallTagObject,Tk2SmallTagObject)]\
	}\
	[{"%{Tk2HugeTagObject}N"=""}%f_find_element(Tk2HugeTagObject,Tk2HugeTagObject)]\
	]\
	]
//#UC END# *4BCC78C10007for48492CB900AB*

%f _evd_SmallTag
// возвращаемый результат: boolean
//#UC START# *4E8342460069for48492CB900AB*
@ %SU
	[{%S{SmallTag}=undefined}{%S{SmallTag}}[{%Gx=true}{true}[{}{true}%G#f_evd_SmallTag()]]]
//#UC END# *4E8342460069for48492CB900AB*

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
%t _constraint
//#UC START# *4704C0E30186for48492CB900AB*
c	{}
r {""=""}: {}
//#UC END# *4704C0E30186for48492CB900AB*

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Определяет, что элемент может реализовываться классом
%f _ClassImplementable
//#UC START# *49551CA202CFfor48492CB900AB*
	false
//#UC END# *49551CA202CFfor48492CB900AB*

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Добавляет файлы необходимые элементу с точки зрения метамодели
%f _pas_ImplUses
//#UC START# *4948EB2601FAfor48492CB900AB*
	%S%[inherited]\
	[{<{}{%G#f_evd_IsSchemaElement()=true}{C}>=1}\
	[{%Ga=abstract}\
	<%g<{}{%LS=TagImplementator}%f_pas_PutToUses(%L%G)>>\
	]\
	]
//#UC END# *4948EB2601FAfor48492CB900AB*

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Выводит дополнительные модули необходимые элементу в интерфейсной секции
%f _pas_IntfUses
//#UC START# *4948F2EE0334for48492CB900AB*
	%S%[inherited]\
	[{%S%f_evd_Implementation()!=none}\
	%f_pas_PutToUses(%f_cut_prefix(%S%f_evd_ImplementationClassAncestor(),T))]
//#UC END# *4948F2EE0334for48492CB900AB*

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Имя типа
%f _pas_TypeName
//#UC START# *4947F8AD02A1for48492CB900AB*
	%f_N(%S)Atom
//#UC END# *4947F8AD02A1for48492CB900AB*

// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Генератор файлов форм (.dfm)
+ dfm
R  
//#UC START# *49F5795900ECfor48492CB900AB*
//#UC END# *49F5795900ECfor48492CB900AB*

// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Реализация на Delphi(.pas)
+ impl.pas
R  
//#UC START# *470F15B800CBfor48492CB900AB*
R  
F !!%SN\n\n
	<%FF>\
	#// %SN
	%S%f_evd_DefineType()\
	#with t_%SN do
	#begin\
	[{%S%f_evd_Implementation()=none}{\
	\n# AtomClass := %f_pas_TypeName(%S)Class;}\
	[\n# AtomType := TypeInfo(<{}{%GS=UMLPrimitive&%GN!=pointer}%f_pas_TypeName(%G)>);]\
	[\n# AtomType := TypeInfo(<{}{%GS=Typedef|%GS=Enum|%GS=Range}%f_pas_TypeName(%G)>);]\
	<{}{%LS=TagImplementator}\n# AtomClass := [{}{nil}%f_pas_TypeName(%L%G)];>]\
	<{}{%LS=Wrapper}\n# WrapperType := %f_pas_TypeName(%L);>\
	<{}{%LS=InterfaceFactory}\n# InterfaceFactoryType := %f_pas_TypeName(%L);>\
	<{}{%GN=pointer}\n# IsRawData := true;>\
	[\n# IDIndex := k2_ti%S{IDIndex};]\
	[{%S{need UC}=true}\n%f_with_gen_id(intf.pas,%U[{atom1}\n])]
	[<{\n}{%CC!=Class}%CX\
	>\n]\
	[# SetNeedMarkModifiedAllExcept(k2_ti%S{SetNeedMarkModifiedAllExcept});\n]\
	[{%S{need UC}=true}%f_with_gen_id(intf.pas,%U[{atom}\n])\n]\
	[  Recalc;
	<{\n}{%CC=Class}%CX\
	>\n]\
	#end;//%SN
//#UC END# *470F15B800CBfor48492CB900AB*

// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Родные Delphi интерфейсы (.pas)
+ intf.pas
R  
//#UC START# *470F1571031Cfor48492CB900AB*
R  
O [{%SS=TagOverride}{[{"%f_pas_UnitFileName(%S)"!=""}[{%S{finished}!=true}NOT_FINISHED_]%f_pas_UnitFileName(%S)]}[{%S{need UC}=true|<{}{%CS=TagValue}{C}>!=0}[{"%f_pas_UnitFileName(%S)"!=""}[{%S{finished}!=true}NOT_FINISHED_]%f_pas_UnitFileName(%S)]]]
	[{"%SO"!=""}\
	%f_pas_OpenUnitInterface(%S)\
//	%f_pas_Uses(%S)\
	%f_pas_PutToUses("k2Base")\
//	<%f_warning(%SN - %C%V%TN : %C%V%TS)>\

	<{}{%CS=TagValue}\
//	%f_warning(%CN : %CS)\
//	%C<%f_warning(%C%V%TN : %C%V%TS)>\
	%C<{}{%C%V%TS=Constants}\
//	%f_warning(%C%V%TN : %C%V%TS - %C%V%T%PN : %C%V%T%PS - %f_pas_UnitName(%C%V%T))\
	%f_pas_PutToUses(%C%V%T)\
	>\
	>\

	%f_pas_CloseUses(%S)\
	\

	[{%SS!=TagOverride}\
	[{"%S{ID}"!=""}%f_pas_OpenConst(%S)\
	 k2_id%SN = %S{ID};\n\
	]\

	<{}{%C#f_NeedsOwnType()=true}\
	[%C%f_open_ifdef()\n]\
	var k2_id%C%f_NewTypeName() : Integer = -1;\
	[\n%C%f_close_ifdef()]
	>\

	%f_pas_OpenMethodInterface("k2_typ%SN",%S)\
	function k2_typ%SN: Tk2Type;\
	]

	[<{\n}%CX>\n]\
	[{%S{need UC}=true}\n%U[{const_intf}\n]\n]\
	%f_pas_OpenUnitImplementation(%S)\
	[{%SS!=TagOverride}%f_pas_PutToUses(%P)]\
	%f_pas_PutToUses("k2Facade")\
	%f_pas_CloseUses(%S)\
	[{%SS!=TagOverride}\
	var
	 g_%SN : Tk2Type = nil;
	
	%f_pas_OpenMethodImplementation("k2_typ%SN",%S)\
	function k2_typ%SN: Tk2Type;
	begin
	 if (g_%SN = nil) then
	 begin
	  Assert(Tk2TypeTable.GetInstance Is %f_pas_TypeName(%P));
	  g_%SN := %f_pas_TypeName(%P)(Tk2TypeTable.GetInstance).t_%SN;
	 end;//g_%SN = nil
	 Result := g_%SN;
	end;]\
	\
	%f_pas_CloseUnit(%S)]
//#UC END# *470F1571031Cfor48492CB900AB*

// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
+ intf2.pas
R  
//#UC START# *477398E501C0for48492CB900AB*
R  
	%f_pas_OpenType(%S)\
	[{%S%f_evd_Implementation()!=none}\
	#%f_pas_TypeName(%S)Class = class(%S%f_evd_ImplementationClassAncestor())
	# \{* Класс реализации тега "%SN" \}
	#protected
	#// realized methods
	#  function TagType: Tk2Type; override;
	#    {* Тип параграфа }
	#end;//%f_pas_TypeName(%S)Class
	\n]\
	#%f_pas_TypeName(%S) = class\

	(Tk2Type)
//	[#private
//	<{\n}%CX>
//	]\
	#protected
	#  function GetAsPCharLen: Tl3PCharLenPrim; override;\
	[{%S%f_evd_SchemaElementAncestorCount()!=0}\n#  function InheritsFrom(anAtomType: Tk2TypePrim): Boolean; override;]
	#public
	#  function DoMakeTag(aType: Tk2Type): Ik2Tag; override;\

	[{%S{Defines CompareTags}=true|<{}{%g{Defines CompareTags}=true}{C}>!=0}\
	\n#  function CompareTags(const A: Ik2Tag;
	#    const B: Ik2Tag;
	#    aSortIndex: Tl3SortIndex): Integer; override;
	#    \{* Сравнивает теги \}\
	]\

	[{%S{Defines CompareTagWithInt}=true|<{}{%g{Defines CompareTagWithInt}=true}{C}>!=0}\
	\n#  function CompareTagWithInt(const aTag: Ik2Tag;
	#    aValue: Integer;
	#    anIndex: Integer): Integer; override;
	#    \{* Сравнивает тег с целым \}\
	]\

	\n\
	#end;//%f_pas_TypeName(%S)\
	<%CX>
//#UC END# *477398E501C0for48492CB900AB*

// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// 3-я секция интерфейса. Например поле для свойства.
+ intf3.pas
R  
//#UC START# *4774D2A20372for48492CB900AB*
R  
	# t_%SN : %f_pas_TypeName(%S);\
	[\n# <{\n# }%CX>]
//#UC END# *4774D2A20372for48492CB900AB*

// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Скрипты TC (.sd)
+ sd
R  
//#UC START# *4DE79AFC0030for48492CB900AB*
//#UC END# *4DE79AFC0030for48492CB900AB*

// реализация абстрактного стереотипа Документация::MDAGenerator
// Хак для [$281531116]
+ link_to_requests_hack
//#UC START# *4E65F581015Afor48492CB900AB*
//#UC END# *4E65F581015Afor48492CB900AB*

// перекрытие базового стереотипа ModelBuilding::MDAGenerator
// генератор построения виртуальных элементов модели - запускается до генерации конкретных
// артефактов
+ spell
//#UC START# *4A41A13D03D5for48492CB900AB*
	%S%f_DoSpell()\
	<%CX>
//#UC END# *4A41A13D03D5for48492CB900AB*

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Вложенные стереотипы

: Atom::Class::uses::ClassDependency
? Зависимость структурного элемента от элементов реализации
= ClassBaseGenerator::MDAGenerator

// Параметры стереотипа
Y code_dep_uses.gif
L code_dep_uses

// Генераторы
// Родные Delphi интерфейсы (.pas)
+ intf.pas
R  
//#UC START# *470F1571031Cfor48564FC60216*
//#UC END# *470F1571031Cfor48564FC60216*

// Реализация на Delphi(.pas)
+ impl.pas
R  
//#UC START# *470F15B800CBfor48564FC60216*
//#UC END# *470F15B800CBfor48564FC60216*

// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
+ intf2.pas
R  
//#UC START# *477398E501C0for48564FC60216*
//#UC END# *477398E501C0for48564FC60216*

// 3-я секция интерфейса. Например поле для свойства.
+ intf3.pas
R  
//#UC START# *4774D2A20372for48564FC60216*
//#UC END# *4774D2A20372for48564FC60216*

// Генератор файлов форм (.dfm)
+ dfm
R  
//#UC START# *49F5795900ECfor48564FC60216*
//#UC END# *49F5795900ECfor48564FC60216*

// Скрипты TC (.sd)
+ sd
R  
//#UC START# *4DE79AFC0030for48564FC60216*
//#UC END# *4DE79AFC0030for48564FC60216*

// Хак для [$281531116]
+ link_to_requests_hack
//#UC START# *4E65F581015Afor48564FC60216*
//#UC END# *4E65F581015Afor48564FC60216*

// Генерация модели в MDKnow
+ wiki
//#UC START# *46E6D4BB0339for48564FC60216*
//#UC END# *46E6D4BB0339for48564FC60216*

// генератор заголовочных файлов C++ (.h)
+ h
//#UC START# *47022C88029Ffor48564FC60216*
//#UC END# *47022C88029Ffor48564FC60216*

// генератор файлов реализации C++ (.cpp)
+ cpp
//#UC START# *47022CB8034Bfor48564FC60216*
//#UC END# *47022CB8034Bfor48564FC60216*

// генератор inline файлов реализации C++ (.i.h)
+ i.h
//#UC START# *47022CCF00EAfor48564FC60216*
//#UC END# *47022CCF00EAfor48564FC60216*

// генератор классов, интерфейсов на java (.java)
+ java
//#UC START# *470321950119for48564FC60216*
//#UC END# *470321950119for48564FC60216*

// генератор реализации фабрик интерфейсов на java (.java)
+ fctr.java
//#UC START# *470321C1038Afor48564FC60216*
//#UC END# *470321C1038Afor48564FC60216*

// Функции стереотипа
%f _st_space_key
	SHD


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
%t _constraint
//#UC START# *4704C0E30186for48564FC60216*
c	{}
r {""=""}: {}
//#UC END# *4704C0E30186for48564FC60216*

// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
%f _wiki_child_kind
//#UC START# *4705CBD6003Efor48564FC60216*
	uses
//#UC END# *4705CBD6003Efor48564FC60216*

// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
%f _wiki_up_add_gen
//#UC START# *470484D50138for48564FC60216*
//#UC END# *470484D50138for48564FC60216*


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

