////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/CommonTemplates/CommonLang/ImplementationTypes/method.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAClass::Class>> MDProcess$Templates::CommonTemplates::CommonLang::ImplementationTypes::method
//
// Метод класса
// ---
// [$140282719]
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//: method::Class
implementation @ <<method>>
//? Метод класса
//? [$140282719]
//> localmethod::Class

//= WikiImplClass::Class
//= UsesContainer::Class
//= Delphi интерфейсы и реализация::MDAGenerator

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Параметры стереотипа
//v -#+
// - типы видимости
//a fra
// - тип абстракции
//Y code_method.gif
//L code_method
// Параметры визуализации
//$ C 240,205,240
//$ l 120,40,120
//$ f 120,40,120
//m t
// - может быть реализован/иметь перекрытую реализацию

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Пользовательские свойства

//p is static:tribool=undefined ? Определяет, что метод принадлежит мета-классу

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функции стереотипа

//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'

//%f _wiki_up_print
; // st_space_key

: wiki_up_print OBJECT IN %S
//	%S#[inherited][{"%S{is static}"!="%S{!is static}"}%f_up_prefix(%S) *is static* = *%S{is static}* - Определяет, что метод принадлежит мета-классу
 ?inherited
 %IF ( ( %S get_up ( 'is static' ) ) %!= ( %S get_up_def ( 'is static' ) ) ) 
  [%f] up_prefix %( %S )% ' *is static* = *'
  %S get_up ( 'is static' ) '* - Определяет, что метод принадлежит мета-классу'
//	]
 %END-IF

// Выводит переменные
//%f _pas_OutVars
; // wiki_up_print

: pas_OutVars OBJECT IN %S
// параметры: aVisibility: a-string = %1
//#UC START# *4BB206CD02BBfor49CB43D403C5*
//	%f_set_var(WAS_VARS,"false")\
 [%f] set_var %( 'WAS_VARS' %, false )% 
//	<{\n }{%CV=%1N&%C#f_IsVar()=true&%C#f_IsGlobalVar()!=true}\
 %FOR %ITEM-SEPARATOR #13#10' ' ; // %ITEM-SEPARATOR 
  %ITEM-CONDITION ( ( %C |V ) %== ( %1 |N ) %&& 
   ( ( %C %?f IsVar %( )% ) %==  true  ) %&& 
   ( ( %C %?f IsGlobalVar %( )% ) %!=  true  ) ) 


//	[{%{WAS_VARS}N=false}\
  %IF ( ( ( get_global_var ( 'WAS_VARS' ) |N ) ) %==  false ) 
//	%f_set_var(WAS_VARS,"true")\
   [%f] set_var %( 'WAS_VARS' %, true )% 

//	[{%1N!=ProtectedAccess}\
   %IF ( ( %1 |N ) %!= 'ProtectedAccess' ) 
//	\n\
    #13#10
//	]\
   %END-IF


//	%S%f_Ind()\
   %S %f Ind %( )% 
//	var
   'var'
//	 \
   ' '
//	]\
  %END-IF


//	%C%f_pas_OutVar()\
  %C %f pas_OutVar %( )% 
//	>\
 %END-FOR
//	[{%{WAS_VARS}N=true&%1N=ProtectedAccess}\
 %IF ( ( ( get_global_var ( 'WAS_VARS' ) |N ) ) %==  true %&& 
   ( ( %1 |N ) %== 'ProtectedAccess'  ) ) 
//	\n\
  #13#10
//	]
 %END-IF
//#UC END# *4BB206CD02BBfor49CB43D403C5*
; // pas_OutVars


// Конструирует вызов итератора
//%f _SpellIteratorCall
: SpellIteratorCall OBJECT IN %S
// параметры: anIterator: MDAClass = %1
//#UC START# *4C0FD8D9007Dfor49CB43D403C5*
//	%S%f_add_dependency(%SU_%1%T%PU_uses,%1%T%PU,uses,,USES_Inst)\
 %S %f add_dependency %( %S |U '_'
 %1 ->T ->P |U   '_uses' %, %1 ->T ->P |U   %, 'uses' %, '' %, 'USES_Inst' )% 
//	[{"%1{iterator func name}"!=""}{\
 %IF ( ( %1 get_up ( 'iterator func name' ) ) %!= '' ) 
  %ELSE
//	%f_set_var(DoIt_Name,"DoIt")\
   [%f] set_var %( 'DoIt_Name' %, 'DoIt' )% 
//	}\
  %THEN
//	%f_set_var(DoIt_Name,"%1{iterator func name}")\
  [%f] set_var %( 'DoIt_Name' %, %1 get_up ( 'iterator func name' ) )% 
//	]\
 %END-IF
//	%f_set_var(Action_Inst,"")\
 [%f] set_var %( 'Action_Inst' %, '' )% 
//	%{method_children}<{}{%CS=localmethod&%CN=%{DoIt_Name}N}\
 ( get_global_var ( 'method_children' ) ) 
 %FOR %ITEM-CONDITION ( ( %C |S ) %== 'localmethod' %&& 
   ( ( %C |N ) %== ( ( get_global_var ( 'DoIt_Name' ) |N ) )  ) ) 
//	%f_set_var(Action_Inst,C)\
  [%f] set_var %( 'Action_Inst' %, 'C' )% 
//	>\
 %END-FOR
//	[{"%{Action_Inst}N"=""}\
 %IF ( ( ( get_global_var ( 'Action_Inst' ) |N ) ) %== '' ) 
//	%S%f_add_class(%1U_Stub,localmethod,%{DoIt_Name}N,Action_Inst)\
  %S %f add_class %( %1 |U '_Stub' %, 'localmethod' %, ( get_global_var ( 'DoIt_Name' ) |N ) %, 'Action_Inst' )% 
//	]\
 %END-IF

//	[{"%{Action_Inst}D"=""|%{Action_Inst}D=undefined}\
 %IF ( ( ( get_global_var ( 'Action_Inst' ) |D ) ) %== '' %|| 
   ( ( ( get_global_var ( 'Action_Inst' ) |D ) ) %== 'undefined'  ) ) 
//	%{Action_Inst}%f_set_documentation(Подитеративная функция для вызова %1%T%{Stub}%f_pas_MethodName() из %SN)\
  ( get_global_var ( 'Action_Inst' ) %f set_documentation %( 'Подитеративная функция для вызова '
  %1 ->T ( get_object_var ( 'Stub' ) %f pas_MethodName %( )% )   ' из '
  %S |N )% ) 
//	]\
 %END-IF

//	%f_set_var(ITEM_TYPE,"")\
 [%f] set_var %( 'ITEM_TYPE' %, '' )% 
//	%1%T[{%SC=Class}{\
 %1 ->T%IF ( ( %S |C ) %== 'Class' ) 
  %ELSE
//	%f_set_var(ITEM_TYPE,T)\
   [%f] set_var %( 'ITEM_TYPE' %, 'T' )% 
//	}\
  %THEN
//	<{}{%CS=element type}%f_set_var(ITEM_TYPE,C%T)>\
  %FOR %ITEM-CONDITION ( ( %C |S ) %== 'element type' ) 
   [%f] set_var %( 'ITEM_TYPE' %, 'C'
   %T )% 
  %END-FOR
//	]\
 %END-IF
  
//	[{%1%T{needs index}=true}{\
 %IF ( ( %1 ->T get_up ( 'needs index' )  ) %==  true ) 
  %ELSE
//	%{Action_Inst}%f_add_operation(%1U_Stub_Sig,,\
   ( get_global_var ( 'Action_Inst' ) %f add_operation %( %1 |U '_Stub_Sig' %, '' %, 
//	DoIt (anItem: %{ITEM_TYPE}U): boolean,Op_Instance\
   'DoIt (anItem: '
   ( get_global_var ( 'ITEM_TYPE' ) |U ) '): boolean' %, 'Op_Instance'
//	)\
)% ) //	}\
  %THEN
//	[{"%{Integer}N"=""}%f_find_element(46A606AC03B2,Integer)]\
  %IF ( ( ( get_global_var ( 'Integer' ) |N ) ) %== '' ) 
   [%f] find_element %( '46A606AC03B2' %, 'Integer' )% 
  %END-IF
//	%{Action_Inst}%f_add_operation(%1U_Stub_Sig,,\
  ( get_global_var ( 'Action_Inst' ) %f add_operation %( %1 |U '_Stub_Sig' %, '' %, 
//	DoIt (anItem: %{ITEM_TYPE}U\
  'DoIt (anItem: '
  ( get_global_var ( 'ITEM_TYPE' ) |U ) 
//	, anIndex: %{Integer}U): boolean,Op_Instance\
%,   ' anIndex: '
  ( get_global_var ( 'Integer' ) |U ) '): boolean' %, 'Op_Instance'
//	)\
)% ) //	]\
 %END-IF

//	%S%f_set_uc_content(intf.pas,_%f_pas_MethodOwnerID(%S,%P)_impl,\
 %S %f set_uc_content %( 'intf.pas' %, '_'
 [%f] pas_MethodOwnerID %( %S %, %P )% '_impl' %, 
//	 %U[{iter}\n \
 ' '
 %U%IF ( 'iter' ) 
  #13#10' '
//	%S%f_Ind()\
  %S %f Ind %( )% 
//	]
 %END-IF
 //	%S%f_Ind()\
 %S %f Ind %( )% 
//	  %1%T%f_pas_MethodName("f")(%1%T%{Stub}%f_pas_MethodName()(@%{Action_Inst}%f_pas_MethodName())\
 '  '
 %1 ->T %f pas_MethodName %( 'f' )%  '('
 %1 ->T ( get_object_var ( 'Stub' ) %f pas_MethodName %( )% )   '(@'
 ( get_global_var ( 'Action_Inst' ) %f pas_MethodName %( )% ) ')'
//	[{%1{iterator needs params}=true&%1%T<{}{%CS=in}{C}>!=0}\
 %IF ( ( %1 get_up ( 'iterator needs params' ) ) %==  true %&& 
   ( ( %1 ->T
  %FOR %ITEM-CONDITION ( ( %C |S ) %== 'in' ) 
   ( 'C' ) 
  %END-FOR
  )   %!= 0  ) ) 
//	

//	%S%f_Ind()\
  %S %f Ind %( )% 
//	   %U[{iterparam}\n   \
  '   '
  %U%IF ( 'iterparam' ) 
   #13#10'   '
//	%S%f_Ind()\
   %S %f Ind %( )% 
//	]
  %END-IF
 //	%S%f_Ind()\
  %S %f Ind %( )% 
//	  ]\
  '  ' 
 %END-IF
//	)\
 ')'


//	[{%1{needs after iterator UC}=true}{\
 %IF ( ( %1 get_up ( 'needs after iterator UC' ) ) %==  true ) 
  %ELSE
//	;\
   ';'
//	}\
  %THEN
//	\n %S%f_Ind()\
  #13#10' '
  %S %f Ind %( )% 
//	%U[{afteriter}\n \
  %U%IF ( 'afteriter' ) 
   #13#10' '
//	%S%f_Ind()\
   %S %f Ind %( )% 
//	]\
  %END-IF
 //	]\
 %END-IF


//	)
)% //#UC END# *4C0FD8D9007Dfor49CB43D403C5*
; // SpellIteratorCall


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for49CB43D403C5*
//c          {}
//r {""=""}: {}
//#UC END# *4704C0E30186for49CB43D403C5*
; // constraint


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
//%f _DoSpell
: DoSpell OBJECT IN %S
//#UC START# *4B2A19E3038Bfor49CB43D403C5*
//	%S%[inherited]\
 inherited
//	%f_clear_list(method_children)\
 [%f] clear_list %( 'method_children' )% 
//	<{}{}{%C}%f_add_to_list(method_children,C)>\
 %FOR ( %C ) 
  [%f] add_to_list %( 'method_children' %, 'C' )% 
 %END-FOR

//	%{method_children}<{}{%CS=call&%C%T#f_IsIterator()=true}\
 ( get_global_var ( 'method_children' ) ) 
 %FOR %ITEM-CONDITION ( ( %C |S ) %== 'call' %&& 
   ( ( %C ->T %?f IsIterator %( )%  ) %==  true  ) ) 
//	%1%f_SpellIteratorCall(%C)\
  %1 %f SpellIteratorCall %( %C )% 
//	>\
 %END-FOR
//	%f_clear_list(method_children)\
 [%f] clear_list %( 'method_children' )% 
//	[{%Gx=true}\
 %IF ( ( %G |x ) %==  true ) 
//	[{%S#f_IsFactory()!=true}\
  %IF ( ( %S %?f IsFactory %( )% ) %!=  true ) 
//	[{%S{is static}=true|"<{}{%CC=Operation}{C}>"="0"}\
   %IF ( ( %S get_up ( 'is static' ) ) %==  true %|| 
     ( 
    %FOR %ITEM-CONDITION ( ( %C |C ) %== 'Operation' ) 
     ( 'C' ) 
    %END-FOR
    %== 0  ) ) 

// - тут будем делать методу такую же сигнатуру, как у того метода, 

//   от которого он наследуется
//	<{}{%G#f_IsFactory()=true|%G#f_IsMethod()=true|%GS=Function}\
    %FOR %ITEM-CONDITION ( ( %G %?f IsFactory %( )% ) %==  true %|| 
      ( ( %G %?f IsMethod %( )% ) %==  true  ) %|| 
      ( ( %G |S ) %== 'Function'  ) ) 
//	%G<{}{%CC=Operation}\
     %G
     %FOR %ITEM-CONDITION ( ( %C |C ) %== 'Operation' ) 


//	%C<{}{%CC=Parameter}{%C}\
      %C
      %FOR %ITEM-CONDITION ( ( %C |C ) %== 'Parameter' ) 
       ( %C ) 

//	%C<{}{%CC=Parameter|"%CC"=""}{%C}\

//	%f_warning(%CN)\

//	%f_warning(%C%TN)\
//	%2%P%f_make_accessable(%C%TU)\
       %2 ->P %f make_accessable %( %C ->T |U  )%  
//	>\
      %END-FOR
 
// - прописываем связи к типам параметров


//	%C%f_copy_element(%CU_%1U,%1U,,%CN,true,Op_Instance)\
      %C %f copy_element %( %C |U '_'
      %1 |U %, %1 |U %, '' %, %C |N %, true %, 'Op_Instance' )% 


//	[{%1%Rx=true}\

//	%{Op_Instance}%f_set_target(%1%RU)\

//	]\

//	%{Op_Instance}%f_set_documentation(Сигнатура метода %1%PN.%1N)\
//	%{Op_Instance}%f_set_documentation(%SD)\
      ( get_global_var ( 'Op_Instance' ) %f set_documentation %( %S |D )% ) 
//	%{Op_Instance}%f_set_abstraction_type(final)\
      ( get_global_var ( 'Op_Instance' ) %f set_abstraction_type %( 'final' )% ) 
//	%{Op_Instance}%f_set_visibility_type(PrivateAccess)\
      ( get_global_var ( 'Op_Instance' ) %f set_visibility_type %( 'PrivateAccess' )% ) 
//	%f_cycle_break(%S)\
      [%f] cycle_break %( %S )% 
//	>\
     %END-FOR
 //	>\
    %END-FOR
//	]\
   %END-IF

//	%S{is static}
//	]\
  %END-IF
//	]\
 %END-IF
//	[{%S#f_IsFactory()!=true&"<{}{%CC=Operation}{C}>"="0"}\
 %IF ( ( %S %?f IsFactory %( )% ) %!=  true %&& 
   ( 
  %FOR %ITEM-CONDITION ( ( %C |C ) %== 'Operation' ) 
   ( 'C' ) 
  %END-FOR
  %== 0  ) ) 

// - добавляем сигнатуру без параметров
//	%S%f_add_operation(%SU_DoIt,,DoIt (),Op_Instance)\
  %S %f add_operation %( %S |U '_DoIt' %, '' %, 'DoIt ()' %, 'Op_Instance' )% 
//	%{Op_Instance}%f_set_documentation(Сигнатура метода %SN)\
  ( get_global_var ( 'Op_Instance' ) %f set_documentation %( 'Сигнатура метода '
  %S |N )% ) 
//	]
 %END-IF
//#UC END# *4B2A19E3038Bfor49CB43D403C5*
; // DoSpell


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
//%f _FirstParamIsViewAreaController
: FirstParamIsViewAreaController OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *4CBEFA1402F2for49CB43D403C5*
//@ %SU
//	<{}{%C#f_IsMethod()!=true}\
 %FOR %ITEM-CONDITION ( ( %C %?f IsMethod %( )% ) %!=  true ) 
//	%C%f_FirstParamIsViewAreaController()\
  %C %f FirstParamIsViewAreaController %( )% 
//	%f_cycle_break(%S)\
  [%f] cycle_break %( %S )% 
//	>
 %END-FOR
//#UC END# *4CBEFA1402F2for49CB43D403C5*
; // FirstParamIsViewAreaController


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
//%f _FirstParamName
: FirstParamName OBJECT IN %S
// возвращаемый результат: a-string
//#UC START# *4CBEFF7C020Bfor49CB43D403C5*
//@ %SU
//	<{}{%C#f_IsMethod()!=true}\
 %FOR %ITEM-CONDITION ( ( %C %?f IsMethod %( )% ) %!=  true ) 
//	%C%f_FirstParamName()\
  %C %f FirstParamName %( )% 
//	%f_cycle_break(%S)\
  [%f] cycle_break %( %S )% 
//	>
 %END-FOR
//#UC END# *4CBEFF7C020Bfor49CB43D403C5*
; // FirstParamName


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Есть ли у операции параметры
//%f _HasParams
: HasParams OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *4AE065E20005for49CB43D403C5*
//@ %SU
//	<{}{%C#f_IsMethod()!=true}%C%f_HasParams()>
 %FOR %ITEM-CONDITION ( ( %C %?f IsMethod %( )% ) %!=  true ) 
  %C %f HasParams %( )% 
 %END-FOR
//#UC END# *4AE065E20005for49CB43D403C5*
; // HasParams


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Определяет, что элемент является "внутренностью" класса, атрибутом или операцией
//%f _IsClassInner
: IsClassInner OBJECT IN %S
//#UC START# *49CB3EE70382for49CB43D403C5*
//	true
 true
//#UC END# *49CB3EE70382for49CB43D403C5*
; // IsClassInner


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
//%f _IsMethod
: IsMethod OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *4B2A29440092for49CB43D403C5*
//	true
 true
//#UC END# *4B2A29440092for49CB43D403C5*
; // IsMethod


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
//%f _OutCallParams
: OutCallParams OBJECT IN %S
// возвращаемый результат: a-string
//#UC START# *4AE066F202E2for49CB43D403C5*
//	[(%C<{, }%CN>)]
 %IF-NOT-EMPTY
  '('
  %C
  %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
   %C |N 
  %END-FOR
   ')' 
 %END-IF
//#UC END# *4AE066F202E2for49CB43D403C5*
; // OutCallParams


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
//%f _pas_CallingConventionsDirective
: pas_CallingConventionsDirective OBJECT IN %S
// возвращаемый результат: a-string
//#UC START# *4CBD7CFE025Bfor49CB43D403C5*
//@ %SU
//	<{}{%CC=Operation}\
 %FOR %ITEM-CONDITION ( ( %C |C ) %== 'Operation' ) 
//	%C%f_pas_CallingConventionsDirective()\
  %C %f pas_CallingConventionsDirective %( )% 
//	%f_cycle_break(%S)\
  [%f] cycle_break %( %S )% 
//	>
 %END-FOR
//#UC END# *4CBD7CFE025Bfor49CB43D403C5*
; // pas_CallingConventionsDirective


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Выводит секцию определений метода
//%f _pas_MethodDeclarations
: pas_MethodDeclarations OBJECT IN %S
//#UC START# *49CB54AA033Afor49CB43D403C5*
//	[\
 %IF-NOT-EMPTY
//	<{}{%C#f_IsMethod()=true&%CV=PrivateAccess}\
  %FOR %ITEM-CONDITION ( ( %C %?f IsMethod %( )% ) %==  true %&& 
    ( ( %C |V ) %== 'PrivateAccess'  ) ) 
//	%C%f_pas_MethodImplementation()\n\
   %C %f pas_MethodImplementation %( )% #13#10
//	>\
  %END-FOR
//	\n\
  #13#10
//	]\
 %END-IF

//	[\
 %IF-NOT-EMPTY


//	%S%f_pas_OutVars("ProtectedAccess")\
  %S %f pas_OutVars %( 'ProtectedAccess' )% 

//	[\
  %IF-NOT-EMPTY
//	<{}{%C#f_IsMethod()=true&%CV!=PrivateAccess}\
   %FOR %ITEM-CONDITION ( ( %C %?f IsMethod %( )% ) %==  true %&& 
     ( ( %C |V ) %!= 'PrivateAccess'  ) ) 
//	%C%f_pas_MethodImplementation()\n\
    %C %f pas_MethodImplementation %( )% #13#10
//	>\
   %END-FOR
//	]\n\
  %END-IF
  #13#10
//	]\
 %END-IF

//	%S%[inherited]\
 inherited
//	%S%f_pas_OutVars("PrivateAccess")
 %S %f pas_OutVars %( 'PrivateAccess' )% 
//#UC END# *49CB54AA033Afor49CB43D403C5*
; // pas_MethodDeclarations


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// выводит реализацию метода
// 
// RealizeType = o|r|f
//%f _pas_MethodImplementation
: pas_MethodImplementation OBJECT IN %S
// параметры: Implementator: void = %1, RealizeType: void = %2, Modification: void = %3, aOverrider: MDAClass = %4
//#UC START# *494BEC7C03E5for49CB43D403C5*
//	[\nvar
 %IF-NOT-EMPTY
  #13#10'var'
//	 \
  ' '
//	<{}{%CV=ProtectedAccess&%C#f_IsGlobalVar()=true}\
  %FOR %ITEM-CONDITION ( ( %C |V ) %== 'ProtectedAccess' %&& 
    ( ( %C %?f IsGlobalVar %( )% ) %==  true  ) ) 
//	[ %C%f_pas_OutVar()\n]\
   %IF-NOT-EMPTY
    ' '
    %C %f pas_OutVar %( )% #13#10 
   %END-IF
//	>\
  %END-FOR
//	]\
 %END-IF

//	[{%R#f_IsClassImplementableElement()=true}{\
 %IF ( ( %R %?f IsClassImplementableElement %( )% ) %==  true ) 
  %ELSE
//	<{}{%C#f_IsMethod()!=true&%CC=Operation}\
   %FOR %ITEM-CONDITION ( ( %C %?f IsMethod %( )% ) %!=  true %&& 
     ( ( %C |C ) %== 'Operation'  ) ) 
//	%C%f_pas_DoMethodImplementation(%1,%2,%3)\
    %C %f pas_DoMethodImplementation %( %1 %, %2 %, %3 )% 
//	>\
   %END-FOR
//	}\
  %THEN
//	%R%f_pas_MethodImplementation(%1,%2,%3,%4)\
  %R %f pas_MethodImplementation %( %1 %, %2 %, %3 %, %4 )% 
//	]
 %END-IF
//#UC END# *494BEC7C03E5for49CB43D403C5*
; // pas_MethodImplementation


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// выводит интерфейс метода
// 
// RealizeType = o|r|f
//%f _pas_MethodInterface
: pas_MethodInterface OBJECT IN %S
// параметры: Implementator: void = %1, RealizeType: void = %2, Modification: void = %3, aOverrider: MDAClass = %4
//#UC START# *494BEC6A038Afor49CB43D403C5*
//	[\nvar
 %IF-NOT-EMPTY
  #13#10'var'
//	 \
  ' '
//	<{}{%CV=PublicAccess&%C#f_IsGlobalVar()=true}\
  %FOR %ITEM-CONDITION ( ( %C |V ) %== 'PublicAccess' %&& 
    ( ( %C %?f IsGlobalVar %( )% ) %==  true  ) ) 
//	[ %C%f_pas_OutVar()\n]\
   %IF-NOT-EMPTY
    ' '
    %C %f pas_OutVar %( )% #13#10 
   %END-IF
//	>\
  %END-FOR
//	]\
 %END-IF

//	[{%R#f_IsClassImplementableElement()=true}{\
 %IF ( ( %R %?f IsClassImplementableElement %( )% ) %==  true ) 
  %ELSE
//	<{}{%C#f_IsMethod()!=true&%CC=Operation}\
   %FOR %ITEM-CONDITION ( ( %C %?f IsMethod %( )% ) %!=  true %&& 
     ( ( %C |C ) %== 'Operation'  ) ) 
//	%C%f_pas_DoMethodInterface(%1,%2,%3)\
    %C %f pas_DoMethodInterface %( %1 %, %2 %, %3 )% 
//	>\
   %END-FOR
//	}\
  %THEN
//	%R%f_pas_MethodInterface(%1,%2,%3)\
  %R %f pas_MethodInterface %( %1 %, %2 %, %3 )% 
//	]
 %END-IF
//#UC END# *494BEC6A038Afor49CB43D403C5*
; // pas_MethodInterface


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Выводит имя владельца метода
//%f _pas_MethodOwnerName
: pas_MethodOwnerName OBJECT IN %S
//#UC START# *49CB3C99034Bfor49CB43D403C5*
//	[{%1S=localmethod}{\
 %IF ( ( %1 |S ) %== 'localmethod' ) 
  %ELSE
//	%P%f_pas_MethodOwnerName(%S)\
   %P %f pas_MethodOwnerName %( %S )% 
//	}\
  %THEN
//	]
 %END-IF
//#UC END# *49CB3C99034Bfor49CB43D403C5*
; // pas_MethodOwnerName


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Параметры операции
//%f _pas_Params
: pas_Params OBJECT IN %S
// параметры: Modification: void = %1
//#UC START# *494BDCF3030Efor49CB43D403C5*
//	<{}{%C#f_IsMethod()!=true}%C%f_pas_Params()>
 %FOR %ITEM-CONDITION ( ( %C %?f IsMethod %( )% ) %!=  true ) 
  %C %f pas_Params %( )% 
 %END-FOR
//#UC END# *494BDCF3030Efor49CB43D403C5*
; // pas_Params


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor49CB43D403C5*
//R  
//	[{%Sa!=abstract}\
 %IF ( ( %S |a ) %!= 'abstract' ) 
//	[{%R#f_IsClassImplementableElement()=true}{\
  %IF ( ( %R %?f IsClassImplementableElement %( )% ) %==  true ) 
   %ELSE
//	<{}{%C#f_IsMethod()!=true}%CX>\
    %FOR %ITEM-CONDITION ( ( %C %?f IsMethod %( )% ) %!=  true ) 
     %C |X 
    %END-FOR
//	}\
   %THEN
//	%S%f_pas_MethodImplementation(%P,"r","",%S)\
   %S %f pas_MethodImplementation %( %P %, 'r"' %, '' %, %S )% 
//	]\
  %END-IF
//	]
 %END-IF
//#UC END# *470F15B800CBfor49CB43D403C5*
; // impl.pas


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor49CB43D403C5*
//R  
//	[{%R#f_IsClassImplementableElement()=true}{\
 %IF ( ( %R %?f IsClassImplementableElement %( )% ) %==  true ) 
  %ELSE
//	<{}{%C#f_IsMethod()!=true}%CX>\
   %FOR %ITEM-CONDITION ( ( %C %?f IsMethod %( )% ) %!=  true ) 
    %C |X 
   %END-FOR
//	}\
  %THEN
//	%S%f_pas_MethodInterface(%P,"r","",%S)\
  %S %f pas_MethodInterface %( %P %, 'r"' %, '' %, %S )% 
//	]
 %END-IF
//#UC END# *470F1571031Cfor49CB43D403C5*
; // intf.pas


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
//+ intf2.pas
<<generator>> intf2.pas OBJECT IN %S
//R  
//#UC START# *477398E501C0for49CB43D403C5*
//#UC END# *477398E501C0for49CB43D403C5*
; // intf2.pas


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// 3-я секция интерфейса. Например поле для свойства.
//+ intf3.pas
<<generator>> intf3.pas OBJECT IN %S
//R  
//#UC START# *4774D2A20372for49CB43D403C5*
//#UC END# *4774D2A20372for49CB43D403C5*
; // intf3.pas


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Скрипты TC (.sd)
//+ sd
<<generator>> sd OBJECT IN %S
//R  
//#UC START# *4DE79AFC0030for49CB43D403C5*
//#UC END# *4DE79AFC0030for49CB43D403C5*
; // sd


// реализация абстрактного стереотипа Документация::MDAGenerator
// Хак для [$281531116]
//+ link_to_requests_hack
<<generator>> link_to_requests_hack OBJECT IN %S
//#UC START# *4E65F581015Afor49CB43D403C5*
//#UC END# *4E65F581015Afor49CB43D403C5*
; // link_to_requests_hack


// перекрытие базового стереотипа ModelBuilding::MDAGenerator
// генератор построения виртуальных элементов модели - запускается до генерации конкретных
// артефактов
//+ spell
<<generator>> spell OBJECT IN %S
//#UC START# *4A41A13D03D5for49CB43D403C5*
//	%S%f_DoSpell()\
 %S %f DoSpell %( )% 
//	<%CX>
 %FOR %C |X 
 %END-FOR
//#UC END# *4A41A13D03D5for49CB43D403C5*
; // spell


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Вложенные стереотипы

//: method::Class::Operation
end. // <<method>>

implementation @ :: <<method>> <<Operation>> ;
//? Сигнатура метода
//= CallingConventionsHolder::Class
//= Delphi интерфейсы и реализация::MDAGenerator

// Параметры стереотипа
//v -
// - типы видимости
//e g
// - возможность использовать исключения
//a f
// - тип абстракции
//Y code_method.gif
//L code_method
//T 
// - может не иметь "цели" (типа/результата)

// Генераторы
// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor49CB473A0201*
//R  
//	%S%f_pas_MethodInterface()
 %S %f pas_MethodInterface %( )% 
//#UC END# *470F1571031Cfor49CB473A0201*
; // intf.pas


// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor49CB473A0201*
//R  
//	%S%f_pas_MethodImplementation()
 %S %f pas_MethodImplementation %( )% 
//#UC END# *470F15B800CBfor49CB473A0201*
; // impl.pas


// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
//+ intf2.pas
<<generator>> intf2.pas OBJECT IN %S
//R  
//#UC START# *477398E501C0for49CB473A0201*
//#UC END# *477398E501C0for49CB473A0201*
; // intf2.pas


// 3-я секция интерфейса. Например поле для свойства.
//+ intf3.pas
<<generator>> intf3.pas OBJECT IN %S
//R  
//#UC START# *4774D2A20372for49CB473A0201*
//#UC END# *4774D2A20372for49CB473A0201*
; // intf3.pas


// Скрипты TC (.sd)
//+ sd
<<generator>> sd OBJECT IN %S
//R  
//#UC START# *4DE79AFC0030for49CB473A0201*
//#UC END# *4DE79AFC0030for49CB473A0201*
; // sd


// Хак для [$281531116]
//+ link_to_requests_hack
<<generator>> link_to_requests_hack OBJECT IN %S
//#UC START# *4E65F581015Afor49CB473A0201*
//#UC END# *4E65F581015Afor49CB473A0201*
; // link_to_requests_hack


// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for49CB473A0201*
//#UC END# *46E6D4BB0339for49CB473A0201*
; // wiki


// Генератор файлов форм (.dfm)
//+ dfm
<<generator>> dfm OBJECT IN %S
//R  
//#UC START# *49F5795900ECfor49CB473A0201*
//#UC END# *49F5795900ECfor49CB473A0201*
; // dfm


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'

//%f _wiki_up_print
; // st_space_key

: wiki_up_print OBJECT IN %S
//	%S%[Delphi интерфейсы и реализация::MDAGenerator]f_wiki_up_print()[{"%S{calling conventions}"!="%S{!calling conventions}"}%f_up_prefix(%S) *calling conventions* = *%S{calling conventions}* - Соглашения о вызове
 call-inherited:: 'Delphi интерфейсы и реализация' wiki_up_print %( )%
 %IF ( ( %S get_up ( 'calling conventions' ) ) %!= ( %S get_up_def ( 'calling conventions' ) ) ) 
  [%f] up_prefix %( %S )% ' *calling conventions* = *'
  %S get_up ( 'calling conventions' ) '* - Соглашения о вызове'
//	]
 %END-IF


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
; // wiki_up_print

<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for49CB473A0201*
//c          {}
//r {""=""}: {}
//#UC END# *4704C0E30186for49CB473A0201*
; // constraint


// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor49CB473A0201*
//	method
 'method'
//#UC END# *4705CBD6003Efor49CB473A0201*
; // wiki_child_kind


// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
//%f _wiki_up_add_gen
: wiki_up_add_gen OBJECT IN %S
//#UC START# *470484D50138for49CB473A0201*
//#UC END# *470484D50138for49CB473A0201*
; // wiki_up_add_gen


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Отступ. Аналог #, только с учётом особенностей Delphi
//%f _Ind
: Ind OBJECT IN %S
// возвращаемый результат: a-string
//#UC START# *4BB2008E003Afor49CB473A0201*
//	%P%f_Ind()
 %P %f Ind %( )% 
//#UC END# *4BB2008E003Afor49CB473A0201*
; // Ind


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Элемент является виртуальным
//%f _IsVirtual
: IsVirtual OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *4BC4823500C1for49CB473A0201*
//	%P%f_IsVirtual()
 %P %f IsVirtual %( )% 
//#UC END# *4BC4823500C1for49CB473A0201*
; // IsVirtual


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// выводит ключевое слова типа абстракности
// 
// RealizeType = o|r|f
// Modification = get|set|area|arearef
//%f _pas_AbstractionKeyword
: pas_AbstractionKeyword OBJECT IN %S
// параметры: Implementator: void = %1, RealizeType: void = %2, Modification: void = %3
//#UC START# *494BF05502ACfor49CB473A0201*
//	%P%f_pas_AbstractionKeyword(%1,%2,%3)
 %P %f pas_AbstractionKeyword %( %1 %, %2 %, %3 )% 
//#UC END# *494BF05502ACfor49CB473A0201*
; // pas_AbstractionKeyword


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Выводит тело метода
// 
// Modification = get|set|area|areareaf|o|r|f
//%f _pas_MethodBodyPrim
: pas_MethodBodyPrim OBJECT IN %S
// параметры: Implementator: void = %1, Modification: void = %2, RealizeType: a-string = %3, aOverrider: MDAClass = %4
//#UC START# *494BB3A201A2for49CB473A0201*
//	%P%f_pas_MethodBodyPrim(%1,%2,%3)
 %P %f pas_MethodBodyPrim %( %1 %, %2 %, %3 )% 
//#UC END# *494BB3A201A2for49CB473A0201*
; // pas_MethodBodyPrim


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Выводит секцию определений метода
//%f _pas_MethodDeclarations
: pas_MethodDeclarations OBJECT IN %S
//#UC START# *49CB54AA033Afor49CB473A0201*
//	%P%f_pas_MethodDeclarations(%1,%2)
 %P %f pas_MethodDeclarations %( %1 %, %2 )% 
//#UC END# *49CB54AA033Afor49CB473A0201*
; // pas_MethodDeclarations


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// выводит реализацию метода
// 
// RealizeType = o|r|f
//%f _pas_MethodImplementation
: pas_MethodImplementation OBJECT IN %S
// параметры: Implementator: void = %1, RealizeType: void = %2, Modification: void = %3, aOverrider: MDAClass = %4
//#UC START# *494BEC7C03E5for49CB473A0201*
//	%P%f_pas_MethodImplementation(%1,%2,%3)
 %P %f pas_MethodImplementation %( %1 %, %2 %, %3 )% 
//#UC END# *494BEC7C03E5for49CB473A0201*
; // pas_MethodImplementation


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// выводит интерфейс метода
// 
// RealizeType = o|r|f
//%f _pas_MethodInterface
: pas_MethodInterface OBJECT IN %S
// параметры: Implementator: void = %1, RealizeType: void = %2, Modification: void = %3, aOverrider: MDAClass = %4
//#UC START# *494BEC6A038Afor49CB473A0201*
//	%P%f_pas_MethodInterface(%1,%2,%3)
 %P %f pas_MethodInterface %( %1 %, %2 %, %3 )% 
//#UC END# *494BEC6A038Afor49CB473A0201*
; // pas_MethodInterface


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Выводит имя метода
//%f _pas_MethodName
: pas_MethodName OBJECT IN %S
// параметры: Modification: a-string = %1
//#UC START# *494BD6C80075for49CB473A0201*
//	%P%f_pas_MethodName(%1)
 %P %f pas_MethodName %( %1 )% 
//#UC END# *494BD6C80075for49CB473A0201*
; // pas_MethodName


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Параметры операции
//%f _pas_Params
: pas_Params OBJECT IN %S
// параметры: Modification: void = %1
//#UC START# *494BDCF3030Efor49CB473A0201*
//	[{%P#f_IsFactory()!=true|%P%P#f_IsVCMForm()!=true}{\
 %IF ( ( %P %?f IsFactory %( )% ) %!=  true %|| 
   ( ( %P ->P %?f IsVCMForm %( )%  ) %!=  true  ) ) 
  %ELSE
//	[%S%[inherited];]\
   %IF-NOT-EMPTY
    inherited
    ';' 
   %END-IF
//	%S%f_pas_VCMFormFactoryParams()\
   %S %f pas_VCMFormFactoryParams %( )% 
//	}\
  %THEN
//	%S%[inherited]\
  inherited
//	]
 %END-IF
//#UC END# *494BDCF3030Efor49CB473A0201*
; // pas_Params


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Имя типа результата функции
//%f _pas_ResultTypeName
: pas_ResultTypeName OBJECT IN %S
// параметры: Modification: void = %1
//#UC START# *494BDD190361for49CB473A0201*
//	[{%P%f_IsFactory()=true}{\
 %IF ( ( %P %f IsFactory %( )% ) %==  true ) 
  %ELSE
//	[{%P#f_IsFactoryOnModule()=true&%PS!=FactoryMethod}{\
   %IF ( ( %P %?f IsFactoryOnModule %( )% ) %==  true %&& 
     ( ( %P |S ) %!= 'FactoryMethod'  ) ) 
    %ELSE
//	%S%[inherited]\
     inherited
//	}\
    %THEN
//	%P%f_pas_ResultTypeName(%1)\
    %P %f pas_ResultTypeName %( %1 )% 
//	]\
   %END-IF
//	}\
  %THEN
//	%P%f_pas_ResultTypeName(%1)\
  %P %f pas_ResultTypeName %( %1 )% 
//	]
 %END-IF
//#UC END# *494BDD190361for49CB473A0201*
; // pas_ResultTypeName


// Вложенные стереотипы
//: method::Class::Operation::Parameter
end. // :: <<method>> <<Operation>> ;

implementation @ :: <<method>> <<Operation>> ;
// Параметры стереотипа
//Y code_param.gif
//L code_param

// Генераторы
// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor4BA74A87028D*
//#UC END# *470F1571031Cfor4BA74A87028D*
; // intf.pas


// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor4BA74A87028D*
//#UC END# *470F15B800CBfor4BA74A87028D*
; // impl.pas


// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
//+ intf2.pas
<<generator>> intf2.pas OBJECT IN %S
//R  
//#UC START# *477398E501C0for4BA74A87028D*
//#UC END# *477398E501C0for4BA74A87028D*
; // intf2.pas


// 3-я секция интерфейса. Например поле для свойства.
//+ intf3.pas
<<generator>> intf3.pas OBJECT IN %S
//R  
//#UC START# *4774D2A20372for4BA74A87028D*
//#UC END# *4774D2A20372for4BA74A87028D*
; // intf3.pas


// Скрипты TC (.sd)
//+ sd
<<generator>> sd OBJECT IN %S
//R  
//#UC START# *4DE79AFC0030for4BA74A87028D*
//#UC END# *4DE79AFC0030for4BA74A87028D*
; // sd


// Хак для [$281531116]
//+ link_to_requests_hack
<<generator>> link_to_requests_hack OBJECT IN %S
//#UC START# *4E65F581015Afor4BA74A87028D*
//#UC END# *4E65F581015Afor4BA74A87028D*
; // link_to_requests_hack


// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for4BA74A87028D*
//#UC END# *46E6D4BB0339for4BA74A87028D*
; // wiki


// Генератор файлов форм (.dfm)
//+ dfm
<<generator>> dfm OBJECT IN %S
//R  
//#UC START# *49F5795900ECfor4BA74A87028D*
//#UC END# *49F5795900ECfor4BA74A87028D*
; // dfm


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'



//: method::Class::var::Attribute
; // st_space_key

end. // :: <<method>> <<Operation>> ;

implementation @ :: <<method>> <<var>> ;
//? Локальная переменная
//= Delphi интерфейсы и реализация::MDAGenerator

// Параметры стереотипа
//v -#
// - типы видимости
//a f
// - тип абстракции
//Y code_attr.gif
//L code_attr
//l a
// - возможные типы связи атрибута

// Пользовательские свойства
//p IsResult:b=false ? Определяет, что переменная мапируется на результат функции

// Генераторы
// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor49CB56A601B9*
//#UC END# *470F1571031Cfor49CB56A601B9*
; // intf.pas


// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor49CB56A601B9*
//#UC END# *470F15B800CBfor49CB56A601B9*
; // impl.pas


// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
//+ intf2.pas
<<generator>> intf2.pas OBJECT IN %S
//R  
//#UC START# *477398E501C0for49CB56A601B9*
//#UC END# *477398E501C0for49CB56A601B9*
; // intf2.pas


// 3-я секция интерфейса. Например поле для свойства.
//+ intf3.pas
<<generator>> intf3.pas OBJECT IN %S
//R  
//#UC START# *4774D2A20372for49CB56A601B9*
//#UC END# *4774D2A20372for49CB56A601B9*
; // intf3.pas


// Скрипты TC (.sd)
//+ sd
<<generator>> sd OBJECT IN %S
//R  
//#UC START# *4DE79AFC0030for49CB56A601B9*
//#UC END# *4DE79AFC0030for49CB56A601B9*
; // sd


// Хак для [$281531116]
//+ link_to_requests_hack
<<generator>> link_to_requests_hack OBJECT IN %S
//#UC START# *4E65F581015Afor49CB56A601B9*
//#UC END# *4E65F581015Afor49CB56A601B9*
; // link_to_requests_hack


// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for49CB56A601B9*
//#UC END# *46E6D4BB0339for49CB56A601B9*
; // wiki


// Генератор файлов форм (.dfm)
//+ dfm
<<generator>> dfm OBJECT IN %S
//R  
//#UC START# *49F5795900ECfor49CB56A601B9*
//#UC END# *49F5795900ECfor49CB56A601B9*
; // dfm


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'

//%f _wiki_up_print
; // st_space_key

: wiki_up_print OBJECT IN %S
//	%S#[inherited][{"%S{IsResult}"!="%S{!IsResult}"}%f_up_prefix(%S) *IsResult* = *%S{IsResult}* - Определяет, что переменная мапируется на результат функции
 ?inherited
 %IF ( ( %S get_up ( 'IsResult' ) ) %!= ( %S get_up_def ( 'IsResult' ) ) ) 
  [%f] up_prefix %( %S )% ' *IsResult* = *'
  %S get_up ( 'IsResult' ) '* - Определяет, что переменная мапируется на результат функции'
//	]
 %END-IF

// Определяет, что элемент является переменной
//%f _IsVar
; // wiki_up_print

: IsVar OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *49CB585603D9for49CB56A601B9*
//	true
 true
//#UC END# *49CB585603D9for49CB56A601B9*
; // IsVar


// Выводит описание переменной
//%f _pas_OutVar
: pas_OutVar OBJECT IN %S
//#UC START# *4BB1DD42008Afor49CB56A601B9*
//	%S%f_Ind()\
 %S %f Ind %( )% 
//	[{%S#f_IsGlobalVar()=true}{l_}g_]\
 %IF ( ( %S %?f IsGlobalVar %( )% ) %==  true ) 
  %ELSE
   'l_' 
  %THEN
  'g_' 
 %END-IF
//	%SN : %f_pas_TypeName(%T)\
 %S |N ' : '
 [%f] pas_TypeName %( %T )% 
//	[{%S{IsResult}=true} absolute Result];\
 %IF ( ( %S get_up ( 'IsResult' ) ) %==  true ) 
  ' absolute Result' 
 %END-IF
 ';'
//	[ // %f_str_replace(%SD,\n,%f_space(%S))]
 %IF-NOT-EMPTY
  ' // '
  [%f] str_replace %( %S |D %, #13#10 %, [%f] space %( %S )% )% 
 %END-IF
//#UC END# *4BB1DD42008Afor49CB56A601B9*
; // pas_OutVar


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for49CB56A601B9*
//c          {}
//r {""=""}: {}
//#UC END# *4704C0E30186for49CB56A601B9*
; // constraint


// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor49CB56A601B9*
//	attr
 'attr'
//#UC END# *4705CBD6003Efor49CB56A601B9*
; // wiki_child_kind


// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
//%f _wiki_up_add_gen
: wiki_up_add_gen OBJECT IN %S
//#UC START# *470484D50138for49CB56A601B9*
//#UC END# *470484D50138for49CB56A601B9*
; // wiki_up_add_gen


// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Отступ. Аналог #, только с учётом особенностей Delphi
//%f _Ind
: Ind OBJECT IN %S
// возвращаемый результат: a-string
//#UC START# *4BB2008E003Afor49CB56A601B9*
//	%P%f_Ind()
 %P %f Ind %( )% 
//#UC END# *4BB2008E003Afor49CB56A601B9*
; // Ind


//: method::Class::globalvar::Attribute
end. // :: <<method>> <<var>> ;

implementation @ :: <<method>> <<globalvar>> ;
//? Глобальная переменная
//= method::Class::var::Attribute

// Параметры стереотипа
//v #+
// - типы видимости

// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'

//%f _IsGlobalVar
; // st_space_key

: IsGlobalVar OBJECT IN %S
// возвращаемый результат: boolean
//#UC START# *4B72F6B80275for4B72F4DD0345*
//	true
 true
//#UC END# *4B72F6B80275for4B72F4DD0345*
; // IsGlobalVar


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// перекрытие базового стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Отступ. Аналог #, только с учётом особенностей Delphi
//%f _Ind
: Ind OBJECT IN %S
// возвращаемый результат: a-string
//#UC START# *4BB2008E003Afor4B72F4DD0345*
//#UC END# *4BB2008E003Afor4B72F4DD0345*
; // Ind


//: method::Class::call::ClassDependency
end. // :: <<method>> <<globalvar>> ;

implementation @ :: <<method>> <<call>> ;
//? Вызов метода (итератора)
//= UsesContainer::Class::uses::ClassDependency

// Параметры стереотипа
//v -
// - типы видимости
//a f
// - тип абстракции

// Пользовательские свойства
//p iterator func name:s ? Имя подитеративной функции
//p iterator needs params:b=true ? Нужна ли пользовательская секция для передачи параметров
//p needs after iterator UC:b=false ? Нужна ли пользовательская секция после вызова

// Генераторы
// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for4BB0B8710126*
//#UC END# *46E6D4BB0339for4BB0B8710126*
; // wiki


// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor4BB0B8710126*
//#UC END# *47022C88029Ffor4BB0B8710126*
; // h


// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor4BB0B8710126*
//#UC END# *47022CB8034Bfor4BB0B8710126*
; // cpp


// генератор inline файлов реализации C++ (.i.h)
//+ i.h
<<generator>> i.h OBJECT IN %S
//#UC START# *47022CCF00EAfor4BB0B8710126*
//#UC END# *47022CCF00EAfor4BB0B8710126*
; // i.h


// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for4BB0B8710126*
//#UC END# *470321950119for4BB0B8710126*
; // java


// генератор реализации фабрик интерфейсов на java (.java)
//+ fctr.java
<<generator>> fctr.java OBJECT IN %S
//#UC START# *470321C1038Afor4BB0B8710126*
//#UC END# *470321C1038Afor4BB0B8710126*
; // fctr.java


// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor4BB0B8710126*
//#UC END# *470F1571031Cfor4BB0B8710126*
; // intf.pas


// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor4BB0B8710126*
//#UC END# *470F15B800CBfor4BB0B8710126*
; // impl.pas


// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
//+ intf2.pas
<<generator>> intf2.pas OBJECT IN %S
//R  
//#UC START# *477398E501C0for4BB0B8710126*
//#UC END# *477398E501C0for4BB0B8710126*
; // intf2.pas


// 3-я секция интерфейса. Например поле для свойства.
//+ intf3.pas
<<generator>> intf3.pas OBJECT IN %S
//R  
//#UC START# *4774D2A20372for4BB0B8710126*
//#UC END# *4774D2A20372for4BB0B8710126*
; // intf3.pas


// Генератор файлов форм (.dfm)
//+ dfm
<<generator>> dfm OBJECT IN %S
//R  
//#UC START# *49F5795900ECfor4BB0B8710126*
//#UC END# *49F5795900ECfor4BB0B8710126*
; // dfm


// Скрипты TC (.sd)
//+ sd
<<generator>> sd OBJECT IN %S
//R  
//#UC START# *4DE79AFC0030for4BB0B8710126*
//#UC END# *4DE79AFC0030for4BB0B8710126*
; // sd


// Хак для [$281531116]
//+ link_to_requests_hack
<<generator>> link_to_requests_hack OBJECT IN %S
//#UC START# *4E65F581015Afor4BB0B8710126*
//#UC END# *4E65F581015Afor4BB0B8710126*
; // link_to_requests_hack


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'

//%f _wiki_up_print
; // st_space_key

: wiki_up_print OBJECT IN %S
//	%S#[inherited][{"%S{iterator func name}"!="%S{!iterator func name}"}%f_up_prefix(%S) *iterator func name* = *%S{iterator func name}* - Имя подитеративной функции
 ?inherited
 %IF ( ( %S get_up ( 'iterator func name' ) ) %!= ( %S get_up_def ( 'iterator func name' ) ) ) 
  [%f] up_prefix %( %S )% ' *iterator func name* = *'
  %S get_up ( 'iterator func name' ) '* - Имя подитеративной функции'
//	][{"%S{needs after iterator UC}"!="%S{!needs after iterator UC}"}%f_up_prefix(%S) *needs after iterator UC* = *%S{needs after iterator UC}* - Нужна ли пользовательская секция после вызова
 %END-IF
 %IF ( ( %S get_up ( 'needs after iterator UC' ) ) %!= ( %S get_up_def ( 'needs after iterator UC' ) ) ) 
  [%f] up_prefix %( %S )% ' *needs after iterator UC* = *'
  %S get_up ( 'needs after iterator UC' ) '* - Нужна ли пользовательская секция после вызова'
//	][{"%S{iterator needs params}"!="%S{!iterator needs params}"}%f_up_prefix(%S) *iterator needs params* = *%S{iterator needs params}* - Нужна ли пользовательская секция для передачи параметров
 %END-IF
 %IF ( ( %S get_up ( 'iterator needs params' ) ) %!= ( %S get_up_def ( 'iterator needs params' ) ) ) 
  [%f] up_prefix %( %S )% ' *iterator needs params* = *'
  %S get_up ( 'iterator needs params' ) '* - Нужна ли пользовательская секция для передачи параметров'
//	]
 %END-IF


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
; // wiki_up_print

<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for4BB0B8710126*
//c          {}
//r {""=""}: {}
//#UC END# *4704C0E30186for4BB0B8710126*
; // constraint


// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
//%f _wiki_up_add_gen
: wiki_up_add_gen OBJECT IN %S
//#UC START# *470484D50138for4BB0B8710126*
//#UC END# *470484D50138for4BB0B8710126*
; // wiki_up_add_gen



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

end. // :: <<method>> <<call>> ;

