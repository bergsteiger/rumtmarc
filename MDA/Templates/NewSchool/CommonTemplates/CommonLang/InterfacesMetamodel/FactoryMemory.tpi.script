////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/CommonTemplates/CommonLang/InterfacesMetamodel/FactoryMemory.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAClass::Class>> MDProcess$Templates::CommonTemplates::CommonLang::InterfacesMetamodel::FactoryMemory
//
// Единая память для фабрик интерфейса
// ---
// Используется для указания фреймворку, что некоторые фабрики должны использовать единую "память"
// для созданных ими объектов. Может быть вложен в интерфейс, и использован как тип фабричного
// метода, что означает что данная фабрика будет использовать данную общую "память". Для
// идентификации объектов можно указать тип единого ключа (с помощью атрибута), с помощью которого
// будут идентифицироваться объекты внутри этой фабрики.
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//: FactoryMemory::Class
implementation @ <<FactoryMemory>>
//? Единая память для фабрик интерфейса
//? Используется для указания фреймворку, что некоторые фабрики должны использовать единую "память" для созданных ими объектов. Может быть вложен в интерфейс, и использован как тип фабричного метода, что означает что данная фабрика будет использовать данную общую "память". Для идентификации объектов можно указать тип единого ключа (с помощью атрибута), с помощью которого будут идентифицироваться объекты внутри этой фабрики.
//< *::Class,*::Category

//= WithFactory::MDAGenerator

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Параметры стереотипа
//Y code_factory_memory.gif
//L code_factory_memory
// Параметры визуализации
//$ C 130,170,200
//$ l 10,100,220
//$ f 10,100,220

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функции стереотипа

//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'

// выводит тип ключа используемого для идентификации объектов в общей "памяти"
//%f _dump_factory_mem_key
; // st_space_key

: dump_factory_mem_key OBJECT IN %S
//#UC START# *4753E98D0058for4753C0BC029E*
//	[{%X{lid}=cpp}{%f_dump_factory_mem_key_java(%S)}%f_dump_factory_mem_key_cpp(%S)]
 %IF ( ( %X get_up ( 'lid' ) ) %== 'cpp' ) 
  %ELSE
   [%f] dump_factory_mem_key_java %( %S )% 
  %THEN
  [%f] dump_factory_mem_key_cpp %( %S )% 
 %END-IF


//f _dump_factory_mem_key_java
; // dump_factory_mem_key

end. // <<FactoryMemory>>

: dump_factory_mem_key_java OBJECT IN %S
//	[{<{}{%CS=common key}{%CC}>=0}{\
 %IF ( 
  %FOR %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
   ( %C |C ) 
  %END-FOR
  %== 0 ) 
  %ELSE
//	#public static class %S%f_factory_mem_key_name() {
   out_indent 'public static class '
   %S %f factory_mem_key_name %( )% ' {'
//	<{}{%CS=common key}{%C}#	[{%f_check_if_type(%C%T,"string")=false}{public String %CNArg_;}public %t_attr(%C%T,"agr") %f_to_java(%CN_arg)_;]
   %FOR %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
    ( %C ) 
    out_indent '	'
    %IF ( ( [%f] check_if_type %( %C ->T  %, 'string' )% ) %==  false ) 
     %ELSE
      'public String '
      %C |N 'Arg_;' 
     %THEN
     'public '
     [%t] attr %( %C ->T  %, 'agr' )% ' '
     [%f] to_java %( %C |N '_arg' )% '_;' 
    %END-IF
//	>
   %END-FOR
//	#	public %S%f_factory_mem_key_name() (final %S%f_factory_mem_key_name() c) {
   out_indent '	public '
   %S %f factory_mem_key_name %( )% ' (final '
   %S %f factory_mem_key_name %( )% ' c) {'
//	[#		<{\n#		}{%CS=common key}%f_to_java(%CN_arg)_ = c.%f_to_java(%CN_arg)_;>][{%S%f_use_for_multi_factory()=true}
   %IF-NOT-EMPTY
    out_indent '		'
    %FOR %ITEM-SEPARATOR #13#10
     out_indent '		' ; // %ITEM-SEPARATOR 
     %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
     [%f] to_java %( %C |N '_arg' )% '_ = c.'
     [%f] to_java %( %C |N '_arg' )% '_;' 
    %END-FOR
   %END-IF
   %IF ( ( %S %f use_for_multi_factory %( )% ) %==  true ) 

//	#		keyArg_ = c.keyArg_;]
    out_indent '		keyArg_ = c.keyArg_;' 
   %END-IF
//	#	}
   out_indent '	' 
  %THEN

//	

//	#	public %S%f_factory_mem_key_name() (
  out_indent '	public '
  %S %f factory_mem_key_name %( )% ' ('
//	#		<{, }{%CS=common key}%t_arg(%C%T,"in") %f_to_java(%CN)>
  out_indent '		'
  %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
   %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
   [%t] arg %( %C ->T  %, 'in' )% ' '
   [%f] to_java %( %C |N )% 
  %END-FOR
//	#	) {
  out_indent '	) {'
//	[#		<{\n#		}{%CS=common key}%f_to_java(%CN_arg)_ = %f_to_java(%CN);>]
  %IF-NOT-EMPTY
   out_indent '		'
   %FOR %ITEM-SEPARATOR #13#10
    out_indent '		' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
    [%f] to_java %( %C |N '_arg' )% '_ = '
    [%f] to_java %( %C |N )% ';' 
   %END-FOR
  %END-IF
//	#	}
  out_indent '	}'
//	

//	#	public %S%f_factory_mem_key_name() () {
  out_indent '	public '
  %S %f factory_mem_key_name %( )% ' () {'
//	#	}
  out_indent '	}'
//	

//	[{%S%f_use_for_multi_factory()=true}#	protected %P%f_dump_switch_type() keyArg_;
  %IF ( ( %S %f use_for_multi_factory %( )% ) %==  true ) 
   out_indent '	protected '
   %P %f dump_switch_type %( )% ' keyArg_;'
//	]
  %END-IF
//	#}
  out_indent '}'
//	}%f_collect_factory_for_mem(%S,"false")\
  '}'
  [%f] collect_factory_for_mem %( %S %, false )% 
//	%f_pop_first_to_var(FACTORY_FOR_MEM,FACTORY)\
  [%f] pop_first_to_var %( 'FACTORY_FOR_MEM' %, 'FACTORY' )% 
//	#public static class %S%f_factory_mem_key_name() {
  out_indent 'public static class '
  %S %f factory_mem_key_name %( )% ' {'
//	%{FACTORY}<{}{"%CS"!="nokey"}#	[{%f_check_if_type(%C%T,"string")=false}{public String %CNArg_;}public %t_attr(%C%T,"agr") %f_to_java(%CN_arg)_;]
  ( get_global_var ( 'FACTORY' ) ) 
  %FOR %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
   out_indent '	'
   %IF ( ( [%f] check_if_type %( %C ->T  %, 'string' )% ) %==  false ) 
    %ELSE
     'public String '
     %C |N 'Arg_;' 
    %THEN
    'public '
    [%t] attr %( %C ->T  %, 'agr' )% ' '
    [%f] to_java %( %C |N '_arg' )% '_;' 
   %END-IF
//	>
  %END-FOR
//	#	public %S%f_factory_mem_key_name() (final %S%f_factory_mem_key_name() c) {
  out_indent '	public '
  %S %f factory_mem_key_name %( )% ' (final '
  %S %f factory_mem_key_name %( )% ' c) {'
//	[#		%{FACTORY}<{\n#		}{"%CS"!="nokey"}%f_to_java(%CN_arg)_ = c.%f_to_java(%CN_arg)_;>][{%S%f_use_for_multi_factory()=true}
  %IF-NOT-EMPTY
   out_indent '		'
   ( get_global_var ( 'FACTORY' ) ) 
   %FOR %ITEM-SEPARATOR #13#10
    out_indent '		' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
    [%f] to_java %( %C |N '_arg' )% '_ = c.'
    [%f] to_java %( %C |N '_arg' )% '_;' 
   %END-FOR
  %END-IF
  %IF ( ( %S %f use_for_multi_factory %( )% ) %==  true ) 

//	#		keyArg_ = c.keyArg_;]
   out_indent '		keyArg_ = c.keyArg_;' 
  %END-IF
//	#	}
  out_indent '	}'
//	

//	#	public %S%f_factory_mem_key_name() (%{FACTORY}<{, }{"%CS"!="nokey"}%f_arg_full_decl(%C)>) {
  out_indent '	public '
  %S %f factory_mem_key_name %( )% ' ('
  ( get_global_var ( 'FACTORY' ) ) 
  %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
   %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
   [%f] arg_full_decl %( %C )% 
  %END-FOR
  ') {'
//	[#		%{FACTORY}<{\n#		}{"%CS"!="nokey"}%f_to_java(%CN_arg)_ = %f_to_java(%CN);>]
  %IF-NOT-EMPTY
   out_indent '		'
   ( get_global_var ( 'FACTORY' ) ) 
   %FOR %ITEM-SEPARATOR #13#10
    out_indent '		' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
    [%f] to_java %( %C |N '_arg' )% '_ = '
    [%f] to_java %( %C |N )% ';' 
   %END-FOR
  %END-IF
//	#	}
  out_indent '	}'
//	

//	#	public %S%f_factory_mem_key_name() () {
  out_indent '	public '
  %S %f factory_mem_key_name %( )% ' () {'
//	#	}
  out_indent '	}'
//	

//	[{%S%f_use_for_multi_factory()=true}#	protected %P%f_dump_switch_type() keyArg_;
  %IF ( ( %S %f use_for_multi_factory %( )% ) %==  true ) 
   out_indent '	protected '
   %P %f dump_switch_type %( )% ' keyArg_;'
//	]
  %END-IF
//	#}]
  out_indent '}' 
 %END-IF
//	
//	#[{%Pa=abstract}public ]static class %S%f_factory_mem_key_name()Comparator implements java.util.Comparator\<%S%f_factory_mem_key_name()\> {
 out_indent %IF ( ( %P |a ) %== 'abstract' ) 
  'public ' 
 %END-IF
 'static class '
 %S %f factory_mem_key_name %( )% 'Comparator implements java.util.Comparator<'
 %S %f factory_mem_key_name %( )% '> {'
//	#	public int compare (final %S%f_factory_mem_key_name() a, final %S%f_factory_mem_key_name() b) {
 out_indent '	public int compare (final '
 %S %f factory_mem_key_name %( )% ' a, final '
 %S %f factory_mem_key_name %( )% ' b) {'
//	[{<{}{%CS=common key}{%CC}>=0}{\
 %IF ( 
  %FOR %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
   ( %C |C ) 
  %END-FOR
  %== 0 ) 
  %ELSE
//	<{}{%CS=common key}#		int %f_to_java(a_%CN_arg_hash) = %t_to_object_type(%C,"a.%f_to_java(%CN_arg)_").hashCode ();
   %FOR %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
    out_indent '		int '
    [%f] to_java %( 'a_'
    %C |N '_arg_hash' )% ' = '
    [%t] to_object_type %( %C %, 'a.'
    [%f] to_java %( %C |N '_arg' )% '_' )% '.hashCode ();'
//	#		int %f_to_java(b_%CN_arg_hash) = %t_to_object_type(%C,"b.%f_to_java(%CN_arg)_").hashCode ();
    out_indent '		int '
    [%f] to_java %( 'b_'
    %C |N '_arg_hash' )% ' = '
    [%t] to_object_type %( %C %, 'b.'
    [%f] to_java %( %C |N '_arg' )% '_' )% '.hashCode ();'
//	#		if (%f_to_java(a_%CN_arg_hash) \< %f_to_java(b_%CN_arg_hash)) {
    out_indent '		if ('
    [%f] to_java %( 'a_'
    %C |N '_arg_hash' )% ' < '
    [%f] to_java %( 'b_'
    %C |N '_arg_hash' )% ') {'
//	#			return 1;
    out_indent '			return 1;'
//	#		} else if (%f_to_java(a_%CN_arg_hash) \> %f_to_java(b_%CN_arg_hash)) {
    out_indent '		} else if ('
    [%f] to_java %( 'a_'
    %C |N '_arg_hash' )% ' > '
    [%f] to_java %( 'b_'
    %C |N '_arg_hash' )% ') {'
//	#			return -1;
    out_indent '			return -1;'
//	#		}
    out_indent '		}'
//	>}\
   %END-FOR
  %THEN
//	%{FACTORY}<{}{"%CS"!="nokey"}#		int %f_to_java(a_%CN_arg_hash) = %t_to_object_type(%C,"a.%f_to_java(%CN_arg)_").hashCode ();
  ( get_global_var ( 'FACTORY' ) ) 
  %FOR %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
   out_indent '		int '
   [%f] to_java %( 'a_'
   %C |N '_arg_hash' )% ' = '
   [%t] to_object_type %( %C %, 'a.'
   [%f] to_java %( %C |N '_arg' )% '_' )% '.hashCode ();'
//	#		int %f_to_java(b_%CN_arg_hash) = %t_to_object_type(%C,"b.%f_to_java(%CN_arg)_").hashCode ();
   out_indent '		int '
   [%f] to_java %( 'b_'
   %C |N '_arg_hash' )% ' = '
   [%t] to_object_type %( %C %, 'b.'
   [%f] to_java %( %C |N '_arg' )% '_' )% '.hashCode ();'
//	#		if (%f_to_java(a_%CN_arg_hash) \< %f_to_java(b_%CN_arg_hash)) {
   out_indent '		if ('
   [%f] to_java %( 'a_'
   %C |N '_arg_hash' )% ' < '
   [%f] to_java %( 'b_'
   %C |N '_arg_hash' )% ') {'
//	#			return 1;
   out_indent '			return 1;'
//	#		} else if (%f_to_java(a_%CN_arg_hash) \> %f_to_java(b_%CN_arg_hash)) {
   out_indent '		} else if ('
   [%f] to_java %( 'a_'
   %C |N '_arg_hash' )% ' > '
   [%f] to_java %( 'b_'
   %C |N '_arg_hash' )% ') {'
//	#			return -1;
   out_indent '			return -1;'
//	#		}
   out_indent '		}'
//	>][{%S%f_use_for_multi_factory()=true}
  %END-FOR
 %END-IF
 %IF ( ( %S %f use_for_multi_factory %( )% ) %==  true ) 

//	#		if (a.keyArg_.hashCode () \< b.keyArg_.hashCode ()) {
  out_indent '		if (a.keyArg_.hashCode () < b.keyArg_.hashCode ()) {'
//	#			return 1;
  out_indent '			return 1;'
//	#		} else if (a.keyArg_.hashCode () \> b.keyArg_.hashCode ()) {
  out_indent '		} else if (a.keyArg_.hashCode () > b.keyArg_.hashCode ()) {'
//	#			return -1;
  out_indent '			return -1;'
//	#		}]
  out_indent '		}' 
 %END-IF
//	#		return 0;
 out_indent '		return 0;'
//	#	]
 out_indent '	]'
//	#	}
 out_indent '	}'
//	#}
 out_indent '}'

//f _dump_factory_mem_key_cpp
; // dump_factory_mem_key_java

: dump_factory_mem_key_cpp OBJECT IN %S
//	[{<{}{%CS=common key}{%CC}>=0}{\
 %IF ( 
  %FOR %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
   ( %C |C ) 
  %END-FOR
  %== 0 ) 
  %ELSE
//	#struct %S%f_factory_mem_key_name() {
   out_indent 'struct '
   %S %f factory_mem_key_name %( )% ' {'
//	<{}{%CS=common key}{%C}#	[{%f_check_if_type(%C%T,"string")=false}{std::string %CN_arg;}%t_attr(%C%T,"agr") %CN_arg;]
   %FOR %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
    ( %C ) 
    out_indent '	'
    %IF ( ( [%f] check_if_type %( %C ->T  %, 'string' )% ) %==  false ) 
     %ELSE
      'std::string '
      %C |N '_arg;' 
     %THEN
     [%t] attr %( %C ->T  %, 'agr' )% ' '
     %C |N '_arg;' 
    %END-IF
//	>
   %END-FOR
//	

//	#	%S%f_factory_mem_key_name() (const %S%f_factory_mem_key_name()& c)
   out_indent '	'
   %S %f factory_mem_key_name %( )% ' (const '
   %S %f factory_mem_key_name %( )% '& c)'
//	[#		: <{\n#		, }{%CS=common key}%CN_arg (c.%CN_arg)>[{%S%f_use_for_multi_factory()=true}\n#		, key_arg (c.key_arg)]]
   %IF-NOT-EMPTY
    out_indent '		: '
    %FOR %ITEM-SEPARATOR #13#10
     out_indent '		, ' ; // %ITEM-SEPARATOR 
     %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
     %C |N '_arg (c.'
     %C |N '_arg)' 
    %END-FOR
    %IF ( ( %S %f use_for_multi_factory %( )% ) %==  true ) 
     #13#10
     out_indent '		, key_arg (c.key_arg)' 
    %END-IF
   %END-IF
//	#	{
   out_indent '	{'
//	#	}
   out_indent '	' 
  %THEN

//	

//	#	%S%f_factory_mem_key_name() (<{, }{%CS=common key}%t_arg(%C%T,"in") %CN>)
  out_indent '	'
  %S %f factory_mem_key_name %( )% ' ('
  %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
   %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
   [%t] arg %( %C ->T  %, 'in' )% ' '
   %C |N 
  %END-FOR
  ')'
//	[#		 : <{, }{%CS=common key}%CN_arg (%CN)>]
  %IF-NOT-EMPTY
   out_indent '		 : '
   %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
    %C |N '_arg ('
    %C |N ')' 
   %END-FOR
  %END-IF
//	#	{
  out_indent '	{'
//	#	}
  out_indent '	}'
//	

//	#	%S%f_factory_mem_key_name() () {
  out_indent '	'
  %S %f factory_mem_key_name %( )% ' () {'
//	#	}
  out_indent '	}'
//	

//	#	bool operator \< (const %S%f_factory_mem_key_name()& c) const {
  out_indent '	bool operator < (const '
  %S %f factory_mem_key_name %( )% '& c) const {'
//	#		return [{}{false}<{ ? true : }{%CS=common key}%CN_arg \< c.%CN_arg>[{%S%f_use_for_multi_factory()=true}[{%f_have_nokey_params(%{FACTORY})=true} ? true : ]key_arg \< c.key_arg]];
  out_indent '		return '
  %IF ( ) 
   %ELSE
     false 
   %THEN
   %FOR %ITEM-SEPARATOR ' ? true : ' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
    %C |N '_arg < c.'
    %C |N '_arg' 
   %END-FOR
   %IF ( ( %S %f use_for_multi_factory %( )% ) %==  true ) 
    %IF ( ( [%f] have_nokey_params %( ( get_global_var ( 'FACTORY' ) ) )% ) %==  true ) 
     ' ? true : ' 
    %END-IF
    'key_arg < c.key_arg' 
   %END-IF
  %END-IF
  ';'
//	#	}
  out_indent '	}'
//	[{%S%f_use_for_multi_factory()=true}
  %IF ( ( %S %f use_for_multi_factory %( )% ) %==  true ) 

//	#private:
   out_indent 'private:'
//	#	friend class %PNFactoryManager;
   out_indent '	friend class '
   %P |N 'FactoryManager;'
//	#	%P%f_dump_switch_type() key_arg;]
   out_indent '	'
   %P %f dump_switch_type %( )% ' key_arg;' 
  %END-IF
//	#};
  out_indent '};'
//	}%f_collect_factory_for_mem(%S,"false")\
  '}'
  [%f] collect_factory_for_mem %( %S %, false )% 
//	%f_pop_first_to_var(FACTORY_FOR_MEM,FACTORY)\
  [%f] pop_first_to_var %( 'FACTORY_FOR_MEM' %, 'FACTORY' )% 
//	#struct %S%f_factory_mem_key_name() {
  out_indent 'struct '
  %S %f factory_mem_key_name %( )% ' {'
//	[{"%{FACTORY}U"!=""}%{FACTORY}<{}{"%CS"!="nokey"}#	[{%f_check_if_type(%C%T,"string")=false}{std::string %CN_arg;}%t_attr(%C%T,"agr") %CN_arg;]
  %IF ( ( ( get_global_var ( 'FACTORY' ) |U ) ) %!= '' ) 
   ( get_global_var ( 'FACTORY' ) ) 
   %FOR %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
    out_indent '	'
    %IF ( ( [%f] check_if_type %( %C ->T  %, 'string' )% ) %==  false ) 
     %ELSE
      'std::string '
      %C |N '_arg;' 
     %THEN
     [%t] attr %( %C ->T  %, 'agr' )% ' '
     %C |N '_arg;' 
    %END-IF
//	>
   %END-FOR
//	#	%S%f_factory_mem_key_name() (const %f_to_borland(%SNKeyID)& c)[
   out_indent '	'
   %S %f factory_mem_key_name %( )% ' (const '
   [%f] to_borland %( %S |N 'KeyID' )% '& c)'
   %IF-NOT-EMPTY

//	#		: %{FACTORY}<{\n#		, }{"%CS"!="nokey"}%CN_arg (c.%CN_arg>)[{%S%f_use_for_multi_factory()=true}\n#		, key_arg (c.key_arg)]]
    out_indent '		: '
    ( get_global_var ( 'FACTORY' ) ) 
    %FOR %ITEM-SEPARATOR #13#10
     out_indent '		, ' ; // %ITEM-SEPARATOR 
     %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
     %C |N '_arg (c.'
     %C |N '_arg' 
    %END-FOR
    ')'
    %IF ( ( %S %f use_for_multi_factory %( )% ) %==  true ) 
     #13#10
     out_indent '		, key_arg (c.key_arg)' 
    %END-IF
   %END-IF
//	#	{
   out_indent '	{'
//	#	}
   out_indent '	}'
//	

//	#	%S%f_factory_mem_key_name() (%{FACTORY}<{, }{"%CS"!="nokey"}%f_arg_full_decl(%C)>)[
   out_indent '	'
   %S %f factory_mem_key_name %( )% ' ('
   ( get_global_var ( 'FACTORY' ) ) 
   %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
    [%f] arg_full_decl %( %C )% 
   %END-FOR
   ')'
   %IF-NOT-EMPTY

//	#		 : %{FACTORY}<{, }{"%CS"!="nokey"}%CN_arg (%CN)>]
    out_indent '		 : '
    ( get_global_var ( 'FACTORY' ) ) 
    %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
     %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
     %C |N '_arg ('
     %C |N ')' 
    %END-FOR
   %END-IF
//	#	{
   out_indent '	{'
//	#	}
   out_indent '	}'
//	

//	#	%S%f_factory_mem_key_name() () {
   out_indent '	'
   %S %f factory_mem_key_name %( )% ' () {'
//	#	}
   out_indent '	}'
//	

//	]#	bool operator \< (const %S%f_factory_mem_key_name()& c) const {
  %END-IF
  out_indent '	bool operator < (const '
  %S %f factory_mem_key_name %( )% '& c) const {'
//	#		return [{}{true}%{FACTORY}<{ ? true : }{"%CS"!="nokey"}%CN_arg \< c.%CN_arg>[{%S%f_use_for_multi_factory()=true}[{%f_have_nokey_params(%{FACTORY})=true} ? true : ]key_arg \< c.key_arg]];
  out_indent '		return '
  %IF ( ) 
   %ELSE
     true 
   %THEN
   ( get_global_var ( 'FACTORY' ) ) 
   %FOR %ITEM-SEPARATOR ' ? true : ' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
    %C |N '_arg < c.'
    %C |N '_arg' 
   %END-FOR
   %IF ( ( %S %f use_for_multi_factory %( )% ) %==  true ) 
    %IF ( ( [%f] have_nokey_params %( ( get_global_var ( 'FACTORY' ) ) )% ) %==  true ) 
     ' ? true : ' 
    %END-IF
    'key_arg < c.key_arg' 
   %END-IF
  %END-IF
  ';'
//	#	}
  out_indent '	}'
//	[{%S%f_use_for_multi_factory()=true}
  %IF ( ( %S %f use_for_multi_factory %( )% ) %==  true ) 

//	

//	#private:
   out_indent 'private:'
//	#	friend class %PNFactoryManager;
   out_indent '	friend class '
   %P |N 'FactoryManager;'
//	#	%P%f_dump_switch_type() key_arg;
   out_indent '	'
   %P %f dump_switch_type %( )% ' key_arg;'
//	]
  %END-IF
//	#};]
  out_indent '};' 
 %END-IF

//f _have_nokey_params
; // dump_factory_mem_key_cpp

: have_nokey_params OBJECT IN %S
//	[{<{}{"%CS"!="nokey"}{%CC}>=0}{true}false]
 %IF ( 
  %FOR %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
   ( %C |C ) 
  %END-FOR
  %== 0 ) 
  %ELSE
    true 
  %THEN
   false 
 %END-IF

//собираем фабрики используещие данную "память" в список
//в качестве второго параметра функции передаём флаг нужно ли "собирать" фабрики без параметров
//f _collect_factory_for_mem
; // have_nokey_params

: collect_factory_for_mem OBJECT IN %S
//	%f_set_var(SELF,S)\
 [%f] set_var %( 'SELF' %, 'S' )% 
//	%f_clear_list(FACTORY_FOR_MEM)\
 [%f] clear_list %( 'FACTORY_FOR_MEM' )% 
//	%f_set_var(ARG,1)\
 [%f] set_var %( 'ARG' %, 1 )% 
//	%P<{}{%f_is_factory(%C)=true}{%C}[{%C%TU=%{SELF}U&%f_exists_in_list(FACTORY_FOR_MEM,C)=false}[{%{ARG}N=true|%C<{}{"%CS"!="nokey"}{C}>!=0}%f_add_to_list(FACTORY_FOR_MEM,C)]\
 %P
 %FOR %ITEM-CONDITION ( ( [%f] is_factory %( %C )% ) %==  true ) 
  ( %C ) 
  %IF ( ( %C ->T |U  ) %== ( ( get_global_var ( 'SELF' ) |U ) ) %&& 
    ( ( [%f] exists_in_list %( 'FACTORY_FOR_MEM' %, 'C' )% ) %==  false  ) ) 
   %IF ( ( ( get_global_var ( 'ARG' ) |N ) ) %==  true %|| 
     ( ( %C
    %FOR %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
     ( 'C' ) 
    %END-FOR
 )     %!= 0  ) ) 
    [%f] add_to_list %( 'FACTORY_FOR_MEM' %, 'C' )% 
   %END-IF
//	]>%P<{}{"%ga"="abstract"}%g<{}{%f_is_factory(%C)=true}{%C}[{%C%TU=%{SELF}U&%f_exists_in_list(FACTORY_FOR_MEM,C)=false}[%{ARG}N=true|%C<{}{"%CS"!="nokey"}{C}>!=0}%f_add_to_list(FACTORY_FOR_MEM,C)]\
  %END-IF
 %END-FOR
  %P
 %FOR %ITEM-CONDITION ( ( %g |a ) %== 'abstract' ) 
  %g
  %FOR %ITEM-CONDITION ( ( [%f] is_factory %( %C )% ) %==  true ) 
   ( %C ) 
   %IF ( ( %C ->T |U  ) %== ( ( get_global_var ( 'SELF' ) |U ) ) %&& 
     ( ( [%f] exists_in_list %( 'FACTORY_FOR_MEM' %, 'C' )% ) %==  false  ) ) 
    %IF-NOT-EMPTY
     ( get_global_var ( 'ARG' ) |N ) '=true|'
     %C
     %FOR %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
      ( 'C' ) 
     %END-FOR
      '!=0}'
     [%f] add_to_list %( 'FACTORY_FOR_MEM' %, 'C' )% 
    %END-IF
//	]>>
   %END-IF
  %END-FOR
  %END-FOR
 
//выводит список параметров, которые используются для идентификации
//объектов в данной общей пямяти
//%f _dump_factory_mem_params
; // collect_factory_for_mem

implementation @ <<FactoryMemory>>
: dump_factory_mem_params OBJECT IN %S
//	[{<{}{%CS=common key}(%CC)>=0}{<{, }{%CS=common key}%t_arg(%C%T,"in") %CN>}\
 %IF ( 
  %FOR %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
   '('
   %C |C ')' 
  %END-FOR
  %== 0 ) 
  %ELSE
   %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
    [%t] arg %( %C ->T  %, 'in' )% ' '
    %C |N 
   %END-FOR
  %THEN
//	%f_collect_factory_for_mem(%S,"false")\
  [%f] collect_factory_for_mem %( %S %, false )% 
//	%f_pop_first_to_var(FACTORY_FOR_MEM,FACTORY)\
  [%f] pop_first_to_var %( 'FACTORY_FOR_MEM' %, 'FACTORY' )% 
//	%{FACTORY}<{, }{%CS!=no key}%f_arg(%C) %CN>]
  ( get_global_var ( 'FACTORY' ) ) 
  %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
   %ITEM-CONDITION ( ( %C |S ) %!= 'no key' ) 
   [%f] arg %( %C )% ' '
   %C |N 
  %END-FOR
 %END-IF
//	[{%TS=FactoryMemory&<{}{%CS=no key}{%CC}>!=0&%T<{}{%CS=common key}(%CC)>!=0}\
//	%T<{, }{%CS=common key}%t_attr(%C%T,"in") %CN><{}{%CS!=no key}, %t_attr(%C%T,"in") %CN>]
//#UC END# *4753E98D0058for4753C0BC029E*
; // dump_factory_mem_params


// Выводит имя ключа для идентификации объектов в общей памяти
//%f _factory_mem_key_name
: factory_mem_key_name OBJECT IN %S
//#UC START# *4754F69C0002for4753C0BC029E*
//	%f_to_borland(%SNKeyID)
 [%f] to_borland %( %S |N 'KeyID' )% 

//#UC END# *4754F69C0002for4753C0BC029E*
; // factory_mem_key_name


// Выводит имя трансформатора параметров фабрик, использующих данную общую память, в ключ
// идентификации
//%f _transfomator_name
: transfomator_name OBJECT IN %S
//#UC START# *4754F6DC0169for4753C0BC029E*
//	%PN%SNTransformator
 %P |N %S |N 'Transformator'
//#UC END# *4754F6DC0169for4753C0BC029E*
; // transfomator_name


// Используется ли данная общая память в мульти-фабрике.
//%f _use_for_multi_factory
: use_for_multi_factory OBJECT IN %S
//#UC START# *47577D78020Efor4753C0BC029E*
//	%f_collect_factory_for_mem(%S,"true")\
 [%f] collect_factory_for_mem %( %S %, true )% 
//	[{"<{}{%f_is_empty(FACTORY_FOR_MEM)=false}{W}%f_pop_first_to_var(FACTORY_FOR_MEM,CYCLE_ITEM)[{%{CYCLE_ITEM}S=multi factory}%{CYCLE_ITEM}N]>"=""}{true}false]
 %IF ( 
  %FOR %ITEM-CONDITION ( ( [%f] is_empty %( 'FACTORY_FOR_MEM' )% ) %==  false ) 
   ( 'W' ) 
   [%f] pop_first_to_var %( 'FACTORY_FOR_MEM' %, 'CYCLE_ITEM' )% %IF ( ( ( get_global_var ( 'CYCLE_ITEM' ) |S ) ) %== 'multi factory' ) 
    ( get_global_var ( 'CYCLE_ITEM' ) |N ) 
   %END-IF
  %END-FOR
  %== '' ) 
  %ELSE
    true 
  %THEN
   false 
 %END-IF
//#UC END# *47577D78020Efor4753C0BC029E*
; // use_for_multi_factory


// используется ли данная общая память в синхро-фабриках
//%f _use_for_synchro_factory
: use_for_synchro_factory OBJECT IN %S
//#UC START# *47722E760365for4753C0BC029E*
//	%f_collect_factory_for_mem(%S,"true")\
 [%f] collect_factory_for_mem %( %S %, true )% 
//	%f_set_var(USE_IN_SYNCHRO,"false")\
 [%f] set_var %( 'USE_IN_SYNCHRO' %, false )% 
//	<{}{%f_is_empty(FACTORY_FOR_MEM)=false}{W}%f_pop_first_to_var(FACTORY_FOR_MEM,CYCLE_ITEM)[{%{CYCLE_ITEM}s=synchro}%f_set_var(USE_IN_SYNCHRO,"true")]>\
 %FOR %ITEM-CONDITION ( ( [%f] is_empty %( 'FACTORY_FOR_MEM' )% ) %==  false ) 
  ( 'W' ) 
  [%f] pop_first_to_var %( 'FACTORY_FOR_MEM' %, 'CYCLE_ITEM' )% %IF ( ( ( get_global_var ( 'CYCLE_ITEM' ) |s ) ) %== 'synchro' ) 
   [%f] set_var %( 'USE_IN_SYNCHRO' %, true )% 
  %END-IF
 %END-FOR
//	%{USE_IN_SYNCHRO}N
 ( get_global_var ( 'USE_IN_SYNCHRO' ) |N ) 
//#UC END# *47722E760365for4753C0BC029E*
; // use_for_synchro_factory


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for4753C0BC029E*
//c                                                                {}
//r {<{}{%CS=common key}{%CC}>!=0&<{}{%CS=common key}{%CC}>!=1}:  {%SS может иметь не более одного ключа}
//r "%f_check_equal_factory_parameters(%S)"!="":                   {Фабрики использующие %SS (%SN) в качестве общей памяти должны иметь одниковый список ключевых параметров \<%f_check_equal_factory_parameters(%S)\>}
//r {%f_check_non_empty_factory_list(%S)=false}:                   {Должна быть хотя бы одна НЕ создающая фабрика, использующая данную общую память}
//r {%f_check_synchro_use(%S)=false}:                              {Общая память, используемая в синхро-фабриках, не может использоваться в других типах фабрик}

//проверяем, что фабрики использующие общий кэш определяют один набор параметров
//f _check_equal_factory_parameters
; // constraint

end. // <<FactoryMemory>>

: check_equal_factory_parameters OBJECT IN %S
//	[{<{}{%CS=common key}{%CC}>=0}%f_collect_factory_for_mem(%S,"false")%f_set_var(FACTORY_ARG_STR,"")\
 %IF ( 
  %FOR %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
   ( %C |C ) 
  %END-FOR
  %== 0 ) 
  [%f] collect_factory_for_mem %( %S %, false )% [%f] set_var %( 'FACTORY_ARG_STR' %, '' )% 
//	<{}{%f_is_empty(FACTORY_FOR_MEM)=false}{W}%f_pop_first_to_var(FACTORY_FOR_MEM,CYCLE_ITEM)\
  %FOR %ITEM-CONDITION ( ( [%f] is_empty %( 'FACTORY_FOR_MEM' )% ) %==  false ) 
   ( 'W' ) 
   [%f] pop_first_to_var %( 'FACTORY_FOR_MEM' %, 'CYCLE_ITEM' )% 
//	[{%{CYCLE_ITEM}%Cx=true}[{"%{FACTORY_ARG_STR}N"=""}{[{"%{FACTORY_ARG_STR}N"!="%f_dump_args(%{CYCLE_ITEM})"}%{CYCLE_ITEM}N, ]}\
   %IF ( ( ( get_global_var ( 'CYCLE_ITEM' )  ->C |x ) ) %==  true ) 
    %IF ( ( ( get_global_var ( 'FACTORY_ARG_STR' ) |N ) ) %== '' ) 
     %ELSE
      %IF ( ( ( get_global_var ( 'FACTORY_ARG_STR' ) |N ) ) %!= ( [%f] dump_args %( ( get_global_var ( 'CYCLE_ITEM' ) ) )% ) ) 
       ( get_global_var ( 'CYCLE_ITEM' ) |N ) ', ' 
      %END-IF
     %THEN
//	%f_set_var(FACTORY_ARG_STR,"%f_dump_args(%{CYCLE_ITEM})")]]>%f_set_var(FACTORY_ARG_STR,"")]
     [%f] set_var %( 'FACTORY_ARG_STR' %, [%f] dump_args %( ( get_global_var ( 'CYCLE_ITEM' ) ) )% )% 
    %END-IF
   %END-IF
  %END-FOR
  [%f] set_var %( 'FACTORY_ARG_STR' %, '' )% 
 %END-IF

//f _dump_args
; // check_equal_factory_parameters

: dump_args OBJECT IN %S
//	<{}{%CS!=nokey}{%C}%C%TU>
 %FOR %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
  ( %C ) 
  %C ->T |U  
 %END-FOR

//проверяем, что есть хотя бы одна НЕ создающая фабрика использующия данную общую память
//f _check_non_empty_factory_list
; // dump_args

: check_non_empty_factory_list OBJECT IN %S
//	%f_collect_factory_for_mem(%S,"false")\
 [%f] collect_factory_for_mem %( %S %, false )% 
//	[{%f_is_empty(FACTORY_FOR_MEM)=false}{false}true]
 %IF ( ( [%f] is_empty %( 'FACTORY_FOR_MEM' )% ) %==  false ) 
  %ELSE
    false 
  %THEN
   true 
 %END-IF

//проверяем, что если общая память используется для синхро-фабрик, то
//она не может использоваться для других типов фабрик
//f _check_synchro_use
; // check_non_empty_factory_list

: check_synchro_use OBJECT IN %S
//	%f_collect_factory_for_mem(%S,"true")\
 [%f] collect_factory_for_mem %( %S %, true )% 
//	%f_set_var(USE_IN_SYNCHRO,"false")\
 [%f] set_var %( 'USE_IN_SYNCHRO' %, false )% 
//	%f_set_var(USE_IN_NOT_SYNCHRO,"false")\
 [%f] set_var %( 'USE_IN_NOT_SYNCHRO' %, false )% 
//	<{}{%f_is_empty(FACTORY_FOR_MEM)=false}{W}%f_pop_first_to_var(FACTORY_FOR_MEM,CYCLE_ITEM)\
 %FOR %ITEM-CONDITION ( ( [%f] is_empty %( 'FACTORY_FOR_MEM' )% ) %==  false ) 
  ( 'W' ) 
  [%f] pop_first_to_var %( 'FACTORY_FOR_MEM' %, 'CYCLE_ITEM' )% 
//	[{%{CYCLE_ITEM}s=synchro}{%f_set_var(USE_IN_NOT_SYNCHRO,"true")}%f_set_var(USE_IN_SYNCHRO,"true")]>\
  %IF ( ( ( get_global_var ( 'CYCLE_ITEM' ) |s ) ) %== 'synchro' ) 
   %ELSE
    [%f] set_var %( 'USE_IN_NOT_SYNCHRO' %, true )% 
   %THEN
   [%f] set_var %( 'USE_IN_SYNCHRO' %, true )% 
  %END-IF
 %END-FOR
//	[{%f_is_correct_use(%S)=true}{false}true]
 %IF ( ( [%f] is_correct_use %( %S )% ) %==  true ) 
  %ELSE
    false 
  %THEN
   true 
 %END-IF

//f _is_correct_use
; // check_synchro_use

: is_correct_use OBJECT IN %S
//	[{%{USE_IN_SYNCHRO}N=true&%{USE_IN_NOT_SYNCHRO}N=true}{true}false]
 %IF ( ( ( get_global_var ( 'USE_IN_SYNCHRO' ) |N ) ) %==  true %&& 
   ( ( ( get_global_var ( 'USE_IN_NOT_SYNCHRO' ) |N ) ) %==  true  ) ) 
  %ELSE
    true 
  %THEN
   false 
 %END-IF
//#UC END# *4704C0E30186for4753C0BC029E*
; // is_correct_use


// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
implementation @ <<FactoryMemory>>
: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor4753C0BC029E*
//#UC END# *4705CBD6003Efor4753C0BC029E*
; // wiki_child_kind


// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
//%f _wiki_up_add_gen
: wiki_up_add_gen OBJECT IN %S
//#UC START# *470484D50138for4753C0BC029E*
//#UC END# *470484D50138for4753C0BC029E*
; // wiki_up_add_gen


// реализация абстрактного стереотипа C++ Фабрики::MDAGenerator
// генератор файлов реализации для фабрик интерфейсов (.cpp)
//+ fctr.cpp
<<generator>> fctr.cpp OBJECT IN %S
//#UC START# *4705C54B01F4for4753C0BC029E*
//	[{<{}{%CS=common key}{%CC}>!=0}%f_collect_factory_for_mem(%S)
 %IF ( 
  %FOR %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
   ( %C |C ) 
  %END-FOR
  %!= 0 ) 
  [%f] collect_factory_for_mem %( %S )% 
//	[<{}{%f_is_empty(FACTORY_FOR_MEM)=false}{W}%f_pop_first_to_var(FACTORY_FOR_MEM,CYCLE_ITEM)
  %IF-NOT-EMPTY
   %FOR %ITEM-CONDITION ( ( [%f] is_empty %( 'FACTORY_FOR_MEM' )% ) %==  false ) 
    ( 'W' ) 
    [%f] pop_first_to_var %( 'FACTORY_FOR_MEM' %, 'CYCLE_ITEM' )% 
//	%PNFactoryManager::%S%f_factory_mem_key_name() %PNFactoryManager::%S%f_transfomator_name()::%{CYCLE_ITEM}N_to_id (%{CYCLE_ITEM}<{, }{%CS!=nokey}%f_arg_full_decl(%C)>)
    %P |N 'FactoryManager::'
    %S %f factory_mem_key_name %( )% ' '
    %P |N 'FactoryManager::'
    %S %f transfomator_name %( )% '::'
    ( get_global_var ( 'CYCLE_ITEM' ) |N ) '_to_id ('
    ( get_global_var ( 'CYCLE_ITEM' ) ) 
    %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
     %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
     [%f] arg_full_decl %( %C )% 
    %END-FOR
    ')'
//		/*throw (Core::Root::ImpossibleConversion)*/
    '	/*throw (Core::Root::ImpossibleConversion)*/'
//	{
    '{'
//		%U[{FOR_%f_to_upper(%{CYCLE_ITEM}N_to_id)}
    '	'
    %U%IF ( 'FOR_( '
     [%f] to_upper %( ( get_global_var ( 'CYCLE_ITEM' ) |N ) '_to_id' )% ) ) 

//		throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);
     '	throw Core::Root::MDAGenNotImplemented(GDS_CURRENT_FUNCTION);'
//		]
     '	' 
    %END-IF
 //	}
    '}'
//	>
   %END-FOR
//	]]
  %END-IF
 %END-IF
//#UC END# *4705C54B01F4for4753C0BC029E*
; // fctr.cpp


// реализация абстрактного стереотипа C++ Фабрики::MDAGenerator
// генератор заголовочных файлов для фабрик интерфейсов (.h)
//+ fctr.h
<<generator>> fctr.h OBJECT IN %S
//#UC START# *4705C5490109for4753C0BC029E*
//	%f_set_var(COMMON_MEM,S)\
 [%f] set_var %( 'COMMON_MEM' %, 'S' )% 
//	
//	public:
 'public:'
//	
//	%S%f_dump_factory_mem_key()
 %S %f dump_factory_mem_key %( )% 
//	[{%Pa!=abstract}
 %IF ( ( %P |a ) %!= 'abstract' ) 

//	protected:
  'protected:'
//	%f_dump_common_mem_cache(%S)
  [%f] dump_common_mem_cache %( %S )% 
//	][{<{}{%CS=common key}{%CC}>!=0}%f_collect_factory_for_mem(%S)
 %END-IF
 %IF ( 
  %FOR %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
   ( %C |C ) 
  %END-FOR
  %!= 0 ) 
  [%f] collect_factory_for_mem %( %S )% 
//	#class %S%f_transfomator_name() {
  out_indent 'class '
  %S %f transfomator_name %( )% ' {'
//	[	public:
  %IF-NOT-EMPTY
   '	public:'
//	<{}{%f_is_empty(FACTORY_FOR_MEM)=false}{W}%f_pop_first_to_var(FACTORY_FOR_MEM,CYCLE_ITEM)
   %FOR %ITEM-CONDITION ( ( [%f] is_empty %( 'FACTORY_FOR_MEM' )% ) %==  false ) 
    ( 'W' ) 
    [%f] pop_first_to_var %( 'FACTORY_FOR_MEM' %, 'CYCLE_ITEM' )% 
//	#	static %S%f_factory_mem_key_name() %{CYCLE_ITEM}N_to_id (%{CYCLE_ITEM}<{, }{%CS!=nokey}%f_arg_full_decl(%C)>)
    out_indent '	static '
    %S %f factory_mem_key_name %( )% ' '
    ( get_global_var ( 'CYCLE_ITEM' ) |N ) '_to_id ('
    ( get_global_var ( 'CYCLE_ITEM' ) ) 
    %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
     %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
     [%f] arg_full_decl %( %C )% 
    %END-FOR
    ')'
//	#		/*throw (Core::Root::ImpossibleConversion)*/;
    out_indent '		/*throw (Core::Root::ImpossibleConversion)*/;'
//	>
   %END-FOR
//	#]\};]
   out_indent 
  %END-IF
  '};' 
 %END-IF
//	

//f _dump_common_mem_cache
; // fctr.h

end. // <<FactoryMemory>>

: dump_common_mem_cache OBJECT IN %S
//	#typedef std::map\<[%f_type(%P)FactoryManager::]%S%f_factory_mem_key_name(), [{%S%f_use_for_synchro_factory()=false}{%t_fctr_manager_cache_value(%{INT},"type","")}%t_fctr_manager_cache_value(%{INT},"var","")]\> %f_to_borland(%SNMap);
 out_indent 'typedef std::map<'
 %IF-NOT-EMPTY
  [%f] type %( %P )% 'FactoryManager::' 
 %END-IF
 %S %f factory_mem_key_name %( )% ', '
 %IF ( ( %S %f use_for_synchro_factory %( )% ) %==  false ) 
  %ELSE
   [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'type"' %, '' )% 
  %THEN
  [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'var"' %, '' )% 
 %END-IF
 '> '
 [%f] to_borland %( %S |N 'Map' )% ';'
//	#typedef std::map\<[{%f_is_server_type(%{INT})=false}{CORBA::ULong}const %f_type(%{INT})*], %f_to_borland(%SNMap)::iterator\> %f_to_borland(%SNIndexMap);
 out_indent 'typedef std::map<'
 %IF ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  false ) 
  %ELSE
   'CORBA::ULong' 
  %THEN
  'const '
  [%f] type %( ( get_global_var ( 'INT' ) ) )% '*' 
 %END-IF
 ', '
 [%f] to_borland %( %S |N 'Map' )% '::iterator> '
 [%f] to_borland %( %S |N 'IndexMap' )% ';'
//	#%f_to_borland(%SNMap) m_%f_to_omg(%SN);
 out_indent [%f] to_borland %( %S |N 'Map' )% ' m_'
 [%f] to_omg %( %S |N )% ';'
//	#%f_to_borland(%SNIndexMap) m_%f_to_omg(%SN)_index;
 out_indent [%f] to_borland %( %S |N 'IndexMap' )% ' m_'
 [%f] to_omg %( %S |N )% '_index;'
//	
//	#Core::Mutex m_mutex_for_%f_to_omg(%SN);
 out_indent 'Core::Mutex m_mutex_for_'
 [%f] to_omg %( %S |N )% ';'
//f _need_conversion_exception
; // dump_common_mem_cache

: need_conversion_exception OBJECT IN %S
//	[{%TS=FactoryMemory&%T<{}{%CS=common key}{%CC}>!=0&<{}{%CS!=nokey}{%CC}>!=0}true]
 %IF ( ( %T |S ) %== 'FactoryMemory' %&& 
   ( ( %T
  %FOR %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
   ( %C |C ) 
  %END-FOR
 )   %!= 0  ) %&& 
   ( 
  %FOR %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
   ( %C |C ) 
  %END-FOR
  %!= 0  ) ) 
   true 
 %END-IF
//#UC END# *4705C5490109for4753C0BC029E*
; // need_conversion_exception


// реализация абстрактного стереотипа C++ интерфейсы и реализация::MDAGenerator
// генератор файлов реализации C++ (.cpp)
//+ cpp
implementation @ <<FactoryMemory>>
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor4753C0BC029E*
//#UC END# *47022CB8034Bfor4753C0BC029E*
; // cpp


// реализация абстрактного стереотипа C++ интерфейсы и реализация::MDAGenerator
// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor4753C0BC029E*
//#UC END# *47022C88029Ffor4753C0BC029E*
; // h


// реализация абстрактного стереотипа C++ интерфейсы и реализация::MDAGenerator
// генератор inline файлов реализации C++ (.i.h)
//+ i.h
<<generator>> i.h OBJECT IN %S
//#UC START# *47022CCF00EAfor4753C0BC029E*
//#UC END# *47022CCF00EAfor4753C0BC029E*
; // i.h


// реализация абстрактного стереотипа CORBA IDL::MDAGenerator
// генератор idl спецификаций (.idl)
//+ idl
<<generator>> idl OBJECT IN %S
//#UC START# *47022BBE0261for4753C0BC029E*
//#UC END# *47022BBE0261for4753C0BC029E*
; // idl


// реализация абстрактного стереотипа CORBA IDL::MDAGenerator
// генератор idl спецификаций для AMI (.idl)
//+ idl_ami
<<generator>> idl_ami OBJECT IN %S
//#UC START# *47022C0F01E4for4753C0BC029E*
//#UC END# *47022C0F01E4for4753C0BC029E*
; // idl_ami


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Генератор файлов форм (.dfm)
//+ dfm
<<generator>> dfm OBJECT IN %S
//R  
//#UC START# *49F5795900ECfor4753C0BC029E*
//#UC END# *49F5795900ECfor4753C0BC029E*
; // dfm


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor4753C0BC029E*
//#UC END# *470F15B800CBfor4753C0BC029E*
; // impl.pas


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor4753C0BC029E*
//#UC END# *470F1571031Cfor4753C0BC029E*
; // intf.pas


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
//+ intf2.pas
<<generator>> intf2.pas OBJECT IN %S
//R  
//#UC START# *477398E501C0for4753C0BC029E*
//#UC END# *477398E501C0for4753C0BC029E*
; // intf2.pas


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// 3-я секция интерфейса. Например поле для свойства.
//+ intf3.pas
<<generator>> intf3.pas OBJECT IN %S
//R  
//#UC START# *4774D2A20372for4753C0BC029E*
//#UC END# *4774D2A20372for4753C0BC029E*
; // intf3.pas


// реализация абстрактного стереотипа Delphi интерфейсы и реализация::MDAGenerator
// Скрипты TC (.sd)
//+ sd
<<generator>> sd OBJECT IN %S
//R  
//#UC START# *4DE79AFC0030for4753C0BC029E*
//#UC END# *4DE79AFC0030for4753C0BC029E*
; // sd


// реализация абстрактного стереотипа Java::MDAGenerator
// генератор реализации фабрик интерфейсов на java (.java)
//+ fctr.java
<<generator>> fctr.java OBJECT IN %S
//#UC START# *470321C1038Afor4753C0BC029E*
//	%f_set_var(COMMON_MEM,S)\
 [%f] set_var %( 'COMMON_MEM' %, 'S' )% 
//	
//	%S%f_dump_factory_mem_key()
 %S %f dump_factory_mem_key %( )% 
//	[{%Pa!=abstract}
 %IF ( ( %P |a ) %!= 'abstract' ) 

//	%f_dump_common_mem_cache_java(%S)
  [%f] dump_common_mem_cache_java %( %S )% 
//	][{<{}{%CS=common key}{%CC}>!=0}%f_collect_factory_for_mem(%S)
 %END-IF
 %IF ( 
  %FOR %ITEM-CONDITION ( ( %C |S ) %== 'common key' ) 
   ( %C |C ) 
  %END-FOR
  %!= 0 ) 
  [%f] collect_factory_for_mem %( %S )% 
//	#public static class %S%f_transfomator_name() {
  out_indent 'public static class '
  %S %f transfomator_name %( )% ' {'
//	[<{}{%f_is_empty(FACTORY_FOR_MEM)=false}{W}%f_pop_first_to_var(FACTORY_FOR_MEM,CYCLE_ITEM)
  %IF-NOT-EMPTY
   %FOR %ITEM-CONDITION ( ( [%f] is_empty %( 'FACTORY_FOR_MEM' )% ) %==  false ) 
    ( 'W' ) 
    [%f] pop_first_to_var %( 'FACTORY_FOR_MEM' %, 'CYCLE_ITEM' )% 
//	#	public static %S%f_factory_mem_key_name() %f_to_java(%{CYCLE_ITEM}N_to_id) (%{CYCLE_ITEM}<{, }{%CS!=nokey}%f_arg_full_decl(%C)>)
    out_indent '	public static '
    %S %f factory_mem_key_name %( )% ' '
    [%f] to_java %( ( get_global_var ( 'CYCLE_ITEM' ) |N ) '_to_id' )% ' ('
    ( get_global_var ( 'CYCLE_ITEM' ) ) 
    %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
     %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
     [%f] arg_full_decl %( %C )% 
    %END-FOR
    ')'
//	#		throws ru.garant.shared.Core.Root.ImpossibleConversion
    out_indent '		throws ru.garant.shared.Core.Root.ImpossibleConversion'
//	#	{
    out_indent '	{'
//	#		%U[{FOR_%f_to_upper(%{CYCLE_ITEM}N_to_id)}
    out_indent '		'
    %U%IF ( 'FOR_( '
     [%f] to_upper %( ( get_global_var ( 'CYCLE_ITEM' ) |N ) '_to_id' )% ) ) 

//	#		throw new java.lang.RuntimeException ("Method \[%f_to_java(%{CYCLE_ITEM}N_to_id)\] not implemented");
     out_indent '		throw new java.lang.RuntimeException ("Method ['
     [%f] to_java %( ( get_global_var ( 'CYCLE_ITEM' ) |N ) '_to_id' )% '] not implemented");'
//	#		]
     out_indent '		' 
    %END-IF
 //	#	}
    out_indent '	}'
//	>
   %END-FOR
//	#]}]
   out_indent 
  %END-IF
  '}' 
 %END-IF

//f _dump_common_mem_cache_java
; // fctr.java

end. // <<FactoryMemory>>

: dump_common_mem_cache_java OBJECT IN %S
//	#private java.util.Map\<%S%f_factory_mem_key_name(), [{%S%f_use_for_synchro_factory()=false}{%t_fctr_manager_cache_value(%{INT},"type","")}%t_fctr_manager_cache_value(%{INT},"var","")]\> %f_to_java(%SNMap)_ = 
 out_indent 'private java.util.Map<'
 %S %f factory_mem_key_name %( )% ', '
 %IF ( ( %S %f use_for_synchro_factory %( )% ) %==  false ) 
  %ELSE
   [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'type"' %, '' )% 
  %THEN
  [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'var"' %, '' )% 
 %END-IF
 '> '
 [%f] to_java %( %S |N 'Map' )% '_ = '
//	#	new java.util.TreeMap\<%S%f_factory_mem_key_name(), [{%S%f_use_for_synchro_factory()=false}{%t_fctr_manager_cache_value(%{INT},"type","")}%t_fctr_manager_cache_value(%{INT},"var","")]\> (new %S%f_factory_mem_key_name()Comparator ());
 out_indent '	new java.util.TreeMap<'
 %S %f factory_mem_key_name %( )% ', '
 %IF ( ( %S %f use_for_synchro_factory %( )% ) %==  false ) 
  %ELSE
   [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'type"' %, '' )% 
  %THEN
  [%t] fctr_manager_cache_value %( ( get_global_var ( 'INT' ) ) %, 'var"' %, '' )% 
 %END-IF
 '> (new '
 %S %f factory_mem_key_name %( )% 'Comparator ());'
//	#private [{%f_is_server_type(%{INT})=false}{java.util.Map\<Integer, %S%f_factory_mem_key_name()\> %f_to_java(%SNIndexMap)_ = 
 out_indent 'private '
 %IF ( ( [%f] is_server_type %( ( get_global_var ( 'INT' ) ) )% ) %==  false ) 
  %ELSE
   'java.util.Map<Integer, '
   %S %f factory_mem_key_name %( )% '> '
   [%f] to_java %( %S |N 'IndexMap' )% '_ = '
//	#	new java.util.TreeMap\<Integer, %S%f_factory_mem_key_name()\> ();
   out_indent '	new java.util.TreeMap<Integer, '
   %S %f factory_mem_key_name %( )% '> ();'
//	}java.util.Map\<[{%S%f_use_for_synchro_factory()=false}{Integer}%f_var(%P)], %S%f_factory_mem_key_name()\> %f_to_java(%SNIndexMap)_ = 
  %THEN
  'java.util.Map<'
  %IF ( ( %S %f use_for_synchro_factory %( )% ) %==  false ) 
   %ELSE
    'Integer' 
   %THEN
   [%f] var %( %P )% 
  %END-IF
  ', '
  %S %f factory_mem_key_name %( )% '> '
  [%f] to_java %( %S |N 'IndexMap' )% '_ = '
//	#	new java.util.IdentityHashMap\<[{%S%f_use_for_synchro_factory()=false}{Integer}%f_var(%P)], %S%f_factory_mem_key_name()\> ();]
  out_indent '	new java.util.IdentityHashMap<'
  %IF ( ( %S %f use_for_synchro_factory %( )% ) %==  false ) 
   %ELSE
    'Integer' 
   %THEN
   [%f] var %( %P )% 
  %END-IF
  ', '
  %S %f factory_mem_key_name %( )% '> ();' 
 %END-IF
//#UC END# *470321C1038Afor4753C0BC029E*
; // dump_common_mem_cache_java


// реализация абстрактного стереотипа Java::MDAGenerator
// генератор классов, интерфейсов на java (.java)
//+ java
implementation @ <<FactoryMemory>>
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for4753C0BC029E*
//#UC END# *470321950119for4753C0BC029E*
; // java


// реализация абстрактного стереотипа Дельфи-DLL Адаптер::MDAGenerator
// С++ TIE-обвязка для DLL (_tie.cpp)
//+ dll.cpp
<<generator>> dll.cpp OBJECT IN %S
//#UC START# *47032ED002DEfor4753C0BC029E*
//#UC END# *47032ED002DEfor4753C0BC029E*
; // dll.cpp


// реализация абстрактного стереотипа Дельфи-DLL Адаптер::MDAGenerator
// С++ TIE-обвязка для DLL (_tie.h)
//+ dll.h
<<generator>> dll.h OBJECT IN %S
//#UC START# *47032EC4032Cfor4753C0BC029E*
//#UC END# *47032EC4032Cfor4753C0BC029E*
; // dll.h


// реализация абстрактного стереотипа Дельфи-DLL Адаптер::MDAGenerator
// Delphi интерфейсы для адаптера (.pas)
//+ pas
<<generator>> pas OBJECT IN %S
//#UC START# *470F152700FAfor4753C0BC029E*
//#UC END# *470F152700FAfor4753C0BC029E*
; // pas


// реализация абстрактного стереотипа Документация::MDAGenerator
// Хак для [$281531116]
//+ link_to_requests_hack
<<generator>> link_to_requests_hack OBJECT IN %S
//#UC START# *4E65F581015Afor4753C0BC029E*
//#UC END# *4E65F581015Afor4753C0BC029E*
; // link_to_requests_hack


// реализация абстрактного стереотипа Документация::MDAGenerator
// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for4753C0BC029E*
//#UC END# *46E6D4BB0339for4753C0BC029E*
; // wiki


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Вложенные стереотипы

//: FactoryMemory::Class::common key::Attribute
end. // <<FactoryMemory>>

implementation @ :: <<FactoryMemory>> <<"common key">> ;
//? Тип единого ключа
//? используется для идентификации объектов в общей "памяти", Дополнительно будут сгенерированы специальные функции преобразования параметров-ключей фабрик в этот единый ключ. По умолчанию, если единый ключ не задан, считается, что все фабрики имеют одинаковые параметры-ключи, и соотвественно, никакого преобразования не требуется.
// Параметры стереотипа
//Y code_attr.gif
//L code_attr
//l arl
// - возможные типы связи атрибута

// Генераторы
// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for4753C0D40361*
//#UC END# *46E6D4BB0339for4753C0D40361*
; // wiki


// генератор idl спецификаций (.idl)
//+ idl
<<generator>> idl OBJECT IN %S
//#UC START# *47022BBE0261for4753C0D40361*
//#UC END# *47022BBE0261for4753C0D40361*
; // idl


// генератор idl спецификаций для AMI (.idl)
//+ idl_ami
<<generator>> idl_ami OBJECT IN %S
//#UC START# *47022C0F01E4for4753C0D40361*
//#UC END# *47022C0F01E4for4753C0D40361*
; // idl_ami


// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor4753C0D40361*
//#UC END# *47022C88029Ffor4753C0D40361*
; // h


// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor4753C0D40361*
//#UC END# *47022CB8034Bfor4753C0D40361*
; // cpp


// генератор inline файлов реализации C++ (.i.h)
//+ i.h
<<generator>> i.h OBJECT IN %S
//#UC START# *47022CCF00EAfor4753C0D40361*
//#UC END# *47022CCF00EAfor4753C0D40361*
; // i.h


// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for4753C0D40361*
//#UC END# *470321950119for4753C0D40361*
; // java


// генератор реализации фабрик интерфейсов на java (.java)
//+ fctr.java
<<generator>> fctr.java OBJECT IN %S
//#UC START# *470321C1038Afor4753C0D40361*
//#UC END# *470321C1038Afor4753C0D40361*
; // fctr.java


// С++ TIE-обвязка для DLL (_tie.h)
//+ dll.h
<<generator>> dll.h OBJECT IN %S
//#UC START# *47032EC4032Cfor4753C0D40361*
//#UC END# *47032EC4032Cfor4753C0D40361*
; // dll.h


// С++ TIE-обвязка для DLL (_tie.cpp)
//+ dll.cpp
<<generator>> dll.cpp OBJECT IN %S
//#UC START# *47032ED002DEfor4753C0D40361*
//#UC END# *47032ED002DEfor4753C0D40361*
; // dll.cpp


// генератор заголовочных файлов для фабрик интерфейсов (.h)
//+ fctr.h
<<generator>> fctr.h OBJECT IN %S
//#UC START# *4705C5490109for4753C0D40361*
//#UC END# *4705C5490109for4753C0D40361*
; // fctr.h


// генератор файлов реализации для фабрик интерфейсов (.cpp)
//+ fctr.cpp
<<generator>> fctr.cpp OBJECT IN %S
//#UC START# *4705C54B01F4for4753C0D40361*
//#UC END# *4705C54B01F4for4753C0D40361*
; // fctr.cpp


// Delphi интерфейсы для адаптера (.pas)
//+ pas
<<generator>> pas OBJECT IN %S
//#UC START# *470F152700FAfor4753C0D40361*
//#UC END# *470F152700FAfor4753C0D40361*
; // pas


// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor4753C0D40361*
//#UC END# *470F1571031Cfor4753C0D40361*
; // intf.pas


// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor4753C0D40361*
//#UC END# *470F15B800CBfor4753C0D40361*
; // impl.pas


// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
//+ intf2.pas
<<generator>> intf2.pas OBJECT IN %S
//R  
//#UC START# *477398E501C0for4753C0D40361*
//#UC END# *477398E501C0for4753C0D40361*
; // intf2.pas


// 3-я секция интерфейса. Например поле для свойства.
//+ intf3.pas
<<generator>> intf3.pas OBJECT IN %S
//R  
//#UC START# *4774D2A20372for4753C0D40361*
//#UC END# *4774D2A20372for4753C0D40361*
; // intf3.pas


// Генератор файлов форм (.dfm)
//+ dfm
<<generator>> dfm OBJECT IN %S
//R  
//#UC START# *49F5795900ECfor4753C0D40361*
//#UC END# *49F5795900ECfor4753C0D40361*
; // dfm


// Скрипты TC (.sd)
//+ sd
<<generator>> sd OBJECT IN %S
//R  
//#UC START# *4DE79AFC0030for4753C0D40361*
//#UC END# *4DE79AFC0030for4753C0D40361*
; // sd


// Хак для [$281531116]
//+ link_to_requests_hack
<<generator>> link_to_requests_hack OBJECT IN %S
//#UC START# *4E65F581015Afor4753C0D40361*
//#UC END# *4E65F581015Afor4753C0D40361*
; // link_to_requests_hack


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


//: FactoryMemory::Class::uses::ClassDependency
; // st_space_key

end. // :: <<FactoryMemory>> <<"common key">> ;

implementation @ :: <<FactoryMemory>> <<uses>> ;
//? Использование
//? Определяет, что источник использует указанный объект (цель) каким-либо образом. Меожт использоваться при реализации трансформатора ключей фабрики в уникальный ключ, на основе данной связи будет сгенерированы пути включения файлов используемого объекта.
// Параметры стереотипа
//Y code_dep_uses.gif
//L code_dep_uses

// Генераторы
// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for47577B900144*
//#UC END# *46E6D4BB0339for47577B900144*
; // wiki


// генератор idl спецификаций (.idl)
//+ idl
<<generator>> idl OBJECT IN %S
//#UC START# *47022BBE0261for47577B900144*
//#UC END# *47022BBE0261for47577B900144*
; // idl


// генератор idl спецификаций для AMI (.idl)
//+ idl_ami
<<generator>> idl_ami OBJECT IN %S
//#UC START# *47022C0F01E4for47577B900144*
//#UC END# *47022C0F01E4for47577B900144*
; // idl_ami


// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor47577B900144*
//#UC END# *47022C88029Ffor47577B900144*
; // h


// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor47577B900144*
//#UC END# *47022CB8034Bfor47577B900144*
; // cpp


// генератор inline файлов реализации C++ (.i.h)
//+ i.h
<<generator>> i.h OBJECT IN %S
//#UC START# *47022CCF00EAfor47577B900144*
//#UC END# *47022CCF00EAfor47577B900144*
; // i.h


// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for47577B900144*
//#UC END# *470321950119for47577B900144*
; // java


// генератор реализации фабрик интерфейсов на java (.java)
//+ fctr.java
<<generator>> fctr.java OBJECT IN %S
//#UC START# *470321C1038Afor47577B900144*
//#UC END# *470321C1038Afor47577B900144*
; // fctr.java


// С++ TIE-обвязка для DLL (_tie.h)
//+ dll.h
<<generator>> dll.h OBJECT IN %S
//#UC START# *47032EC4032Cfor47577B900144*
//#UC END# *47032EC4032Cfor47577B900144*
; // dll.h


// С++ TIE-обвязка для DLL (_tie.cpp)
//+ dll.cpp
<<generator>> dll.cpp OBJECT IN %S
//#UC START# *47032ED002DEfor47577B900144*
//#UC END# *47032ED002DEfor47577B900144*
; // dll.cpp


// генератор заголовочных файлов для фабрик интерфейсов (.h)
//+ fctr.h
<<generator>> fctr.h OBJECT IN %S
//#UC START# *4705C5490109for47577B900144*
//#UC END# *4705C5490109for47577B900144*
; // fctr.h


// генератор файлов реализации для фабрик интерфейсов (.cpp)
//+ fctr.cpp
<<generator>> fctr.cpp OBJECT IN %S
//#UC START# *4705C54B01F4for47577B900144*
//#UC END# *4705C54B01F4for47577B900144*
; // fctr.cpp


// Delphi интерфейсы для адаптера (.pas)
//+ pas
<<generator>> pas OBJECT IN %S
//#UC START# *470F152700FAfor47577B900144*
//#UC END# *470F152700FAfor47577B900144*
; // pas


// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor47577B900144*
//#UC END# *470F1571031Cfor47577B900144*
; // intf.pas


// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor47577B900144*
//#UC END# *470F15B800CBfor47577B900144*
; // impl.pas


// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
//+ intf2.pas
<<generator>> intf2.pas OBJECT IN %S
//R  
//#UC START# *477398E501C0for47577B900144*
//#UC END# *477398E501C0for47577B900144*
; // intf2.pas


// 3-я секция интерфейса. Например поле для свойства.
//+ intf3.pas
<<generator>> intf3.pas OBJECT IN %S
//R  
//#UC START# *4774D2A20372for47577B900144*
//#UC END# *4774D2A20372for47577B900144*
; // intf3.pas


// Генератор файлов форм (.dfm)
//+ dfm
<<generator>> dfm OBJECT IN %S
//R  
//#UC START# *49F5795900ECfor47577B900144*
//#UC END# *49F5795900ECfor47577B900144*
; // dfm


// Скрипты TC (.sd)
//+ sd
<<generator>> sd OBJECT IN %S
//R  
//#UC START# *4DE79AFC0030for47577B900144*
//#UC END# *4DE79AFC0030for47577B900144*
; // sd


// Хак для [$281531116]
//+ link_to_requests_hack
<<generator>> link_to_requests_hack OBJECT IN %S
//#UC START# *4E65F581015Afor47577B900144*
//#UC END# *4E65F581015Afor47577B900144*
; // link_to_requests_hack


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

; // st_space_key

end. // :: <<FactoryMemory>> <<uses>> ;

