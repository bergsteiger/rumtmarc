////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Модуль: "w:/MDProcess/CommonTemplates/ServerLib/AdditionalTypes/ServerInterface.tpi"
// Генерация мета-шаблонов
// Generated from UML model, root element: <<MDAClass::Class>> MDProcess$Templates::CommonTemplates::ServerLib::AdditionalTypes::ServerInterface
//
// Серверный интерфейс
// ---
// Определяет интерфейсы в контексте своей компоненты. Для Сервера это серверные интерфейсы, для
// ДЛЛ - объъектный интерфейс экспортируемый ДЛЛ, для библиотеки - интерфейс клсса, для ГУИ набор
// операция пользователя.
//
//
// Все права принадлежат ООО НПП "Гарант-Сервис".
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//: ServerInterface::Class
implementation @ <<ServerInterface>>
//? Серверный интерфейс
//? Определяет интерфейсы в контексте своей компоненты. Для Сервера это серверные интерфейсы, для ДЛЛ - объъектный интерфейс экспортируемый ДЛЛ, для библиотеки - интерфейс клсса, для ГУИ набор операция пользователя.
//< *::Class,*::Category

//= ServerFacet::Class
//= AbstractInterface::Class

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Параметры стереотипа
//a raf
// - тип абстракции
//Y code_server_interface.gif
//L code_server_interface
// Параметры визуализации
//$ C 215,215,255
//$ l 10,10,255
//$ f 10,10,255

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Пользовательские свойства

//p Use AMI:b=false ? генерирует CORBA интерфейс с поддержкой AMI
//p debug log:b=false ? включает генерацию вывода в лог обращений к методам реализующим доступ к данному атрибуту
//p TODO:s ? напоминалка что-то сделать

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Функции стереотипа

//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'

//%f _wiki_up_print
; // st_space_key

: wiki_up_print OBJECT IN %S
//	%S%[ServerFacet::Class]f_wiki_up_print()[{"%S{Use AMI}"!="%S{!Use AMI}"}%f_up_prefix(%S) *Use AMI* = *%S{Use AMI}* - генерирует CORBA интерфейс с поддержкой AMI
 call-inherited:: 'ServerFacet' wiki_up_print %( )%
 %IF ( ( %S get_up ( 'Use AMI' ) ) %!= ( %S get_up_def ( 'Use AMI' ) ) ) 
  [%f] up_prefix %( %S )% ' *Use AMI* = *'
  %S get_up ( 'Use AMI' ) '* - генерирует CORBA интерфейс с поддержкой AMI'
//	][{"%S{debug log}"!="%S{!debug log}"}%f_up_prefix(%S) *debug log* = *%S{debug log}* - включает генерацию вывода в лог обращений к методам реализующим доступ к данному атрибуту
 %END-IF
 %IF ( ( %S get_up ( 'debug log' ) ) %!= ( %S get_up_def ( 'debug log' ) ) ) 
  [%f] up_prefix %( %S )% ' *debug log* = *'
  %S get_up ( 'debug log' ) '* - включает генерацию вывода в лог обращений к методам реализующим доступ к данному атрибуту'
//	][{"%S{TODO}"!="%S{!TODO}"}%f_up_prefix(%S) *TODO* = *%S{TODO}* - напоминалка что-то сделать
 %END-IF
 %IF ( ( %S get_up ( 'TODO' ) ) %!= ( %S get_up_def ( 'TODO' ) ) ) 
  [%f] up_prefix %( %S )% ' *TODO* = *'
  %S get_up ( 'TODO' ) '* - напоминалка что-то сделать'
//	]
 %END-IF

// есть ли не публичные фабрики
//%f _has_private_factory
; // wiki_up_print

: has_private_factory OBJECT IN %S
//#UC START# *470F7242038Afor470F71BF03C8*
//	[{<{}{%CS=factory&%CV!=PublicAccess|%CS=multi factory&%CV!=PublicAccess}{C}>!=0}{false}true]
 %IF ( 
  %FOR %ITEM-CONDITION ( ( %C |S ) %== 'factory' %&& 
    ( ( %C |V ) %!= 'PublicAccess'  ) %|| 
    ( ( %C |S ) %== 'multi factory'  ) %&& 
    ( ( %C |V ) %!= 'PublicAccess'  ) ) 
   ( 'C' ) 
  %END-FOR
  %!= 0 ) 
  %ELSE
    false 
  %THEN
   true 
 %END-IF
//#UC END# *470F7242038Afor470F71BF03C8*
; // has_private_factory


// возвращает true, если есть экспортируемые фабрики
//%f _has_exported_factory
: has_exported_factory OBJECT IN %S
//#UC START# *4AE7EC5D017Dfor470F71BF03C8*
//	[{%f_has_exported_factory_impl(%S)=false}{true}[{<{}{%ga=abstract&%f_has_exported_factory_impl(%g)=true}{%gC}>=0}{true}false]]
 %IF ( ( [%f] has_exported_factory_impl %( %S )% ) %==  false ) 
  %ELSE
    true 
  %THEN
  %IF ( 
   %FOR %ITEM-CONDITION ( ( %g |a ) %== 'abstract' %&& 
     ( ( [%f] has_exported_factory_impl %( %g )% ) %==  true  ) ) 
    ( %g |C ) 
   %END-FOR
   %== 0 ) 
   %ELSE
     true 
   %THEN
    false 
  %END-IF
 %END-IF

//f _has_exported_factory_impl
; // has_exported_factory

end. // <<ServerInterface>>

: has_exported_factory_impl OBJECT IN %S
//	[{"<{}{%f_kind_of(C,ServerFactoryOperationInternal::Class)=true}{%C}[{%C%f_is_exported()=true}.]>"!=""}{false}true]
 %IF ( 
  %FOR %ITEM-CONDITION ( ( [%f] kind_of %( 'C' %, 'ServerFactoryOperationInternal::Class' )% ) %==  true ) 
   ( %C ) 
   %IF ( ( %C %f is_exported %( )% ) %==  true ) 
    '.' 
   %END-IF
  %END-FOR
  %!= '' ) 
  %ELSE
    false 
  %THEN
   true 
 %END-IF
//#UC END# *4AE7EC5D017Dfor470F71BF03C8*
; // has_exported_factory_impl


// возвращает true, если есть неэкспортируемые фабрики
//%f _has_non_exported_factory
implementation @ <<ServerInterface>>
: has_non_exported_factory OBJECT IN %S
//#UC START# *4AE7F23B0014for470F71BF03C8*
//	[{%f_has_non_exported_factory(%S)=false}{true}[{<{}{%ga=abstract&%f_has_non_exported_factory(%g)=true}{%gC}>=0}{true}false]]
 %IF ( ( [%f] has_non_exported_factory %( %S )% ) %==  false ) 
  %ELSE
    true 
  %THEN
  %IF ( 
   %FOR %ITEM-CONDITION ( ( %g |a ) %== 'abstract' %&& 
     ( ( [%f] has_non_exported_factory %( %g )% ) %==  true  ) ) 
    ( %g |C ) 
   %END-FOR
   %== 0 ) 
   %ELSE
     true 
   %THEN
    false 
  %END-IF
 %END-IF

//f _has_non_exported_factory
; // has_non_exported_factory

end. // <<ServerInterface>>

: has_non_exported_factory OBJECT IN %S
//	[{"<{}{%f_kind_of(C,ServerFactoryOperationInternal::Class)=true}{%C}[{%C%f_is_exported()=false}.]>"!=""}{false}true]
 %IF ( 
  %FOR %ITEM-CONDITION ( ( [%f] kind_of %( 'C' %, 'ServerFactoryOperationInternal::Class' )% ) %==  true ) 
   ( %C ) 
   %IF ( ( %C %f is_exported %( )% ) %==  false ) 
    '.' 
   %END-IF
  %END-FOR
  %!= '' ) 
  %ELSE
    false 
  %THEN
   true 
 %END-IF
//#UC END# *4AE7F23B0014for470F71BF03C8*
; // has_non_exported_factory


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// перекрытие базового стереотипа AbstractInterface::Class
// генерация дополнительных объявлений для фабрик (C++)
//%f _additional_fctr_def
implementation @ <<ServerInterface>>
: additional_fctr_def OBJECT IN %S
//#UC START# *471F2C3D0232for470F71BF03C8*
//	[{%S%f_has_exported_factory()=true}private:
 %IF ( ( %S %f has_exported_factory %( )% ) %==  true ) 
  'private:'
//		typedef ACE_Singleton\<%SNFactoryManagerSrv_var, ACE_SYNCH_RECURSIVE_MUTEX\> FactoryManagerSrvSingleton;
  '	typedef ACE_Singleton<'
  %S |N 'FactoryManagerSrv_var, ACE_SYNCH_RECURSIVE_MUTEX> FactoryManagerSrvSingleton;'
//		static Core::Mutex s_init_mutex;
  '	static Core::Mutex s_init_mutex;'
//		static bool s_renew_mode;
  '	static bool s_renew_mode;'
//	<{}{%f_is_factory(%C)=true&%f_is_it_cached(%C)=true&%C%f_is_exported()=true}{%C}
  %FOR %ITEM-CONDITION ( ( [%f] is_factory %( %C )% ) %==  true %&& 
    ( ( [%f] is_it_cached %( %C )% ) %==  true  ) %&& 
    ( ( %C %f is_exported %( )% ) %==  true  ) ) 
   ( %C ) 

//	%f_srv_fctr_mng_fctr_h(%C)
   [%f] srv_fctr_mng_fctr_h %( %C )% 
//	>]
  %END-FOR
 %END-IF
//#UC END# *471F2C3D0232for470F71BF03C8*
; // additional_fctr_def


// перекрытие базового стереотипа AbstractInterface::Class
// генерация дополнительных объявлений для фабрик (Java)
//%f _additional_fctr_def_java
: additional_fctr_def_java OBJECT IN %S
//#UC START# *471F2C4302FDfor470F71BF03C8*
//	[{%S%f_has_exported_factory()=true}	static boolean sRenewMode = false;
 %IF ( ( %S %f has_exported_factory %( )% ) %==  true ) 
  '	static boolean sRenewMode = false;'
//		static class FactoryManagerSrvSingleton {
  '	static class FactoryManagerSrvSingleton {'
//			private static %SNFactoryManagerSrv sInstance_ = null;
  '		private static '
  %S |N 'FactoryManagerSrv sInstance_ = null;'
//	

//			public static %SNFactoryManagerSrv getInstance () {
  '		public static '
  %S |N 'FactoryManagerSrv getInstance () {'
//				return sInstance_;
  '			return sInstance_;'
//			}
  '		}'
//	

//			public static void setInstance (%SNFactoryManagerSrv instance) {
  '		public static void setInstance ('
  %S |N 'FactoryManagerSrv instance) {'
//				sInstance_ = instance;
  '			sInstance_ = instance;'
//			}
  '		}'
//	

//		}
  '	}'
//	<{}{%f_is_factory(%C)=true&%f_is_it_cached(%C)=true&%C%f_is_exported()=true}{%C}
  %FOR %ITEM-CONDITION ( ( [%f] is_factory %( %C )% ) %==  true %&& 
    ( ( [%f] is_it_cached %( %C )% ) %==  true  ) %&& 
    ( ( %C %f is_exported %( )% ) %==  true  ) ) 
   ( %C ) 

//	%f_srv_fctr_mng_fctr_java(%C)
   [%f] srv_fctr_mng_fctr_java %( %C )% 
//	>]
  %END-FOR
 %END-IF
//#UC END# *471F2C4302FDfor470F71BF03C8*
; // additional_fctr_def_java


// перекрытие базового стереотипа AbstractInterface::Class
// возвращает базовый менеджер фабрик (C++)
//%f _base_fctr_mng
: base_fctr_mng OBJECT IN %S
//#UC START# *471F2C4701E4for470F71BF03C8*
//	%f_set_var(NEED_COMMA,"false")\
 [%f] set_var %( 'NEED_COMMA' %, false )% 
//	: [{%S%f_has_exported_factory()=true}%f_set_var(NEED_COMMA,"true")virtual public POA_%f_full_name(%S)FactoryManagerSrv][{%S%f_has_non_exported_factory()=true}[{%{NEED_COMMA}N=true}, ]virtual public %SNFactoryManagerLocal]
 ': '
 %IF ( ( %S %f has_exported_factory %( )% ) %==  true ) 
  [%f] set_var %( 'NEED_COMMA' %, true )% 'virtual public POA_'
  [%f] full_name %( %S )% 'FactoryManagerSrv' 
 %END-IF
 %IF ( ( %S %f has_non_exported_factory %( )% ) %==  true ) 
  %IF ( ( ( get_global_var ( 'NEED_COMMA' ) |N ) ) %==  true ) 
   ', ' 
  %END-IF
  'virtual public '
  %S |N 'FactoryManagerLocal' 
 %END-IF
//#UC END# *471F2C4701E4for470F71BF03C8*
; // base_fctr_mng


// перекрытие базового стереотипа AbstractInterface::Class
// возвращает базовый менеджер фабрик (Java)
//%f _base_fctr_mng_java
: base_fctr_mng_java OBJECT IN %S
//#UC START# *471F2C4B008Cfor470F71BF03C8*
//	%f_set_var(NEED_COMMA,"false")\
 [%f] set_var %( 'NEED_COMMA' %, false )% 
//	 extends [{%S%f_has_exported_factory()=true}%f_set_var(NEED_COMMA,"true")%SNFactoryManagerSrvPOA]\
 ' extends '
 %IF ( ( %S %f has_exported_factory %( )% ) %==  true ) 
  [%f] set_var %( 'NEED_COMMA' %, true )% %S |N 'FactoryManagerSrvPOA' 
 %END-IF
//	[{%S%f_has_non_exported_factory()=true}[{%{NEED_COMMA}N=true} ]%SNFactoryManagerLocal]
 %IF ( ( %S %f has_non_exported_factory %( )% ) %==  true ) 
  %IF ( ( ( get_global_var ( 'NEED_COMMA' ) |N ) ) %==  true ) 
   ' ' 
  %END-IF
  %S |N 'FactoryManagerLocal' 
 %END-IF
//#UC END# *471F2C4B008Cfor470F71BF03C8*
; // base_fctr_mng_java


// перекрытие базового стереотипа AbstractInterface::Class
// что это ??? (C++)
//%f _publish_self_cpp
: publish_self_cpp OBJECT IN %S
//#UC START# *471F2C4F03B9for470F71BF03C8*
//	void %SNFactoryManager::publish_self () {
 'void '
 %S |N 'FactoryManager::publish_self () {'
//	[{%S%f_has_exported_factory()=true}	if (Singleton::instance()-\>m_has_registred_factories) {
 %IF ( ( %S %f has_exported_factory %( )% ) %==  true ) 
  '	if (Singleton::instance()->m_has_registred_factories) {'
//			%SNFactoryManagerSrv_var ref = Singleton::instance()-\>_this();
  '		'
  %S |N 'FactoryManagerSrv_var ref = Singleton::instance()->_this();'
//			CoreSrv::bind_path (&LibHomeFactory::get().get_orb_facet().get_ns_root(), ref.in(), "%f_full_name(%S)");
  '		CoreSrv::bind_path (&LibHomeFactory::get().get_orb_facet().get_ns_root(), ref.in(), "'
  [%f] full_name %( %S )% ');'
//		}
  '	}'
//	]}\n\n
 %END-IF
 '}'#13#10#13#10
//#UC END# *471F2C4F03B9for470F71BF03C8*
; // publish_self_cpp


// перекрытие базового стереотипа AbstractInterface::Class
// что это?  (C++)
//%f _publish_self_h
: publish_self_h OBJECT IN %S
//#UC START# *471F2C52032Cfor470F71BF03C8*
//	\tstatic void publish_self ();\n\n
 #9'static void publish_self ();'#13#10#13#10
//#UC END# *471F2C52032Cfor470F71BF03C8*
; // publish_self_h


// перекрытие базового стереотипа AbstractInterface::Class
// что это?? (Java)
//%f _publish_self_java
: publish_self_java OBJECT IN %S
//#UC START# *471F2C56032Cfor470F71BF03C8*
//	\tpublic static void publishSelf () {
 #9'public static void publishSelf () {'
//	[{%S%f_has_exported_factory()=true}\t	if (%SNFactoryManager.%S%f_fctr_mng_get_instance_name()().hasRegistredFactories_) {
 %IF ( ( %S %f has_exported_factory %( )% ) %==  true ) 
  #9'	if ('
  %S |N 'FactoryManager.'
  %S %f fctr_mng_get_instance_name %( )% '().hasRegistredFactories_) {'
//	\t		try {
  #9'		try {'
//	\t			ru.garant.shared.CoreSrv.cos_naming_op.bindPath (
  #9'			ru.garant.shared.CoreSrv.cos_naming_op.bindPath ('
//	\t				<{}{%PM=Library::Category|%PM=ServerLibrary::Category}%f_dump_java_package(%P).%PN.LibHomeFactory>.get().getOrbFacet().getNsRoot()
  #9'				'
  %FOR %ITEM-CONDITION ( ( %P |M ) %== 'Library::Category' %|| 
    ( ( %P |M ) %== 'ServerLibrary::Category'  ) ) 
   [%f] dump_java_package %( %P )% '.'
   %P |N '.LibHomeFactory' 
  %END-FOR
  '.get().getOrbFacet().getNsRoot()'
//	\t				, <{}{%PM=Library::Category|%PM=ServerLibrary::Category}%f_dump_java_package(%P).%PN.LibHomeFactory>.get().getOrbFacet().getRootPoa().servant_to_reference(%SNFactoryManager.%S%f_fctr_mng_get_instance_name()())
  #9'				, '
  %FOR %ITEM-CONDITION ( ( %P |M ) %== 'Library::Category' %|| 
    ( ( %P |M ) %== 'ServerLibrary::Category'  ) ) 
   [%f] dump_java_package %( %P )% '.'
   %P |N '.LibHomeFactory' 
  %END-FOR
  '.get().getOrbFacet().getRootPoa().servant_to_reference('
  %S |N 'FactoryManager.'
  %S %f fctr_mng_get_instance_name %( )% '())'
//	\t				, "%f_full_name(%S)"
  #9'				, "'
  [%f] full_name %( %S )% 
//	\t			);
  #9'			);'
//	[<{}{}{%E}\
  %IF-NOT-EMPTY
   %FOR ( %E ) 
//	\t		} catch (%f_type(%E) ex) {
    #9'		} catch ('
    [%f] type %( %E )% ' ex) {'
//	\t			Logs.LOG_SEX(ex);
    #9'			Logs.LOG_SEX(ex);'
//	\t			throw ex;
    #9'			throw ex;'
//	>]\
   %END-FOR
  %END-IF
//	\t		} catch (Exception ex) {
  #9'		} catch (Exception ex) {'
//	\t			Logs.LOG_SEX(ex);
  #9'			Logs.LOG_SEX(ex);'
//	\t			throw new org.omg.CORBA.portable.UnknownException (ex);
  #9'			throw new org.omg.CORBA.portable.UnknownException (ex);'
//	\t		}
  #9'		}'
//	\t	}
  #9'	}'
//	\t]}\n\n
  #9 
 %END-IF
 '}'#13#10#13#10
//#UC END# *471F2C56032Cfor470F71BF03C8*
; // publish_self_java


// перекрытие базового стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for470F71BF03C8*
//c                                                                                                           {}
//r "%f_has_factory_methods(%S)"="false"&"%Sa"!="abstract"&<{}{%LS=LocalInterface}{%LC}>=0:                   {Not abstract %SS must provide at least one factory}
//r {"<{}{%GS!=%SS}{C}>"!="0"}:                                                                               {%SS can inherit only from other %SS}
//r {"<{}{%RS!=ServerFacet}{C}>"!="0"}:                                                                       {%SS can realize only ServerFacet}
//r {<{}{%CC=Operation&%CS=multi factory}{%CC}>!=0&%f_factory_switch_count(%S)=0}:                            {%SS определяющий мульти-фабрику должен определять селектор !%f_factory_switch_count(%S)!}
//r {<{}{%PS=ServerLibrary}{C}>!=0&%f_to_lower(%PN)=%f_to_lower(%SN)}:                                        {имя %SS, используемого в качестве серверного типа, не должно совпадать с именем родителя}
//r {<{}{%P{Full MDP}=true}{C}>!=0&<{}{%aS=UseCase}{C}>=0}:                                                   {%SS не используется ни одним прецедентом}
//r {%Sa=abstract&<{}{%SM=%ZM}{C}>=0&<{}{%SM=%LM}{C}>=0}:                                                     {Абстрактный %SS должен иметь наследников}
//#UC END# *4704C0E30186for470F71BF03C8*
; // constraint


// реализация абстрактного стереотипа C++ интерфейсы и реализация::MDAGenerator
// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor470F71BF03C8*
//	%f_set_var(SERV,S)\
 [%f] set_var %( 'SERV' %, 'S' )% 
//	[{%f_has_factory_methods(%S)=true}\
 %IF ( ( [%f] has_factory_methods %( %S )% ) %==  true ) 
//	[{%S%f_has_exported_factory()=true}\
  %IF ( ( %S %f has_exported_factory %( )% ) %==  true ) 
//	Core::Mutex %SNFactory::s_init_mutex;
   'Core::Mutex '
   %S |N 'Factory::s_init_mutex;'
//	bool %SNFactory::s_renew_mode = false;
   'bool '
   %S |N 'Factory::s_renew_mode = false;'
//	[<{}{"%f_is_it_cached(%C)"="true"&[{%CS=factory|%CS=multi factory}{false}true]=true&%C%f_is_exported()=true}{%C}Core::Mutex %SNFactory::s_mutex_for_%CN;[{[{%C<{}{%CS!=cache}{%CC}>!=0}{false}true]=false}
   %IF-NOT-EMPTY
    %FOR %ITEM-CONDITION ( ( [%f] is_it_cached %( %C )% ) %== true %&& 
      ( %IF ( ( %C |S ) %== 'factory' %|| 
       ( ( %C |S ) %== 'multi factory'  ) ) 
      %ELSE
        false 
      %THEN
       true 
     %END-IF
     %==  true  ) %&& 
      ( ( %C %f is_exported %( )% ) %==  true  ) ) 
     ( %C ) 
     'Core::Mutex '
     %S |N 'Factory::s_mutex_for_'
     %C |N ';'
     %IF ( %IF ( ( %C
       %FOR %ITEM-CONDITION ( ( %C |S ) %!= 'cache' ) 
        ( %C |C ) 
       %END-FOR
 )        %!= 0 ) 
       %ELSE
         false 
       %THEN
        true 
      %END-IF
      %==  false ) 

//	CORBA::ULong %SNFactory::s_cached_object_hash_for_%CN = 0;]
      'CORBA::ULong '
      %S |N 'Factory::s_cached_object_hash_for_'
      %C |N ' = 0;' 
     %END-IF
//	>
    %END-FOR
//	]][{%S%f_has_multi_factory()=true&%Sa!=abstract}
   %END-IF
  %END-IF
  %IF ( ( %S %f has_multi_factory %( )% ) %==  true %&& 
    ( ( %S |a ) %!= 'abstract'  ) ) 

//	%S%f_dump_interface_factory_keys_method()
   %S %f dump_interface_factory_keys_method %( )% 
//	

//	][
  %END-IF
  %IF-NOT-EMPTY

//	%f_set_var(INT,S)<{}{"%CS"="factory"}%CX
   [%f] set_var %( 'INT' %, 'S' )% 
   %FOR %ITEM-CONDITION ( ( %C |S ) %== 'factory' ) 
    %C |X 
//	

//	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"}%CX
   %END-FOR
   %FOR %ITEM-CONDITION ( ( %g |a ) %== 'abstract' ) 
    %g
    %FOR %ITEM-CONDITION ( ( %C |S ) %== 'factory' ) 
     %C |X 
//	

//	>>][<{}{"%CS"="multi factory"}%CX
    %END-FOR
    %END-FOR
  %END-IF
  %IF-NOT-EMPTY
   %FOR %ITEM-CONDITION ( ( %C |S ) %== 'multi factory' ) 
    %C |X 
//	

//	><{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"}%CX
   %END-FOR
   %FOR %ITEM-CONDITION ( ( %g |a ) %== 'abstract' ) 
    %g
    %FOR %ITEM-CONDITION ( ( %C |S ) %== 'multi factory' ) 
     %C |X 
//	

//	>>][
    %END-FOR
    %END-FOR
  %END-IF
  %IF-NOT-EMPTY

//	%f_set_var(INT,S)<{}{"%CS"="remover"}%CX
   [%f] set_var %( 'INT' %, 'S' )% 
   %FOR %ITEM-CONDITION ( ( %C |S ) %== 'remover' ) 
    %C |X 
//	

//	><{}{"%ga"="abstract"}%g<{}{"%CS"="remover"}%CX
   %END-FOR
   %FOR %ITEM-CONDITION ( ( %g |a ) %== 'abstract' ) 
    %g
    %FOR %ITEM-CONDITION ( ( %C |S ) %== 'remover' ) 
     %C |X 
//	

//	>>]]
    %END-FOR
    %END-FOR
  %END-IF
 %END-IF
//#UC END# *47022CB8034Bfor470F71BF03C8*
; // cpp


// реализация абстрактного стереотипа C++ интерфейсы и реализация::MDAGenerator
// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor470F71BF03C8*
//	%f_set_var(SERV,S)\
 [%f] set_var %( 'SERV' %, 'S' )% 
//	%f_dump_factory(%S)[{%S%f_has_non_exported_factory()=true}
 [%f] dump_factory %( %S )% %IF ( ( %S %f has_non_exported_factory %( )% ) %==  true ) 

//	

//	// additional interface for private factories implementation
  '// additional interface for private factories implementation'
//	class %SNFactoryManagerLocal {
  'class '
  %S |N 'FactoryManagerLocal {'
//		friend class %SNFactory;
  '	friend class '
  %S |N 'Factory;'
//	private:<{}{"%CS"="factory"&%C%f_is_exported()=false}{%C}
  'private:'
  %FOR %ITEM-CONDITION ( ( %C |S ) %== 'factory' %&& 
    ( ( %C %f is_exported %( )% ) %==  false  ) ) 
   ( %C ) 

//		virtual %t_ret(%{INT},"[{%{INT}S!=ServerInterface|%C#f_is_exported()=false}%Cs]") %CN (%C<{, }%CX>) /*throw (Core::Root::NoActiveFactory%C<, %f_type(%E)>)*/ = 0;
   '	virtual '
   [%t] ret %( ( get_global_var ( 'INT' ) ) %, %IF ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' %|| 
     ( ( %C %?f is_exported %( )% ) %==  false  ) ) 
    %C |s 
   %END-IF
)%    ' '
   %C |N ' ('
   %C
   %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
    %C |X 
   %END-FOR
    ') /*throw (Core::Root::NoActiveFactory'
   %C
   %FOR ', '
    [%f] type %( %E )% 
   %END-FOR
    ')*/ = 0;'
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"&%C#f_is_exported()=false}{%C}
  %END-FOR
  %FOR %ITEM-CONDITION ( ( %g |a ) %== 'abstract' ) 
   %g
   %FOR %ITEM-CONDITION ( ( %C |S ) %== 'factory' %&& 
     ( ( %C %?f is_exported %( )% ) %==  false  ) ) 
    ( %C ) 

//		virtual %t_ret(%{INT},"[{%{INT}S!=ServerInterface|%C#f_is_exported()=false}%Cs]") %CN (%C<{, }%CX>) /*throw (Core::Root::NoActiveFactory%C<, %f_type(%E)>)*/ = 0;
    '	virtual '
    [%t] ret %( ( get_global_var ( 'INT' ) ) %, %IF ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' %|| 
      ( ( %C %?f is_exported %( )% ) %==  false  ) ) 
     %C |s 
    %END-IF
)%     ' '
    %C |N ' ('
    %C
    %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
     %C |X 
    %END-FOR
     ') /*throw (Core::Root::NoActiveFactory'
    %C
    %FOR ', '
     [%f] type %( %E )% 
    %END-FOR
     ')*/ = 0;'
//	>><{}{"%CS"="multi factory"&%C%f_is_exported()=false}{%C}
   %END-FOR
   %END-FOR
  %FOR %ITEM-CONDITION ( ( %C |S ) %== 'multi factory' %&& 
    ( ( %C %f is_exported %( )% ) %==  false  ) ) 
   ( %C ) 

//		virtual %t_ret(%{INT},"[{%{INT}S!=ServerInterface|%C#f_is_exported()=false}%Cs]") %CN (%C<%CX, >const char* key) /*throw (Core::Root::UnknownFactoryKey%C<, %f_type(%E)>)*/ = 0;
   '	virtual '
   [%t] ret %( ( get_global_var ( 'INT' ) ) %, %IF ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' %|| 
     ( ( %C %?f is_exported %( )% ) %==  false  ) ) 
    %C |s 
   %END-IF
)%    ' '
   %C |N ' ('
   %C
   %FOR %C |X ', ' 
   %END-FOR
    'const char* key) /*throw (Core::Root::UnknownFactoryKey'
   %C
   %FOR ', '
    [%f] type %( %E )% 
   %END-FOR
    ')*/ = 0;'
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"&%C#f_is_exported()=false}{%C}
  %END-FOR
  %FOR %ITEM-CONDITION ( ( %g |a ) %== 'abstract' ) 
   %g
   %FOR %ITEM-CONDITION ( ( %C |S ) %== 'multi factory' %&& 
     ( ( %C %?f is_exported %( )% ) %==  false  ) ) 
    ( %C ) 

//		virtual %t_ret(%{INT},"[{%{INT}S!=ServerInterface|%S#f_is_exported()=false}%Cs]") %CN (%C<%CX, >const char* key) /*throw (Core::Root::UnknownFactoryKey%C<, %f_type(%E)>)*/ = 0;
    '	virtual '
    [%t] ret %( ( get_global_var ( 'INT' ) ) %, %IF ( ( ( get_global_var ( 'INT' ) |S ) ) %!= 'ServerInterface' %|| 
      ( ( %S %?f is_exported %( )% ) %==  false  ) ) 
     %C |s 
    %END-IF
)%     ' '
    %C |N ' ('
    %C
    %FOR %C |X ', ' 
    %END-FOR
     'const char* key) /*throw (Core::Root::UnknownFactoryKey'
    %C
    %FOR ', '
     [%f] type %( %E )% 
    %END-FOR
     ')*/ = 0;'
//	>><{}{"%CS"="remover"&%C%f_is_exported()=false}{%C}
   %END-FOR
   %END-FOR
  %FOR %ITEM-CONDITION ( ( %C |S ) %== 'remover' %&& 
    ( ( %C %f is_exported %( )% ) %==  false  ) ) 
   ( %C ) 

//		virtual void %CN (%t_arg(%{INT},"in")%C<, %CX>) /*throw (RootSrv::ForeignObject%C<, %f_type(%E)>)*/ = 0;
   '	virtual void '
   %C |N ' ('
   [%t] arg %( ( get_global_var ( 'INT' ) ) %, 'in' )% %C
   %FOR ', '
    %C |X 
   %END-FOR
    ') /*throw (RootSrv::ForeignObject'
   %C
   %FOR ', '
    [%f] type %( %E )% 
   %END-FOR
    ')*/ = 0;'
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="remover"&%C#f_is_exported()=false}{%C}
  %END-FOR
  %FOR %ITEM-CONDITION ( ( %g |a ) %== 'abstract' ) 
   %g
   %FOR %ITEM-CONDITION ( ( %C |S ) %== 'remover' %&& 
     ( ( %C %?f is_exported %( )% ) %==  false  ) ) 
    ( %C ) 

//		virtual void %CN (%t_arg(%{INT},"in")%C<, %CX>) /*throw (RootSrv::ForeignObject%C<, %f_type(%E)>)*/ = 0;
    '	virtual void '
    %C |N ' ('
    [%t] arg %( ( get_global_var ( 'INT' ) ) %, 'in' )% %C
    %FOR ', '
     %C |X 
    %END-FOR
     ') /*throw (RootSrv::ForeignObject'
    %C
    %FOR ', '
     [%f] type %( %E )% 
    %END-FOR
     ')*/ = 0;'
//	>>};]
   %END-FOR
   %END-FOR
  '};' 
 %END-IF
//#UC END# *47022C88029Ffor470F71BF03C8*
; // h


// перекрытие базового стереотипа C++ Фабрики::MDAGenerator
// генератор файлов реализации для фабрик интерфейсов (.cpp)
//+ fctr.cpp
<<generator>> fctr.cpp OBJECT IN %S
//#UC START# *4705C54B01F4for470F71BF03C8*
//= AbstractInterface::Class;fctr.cpp
%call-other-gen ( 'AbstractInterface' 'fctr.cpp' )
//#UC END# *4705C54B01F4for470F71BF03C8*
; // fctr.cpp


// перекрытие базового стереотипа C++ Фабрики::MDAGenerator
// генератор заголовочных файлов для фабрик интерфейсов (.h)
//+ fctr.h
<<generator>> fctr.h OBJECT IN %S
//#UC START# *4705C5490109for470F71BF03C8*
//= AbstractInterface::Class;fctr.h
%call-other-gen ( 'AbstractInterface' 'fctr.h' )
//#UC END# *4705C5490109for470F71BF03C8*
; // fctr.h


// перекрытие базового стереотипа CORBA IDL::MDAGenerator
// генератор idl спецификаций (.idl)
//+ idl
<<generator>> idl OBJECT IN %S
//#UC START# *47022BBE0261for470F71BF03C8*
//F [{"%Sa"="abstract"}abstract ]interface %SN;
//	<#%FF
 %FOR out_indent %F |F 
//	>%f_docs(%S)\
 %END-FOR
 [%f] docs %( %S )% 
//	#[{"%Sa"="abstract"}abstract ]interface %SN[: <{, }%f_type(%G)>] {<{}{%f_is_factory(%C)=false}[
 out_indent %IF ( ( %S |a ) %== 'abstract' ) 
  'abstract ' 
 %END-IF
 'interface '
 %S |N %IF-NOT-EMPTY
  ': '
  %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
   [%f] type %( %G )% 
  %END-FOR
 %END-IF
 ' {'
 %FOR %ITEM-CONDITION ( ( [%f] is_factory %( %C )% ) %==  false ) 
  %IF-NOT-EMPTY

//	%CX]>[{<{}{%f_is_factory(%C)=true&%C{const_type}=combo}{%CC}>!=0}
   %C |X 
  %END-IF
 %END-FOR
 %IF ( 
  %FOR %ITEM-CONDITION ( ( [%f] is_factory %( %C )% ) %==  true %&& 
    ( ( %C get_up ( 'const_type' ) ) %== 'combo'  ) ) 
   ( %C |C ) 
  %END-FOR
  %!= 0 ) 

//	#	void upgrade_rw ();]
  out_indent '	void upgrade_rw ();' 
 %END-IF
//	#};[{%S%f_has_exported_factory(%S)=true}
 out_indent '};'
 %IF ( ( %S %f has_exported_factory %( %S )% ) %==  true ) 

//	

//	[{%S%f_has_multi_factory()=true&%Sa!=abstract}%f_set_var(SWITCH,"")%S%f_find_switch("SWITCH")\
  %IF ( ( %S %f has_multi_factory %( )% ) %==  true %&& 
    ( ( %S |a ) %!= 'abstract'  ) ) 
   [%f] set_var %( 'SWITCH' %, '' )% %S %f find_switch %( 'SWITCH' )% 
//	#typedef sequence\<[{%{SWITCH}%TN!=a-string}{string}%f_type(%{SWITCH}%T)]\> %SNFactoryKeySet;
   out_indent 'typedef sequence<'
   %IF ( ( ( get_global_var ( 'SWITCH' )  ->T |N ) ) %!= 'a-string' ) 
    %ELSE
     'string' 
    %THEN
    [%f] type %( ( get_global_var ( 'SWITCH' )  ->T ) )% 
   %END-IF
   '> '
   %S |N 'FactoryKeySet;'
//	

//	]#// factory manager server interface for %SN
  %END-IF
  out_indent '// factory manager server interface for '
  %S |N 
//	#interface %SNFactoryManagerSrv {
  out_indent 'interface '
  %S |N 'FactoryManagerSrv {'
//	[{%S%f_has_multi_factory()=true&%Sa!=abstract}#	//возвращает список ключей зарегистрированных реализаций интерфейса
  %IF ( ( %S %f has_multi_factory %( )% ) %==  true %&& 
    ( ( %S |a ) %!= 'abstract'  ) ) 
   out_indent '	//возвращает список ключей зарегистрированных реализаций интерфейса'
//	#	%SNFactoryKeySet keys ();
   out_indent '	'
   %S |N 'FactoryKeySet keys ();'
//	

//	][%f_set_var(INT,S)<{}{%CS=factory&%C#f_is_exported()=true}%CX
  %END-IF
  %IF-NOT-EMPTY
   [%f] set_var %( 'INT' %, 'S' )% 
   %FOR %ITEM-CONDITION ( ( %C |S ) %== 'factory' %&& 
     ( ( %C %?f is_exported %( )% ) %==  true  ) ) 
    %C |X 
//	

//	><{}{%ga=abstract}%g<{}{%CS=factory&%C#f_is_exported()=true}!!%CX
   %END-FOR
   %FOR %ITEM-CONDITION ( ( %g |a ) %== 'abstract' ) 
    %g
    %FOR %ITEM-CONDITION ( ( %C |S ) %== 'factory' %&& 
      ( ( %C %?f is_exported %( )% ) %==  true  ) ) 
     '!!'
     %C |X 
//	

//	>>][<{}{%CS=multi factory&%C#f_is_exported()=true}%CX
    %END-FOR
    %END-FOR
  %END-IF
  %IF-NOT-EMPTY
   %FOR %ITEM-CONDITION ( ( %C |S ) %== 'multi factory' %&& 
     ( ( %C %?f is_exported %( )% ) %==  true  ) ) 
    %C |X 
//	

//	><{}{%ga=abstract}%g<{}{%CS=multi factory&%C#f_is_exported()=true}%CX
   %END-FOR
   %FOR %ITEM-CONDITION ( ( %g |a ) %== 'abstract' ) 
    %g
    %FOR %ITEM-CONDITION ( ( %C |S ) %== 'multi factory' %&& 
      ( ( %C %?f is_exported %( )% ) %==  true  ) ) 
     %C |X 
//	

//	>>]#};]
    %END-FOR
    %END-FOR
  %END-IF
  out_indent '};' 
 %END-IF
//#UC END# *47022BBE0261for470F71BF03C8*
; // idl


// перекрытие базового стереотипа Java::MDAGenerator
// генератор реализации фабрик интерфейсов на java (.java)
//+ fctr.java
<<generator>> fctr.java OBJECT IN %S
//#UC START# *470321C1038Afor470F71BF03C8*
//= AbstractInterface::Class;fctr.java
%call-other-gen ( 'AbstractInterface' 'fctr.java' )

//%f _dump_fmng_keys_method
; // fctr.java

: dump_fmng_keys_method OBJECT IN %S
//	[{%XU=fctr.java}%f_set_var(SWITCH,"")%S%f_find_switch("SWITCH")\
 %IF ( ( %X |U ) %== 'fctr.java' ) 
  [%f] set_var %( 'SWITCH' %, '' )% %S %f find_switch %( 'SWITCH' )% 
//	#public %f_type(%{SWITCH}%T)\[\] keys () {
  out_indent 'public '
  [%f] type %( ( get_global_var ( 'SWITCH' )  ->T ) )% '[] keys () {'
//	#	return factoriesMap_.keySet ().toArray (new %f_type(%{SWITCH}%T)\[0\]);
  out_indent '	return factoriesMap_.keySet ().toArray (new '
  [%f] type %( ( get_global_var ( 'SWITCH' )  ->T ) )% '[0]);'
//	#}][{%XU=fctr.h}#%SNFactoryKeySet* keys ();][{%XU=fctr.cpp}%f_set_var(SWITCH,"")%S%f_find_switch("SWITCH")\
  out_indent '}' 
 %END-IF
 %IF ( ( %X |U ) %== 'fctr.h' ) 
  out_indent %S |N 'FactoryKeySet* keys ();' 
 %END-IF
 %IF ( ( %X |U ) %== 'fctr.cpp' ) 
  [%f] set_var %( 'SWITCH' %, '' )% %S %f find_switch %( 'SWITCH' )% 
//	%SNFactoryKeySet* %SNFactoryManager::keys () {
  %S |N 'FactoryKeySet* '
  %S |N 'FactoryManager::keys () {'
//		%SNFactoryKeySet_var list (new %SNFactoryKeySet (m_factories_map.size ()));
  '	'
  %S |N 'FactoryKeySet_var list (new '
  %S |N 'FactoryKeySet (m_factories_map.size ()));'
//		size_t i = 0;
  '	size_t i = 0;'
//		for (FactoryMap::iterator it = m_factories_map.begin (); it != m_factories_map.end (); ++it) {
  '	for (FactoryMap::iterator it = m_factories_map.begin (); it != m_factories_map.end (); ++it) {'
//			(*list)\[i++\] = it-\>first[{%{SWITCH}%TN=a-string|%{SWITCH}%TN=string}.c_str ()];
  '		(*list)[i++] = it->first'
  %IF ( ( ( get_global_var ( 'SWITCH' )  ->T |N ) ) %== 'a-string' %|| 
    ( ( ( get_global_var ( 'SWITCH' )  ->T |N ) ) %== 'string'  ) ) 
   '.c_str ()' 
  %END-IF
  ';'
//		}
  '	}'
//		
  '	'
//		return list._retn ();
  '	return list._retn ();'
//	}]
  '}' 
 %END-IF
//#UC END# *470321C1038Afor470F71BF03C8*
; // dump_fmng_keys_method


// перекрытие базового стереотипа Java::MDAGenerator
// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for470F71BF03C8*
//O %SNFactory.java
//	%f_output_constraint(%S)\
 [%f] output_constraint %( %S )% 
//	%f_header(%S)
 [%f] header %( %S )% 
//	%f_set_var(INT,S)package %f_dump_java_package(%S);
 [%f] set_var %( 'INT' %, 'S' )% 'package '
 [%f] dump_java_package %( %S )% ';'
//	
//	%f_dump_std_java_imports(%S)
 [%f] dump_std_java_imports %( %S )% 
//	
//	<{}{"%iC"!="Category"}{%i}%f_java_import(%i)
//	><{}{"%f_set_var(ARG,C)%{INT}<{}{%iU=%{ARG}%TU}{C}>"="0"&%CC=Attribute&%C%TM!=UMLPrimitive::Class&%f_can_dump_attr(%C%T)=true}{%C}%f_java_import(%C%T)
//	>
//	[{"%f_has_factory_methods(%S)"="true"}%f_java_core_exceptions(%S)
 %IF ( ( [%f] has_factory_methods %( %S )% ) %== true ) 
  [%f] java_core_exceptions %( %S )% 
//	][{%f_is_server_type(%S)=true}
 %END-IF
 %IF ( ( [%f] is_server_type %( %S )% ) %==  true ) 

//	import %f_dump_java_package(%P).%P%P%f_name_prefix()LibHomeFactory;
  'import '
  [%f] dump_java_package %( %P )% '.'
  %P ->P %f name_prefix %( )%  'LibHomeFactory;'
//	]
 %END-IF
//	%t_visibility(%S,"%XU")class %SNFactory {
 [%t] visibility %( %S %, %X |U )% 'class '
 %S |N 'Factory {'
//	[{"%f_has_factory_methods(%S)"="true"}%f_set_var(FACTORY_PARENT,S)
 %IF ( ( [%f] has_factory_methods %( %S )% ) %== true ) 
  [%f] set_var %( 'FACTORY_PARENT' %, 'S' )% 
//	[{%S%f_has_multi_factory()=true}
  %IF ( ( %S %f has_multi_factory %( )% ) %==  true ) 

//		
   '	'
//	%f_shift_intend(1)%S%f_dump_interface_factory_keys_method()%f_shift_intend(-1)
   [%f] shift_intend %( 1 )% %S %f dump_interface_factory_keys_method %( )% [%f] shift_intend %( -1 )% 
//	][<{}{%aS=friend&%aC=Dependency}{Sp}%a%P<	friend class %f_type(%L); // friend's servants
  %END-IF
  %IF-NOT-EMPTY
   %FOR %ITEM-CONDITION ( ( %a |S ) %== 'friend' %&& 
     ( ( %a |C ) %== 'Dependency'  ) ) 
    ( 'Sp' ) 
    %a ->P
    %FOR '	friend class '
     [%f] type %( %L )% '; // friend's servants'
//	>><{}{"%ga"="abstract"}%g<{}{"%aM"="Interface::Class::friend::ClassDependency"}{Sp}%a%P<	friend class %f_type(%L); // friend's servants
    %END-FOR
     %END-FOR
   %FOR %ITEM-CONDITION ( ( %g |a ) %== 'abstract' ) 
    %g
    %FOR %ITEM-CONDITION ( ( %a |M ) %== 'Interface::Class::friend::ClassDependency' ) 
     ( 'Sp' ) 
     %a ->P
     %FOR '	friend class '
      [%f] type %( %L )% '; // friend's servants'
//	>>>
     %END-FOR
      %END-FOR
    %END-FOR
//	][%f_set_var(INT,S)<{}{"%CS"="factory"&"%CV"="PublicAccess"}{%C}
  %END-IF
  %IF-NOT-EMPTY
   [%f] set_var %( 'INT' %, 'S' )% 
   %FOR %ITEM-CONDITION ( ( %C |S ) %== 'factory' %&& 
     ( ( %C |V ) %== 'PublicAccess'  ) ) 
    ( %C ) 

//	%CX
    %C |X 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"&"%CV"="PublicAccess"}{%C}
   %END-FOR
   %FOR %ITEM-CONDITION ( ( %g |a ) %== 'abstract' ) 
    %g
    %FOR %ITEM-CONDITION ( ( %C |S ) %== 'factory' %&& 
      ( ( %C |V ) %== 'PublicAccess'  ) ) 
     ( %C ) 

//	%CX
     %C |X 
//	>>][<{}{"%CS"="factory"&"%CV"!="PublicAccess"}{%C}
    %END-FOR
    %END-FOR
  %END-IF
  %IF-NOT-EMPTY
   %FOR %ITEM-CONDITION ( ( %C |S ) %== 'factory' %&& 
     ( ( %C |V ) %!= 'PublicAccess'  ) ) 
    ( %C ) 

//	%CX
    %C |X 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="factory"&"%CV"!="PublicAccess"}{%C}
   %END-FOR
   %FOR %ITEM-CONDITION ( ( %g |a ) %== 'abstract' ) 
    %g
    %FOR %ITEM-CONDITION ( ( %C |S ) %== 'factory' %&& 
      ( ( %C |V ) %!= 'PublicAccess'  ) ) 
     ( %C ) 

//	%CX
     %C |X 
//	>>][<{}{"%CS"="multi factory"&"%CV"="PublicAccess"}{%C}
    %END-FOR
    %END-FOR
  %END-IF
  %IF-NOT-EMPTY
   %FOR %ITEM-CONDITION ( ( %C |S ) %== 'multi factory' %&& 
     ( ( %C |V ) %== 'PublicAccess'  ) ) 
    ( %C ) 

//	%CX
    %C |X 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"&"%CV"="PublicAccess"}{%C}
   %END-FOR
   %FOR %ITEM-CONDITION ( ( %g |a ) %== 'abstract' ) 
    %g
    %FOR %ITEM-CONDITION ( ( %C |S ) %== 'multi factory' %&& 
      ( ( %C |V ) %== 'PublicAccess'  ) ) 
     ( %C ) 

//	%CX
     %C |X 
//	>>][<{}{"%CS"="multi factory"&"%CV"!="PublicAccess"}{%C}
    %END-FOR
    %END-FOR
  %END-IF
  %IF-NOT-EMPTY
   %FOR %ITEM-CONDITION ( ( %C |S ) %== 'multi factory' %&& 
     ( ( %C |V ) %!= 'PublicAccess'  ) ) 
    ( %C ) 

//	%CX
    %C |X 
//	><{}{"%ga"="abstract"}%g<{}{"%CS"="multi factory"&"%CV"!="PublicAccess"}{%C}
   %END-FOR
   %FOR %ITEM-CONDITION ( ( %g |a ) %== 'abstract' ) 
    %g
    %FOR %ITEM-CONDITION ( ( %C |S ) %== 'multi factory' %&& 
      ( ( %C |V ) %!= 'PublicAccess'  ) ) 
     ( %C ) 

//	%CX
     %C |X 
//	>>]%S%f_additional_fctr_def_java()
    %END-FOR
    %END-FOR
  %END-IF
  %S %f additional_fctr_def_java %( )% 
//	]
 %END-IF
//	} //interface %SNFactory
 '} //interface '
 %S |N 'Factory'

//%f _dump_interface_factory_keys_method
; // java

: dump_interface_factory_keys_method OBJECT IN %S
//	[{%XU=java}#public static %S%f_dump_switch_type()\[\] keys () throws ru.garant.shared.CoreSrv.ForeignObject {
 %IF ( ( %X |U ) %== 'java' ) 
  out_indent 'public static '
  %S %f dump_switch_type %( )% '[] keys () throws ru.garant.shared.CoreSrv.ForeignObject {'
//	#	if (FactoryManagerSrvSingleton.getInstance() == null) {
  out_indent '	if (FactoryManagerSrvSingleton.getInstance() == null) {'
//	#		synchronized (FactoryManagerSrvSingleton.class) {
  out_indent '		synchronized (FactoryManagerSrvSingleton.class) {'
//	#			try {
  out_indent '			try {'
//	#				org.omg.CORBA.Object obj = ru.garant.shared.CoreSrv.cos_naming_op.resolvePath (
  out_indent '				org.omg.CORBA.Object obj = ru.garant.shared.CoreSrv.cos_naming_op.resolvePath ('
//	#					LibHomeFactory.get().getOrbFacet().getNsRoot(), "%f_full_name(%S)"
  out_indent '					LibHomeFactory.get().getOrbFacet().getNsRoot(), "'
  [%f] full_name %( %S )% 
//	#				);
  out_indent '				);'
//	#				FactoryManagerSrvSingleton.setInstance(%SNFactoryManagerSrvHelper.narrow (obj));
  out_indent '				FactoryManagerSrvSingleton.setInstance('
  %S |N 'FactoryManagerSrvHelper.narrow (obj));'
//	#			} catch (java.lang.Exception ex) {
  out_indent '			} catch (java.lang.Exception ex) {'
//	#				Logs.LOG_SEX (ex);
  out_indent '				Logs.LOG_SEX (ex);'
//	#			}
  out_indent '			}'
//	#			if (FactoryManagerSrvSingleton.getInstance() == null) {
  out_indent '			if (FactoryManagerSrvSingleton.getInstance() == null) {'
//	#				throw new ru.garant.shared.CoreSrv.ForeignObject ();
  out_indent '				throw new ru.garant.shared.CoreSrv.ForeignObject ();'
//	#			}
  out_indent '			}'
//	#		}
  out_indent '		}'
//	#	}
  out_indent '	}'
//	#	try {
  out_indent '	try {'
//	#		return FactoryManagerSrvSingleton.getInstance().keys ();
  out_indent '		return FactoryManagerSrvSingleton.getInstance().keys ();'
//	#	} catch (org.omg.CORBA.TRANSIENT ex) {
  out_indent '	} catch (org.omg.CORBA.TRANSIENT ex) {'
//	#		if (sRenewMode) {
  out_indent '		if (sRenewMode) {'
//	#			sRenewMode = false;
  out_indent '			sRenewMode = false;'
//	#			Logs.LOG_W ("WARNING: %SNFactoryManagerSrv is in invalid (inactive) state");
  out_indent '			Logs.LOG_W ("WARNING: '
  %S |N 'FactoryManagerSrv is in invalid (inactive) state");'
//	#			throw  new ru.garant.shared.CoreSrv.ForeignObject ();
  out_indent '			throw  new ru.garant.shared.CoreSrv.ForeignObject ();'
//	#		}
  out_indent '		}'
//	#		synchronized (FactoryManagerSrvSingleton.class) {
  out_indent '		synchronized (FactoryManagerSrvSingleton.class) {'
//	#			Logs.LOG_D ("DEBUG: Try to renew %SNFactoryManagerSrv");
  out_indent '			Logs.LOG_D ("DEBUG: Try to renew '
  %S |N 'FactoryManagerSrv");'
//	#			sRenewMode = true;
  out_indent '			sRenewMode = true;'
//	#			FactoryManagerSrvSingleton.setInstance (null);
  out_indent '			FactoryManagerSrvSingleton.setInstance (null);'
//	#			%S%f_dump_switch_type()\[\] ret = keys ();
  out_indent '			'
  %S %f dump_switch_type %( )% '[] ret = keys ();'
//	#			sRenewMode = false;
  out_indent '			sRenewMode = false;'
//	#			return ret;
  out_indent '			return ret;'
//	#		}
  out_indent '		}'
//	#	}
  out_indent '	}'
//	#}][{%XU=h}#%SNFactoryKeySet* keys (); /*throw (CoreSrv::ForeignObject)*/]\
  out_indent '}' 
 %END-IF
 %IF ( ( %X |U ) %== 'h' ) 
  out_indent %S |N 'FactoryKeySet* keys (); /*throw (CoreSrv::ForeignObject)*/' 
 %END-IF
//	[{%XU=cpp}%SNFactoryKeySet* %SNFactory::keys () /*throw (CoreSrv::ForeignObject)*/ {
 %IF ( ( %X |U ) %== 'cpp' ) 
  %S |N 'FactoryKeySet* '
  %S |N 'Factory::keys () /*throw (CoreSrv::ForeignObject)*/ {'
//		if (FactoryManagerSrvSingleton::instance()-\>ptr() == 0) {
  '	if (FactoryManagerSrvSingleton::instance()->ptr() == 0) {'
//			GUARD (s_init_mutex);
  '		GUARD (s_init_mutex);'
//			if (FactoryManagerSrvSingleton::instance()-\>ptr() == 0) {
  '		if (FactoryManagerSrvSingleton::instance()->ptr() == 0) {'
//				try {
  '			try {'
//					CORBA::Object_var obj = CoreSrv::resolve_path (&LibHomeFactory::get().get_orb_facet().get_ns_root(), "%f_full_name(%S)");
  '				CORBA::Object_var obj = CoreSrv::resolve_path (&LibHomeFactory::get().get_orb_facet().get_ns_root(), "'
  [%f] full_name %( %S )% ');'
//					*FactoryManagerSrvSingleton::instance() = %SNFactoryManagerSrv::_narrow (obj);
  '				*FactoryManagerSrvSingleton::instance() = '
  %S |N 'FactoryManagerSrv::_narrow (obj);'
//				} CATCH_AND_LOG ("COS Naming can't find FactoryManagerSrv for %SN");
  '			} CATCH_AND_LOG ("COS Naming can''t find FactoryManagerSrv for '
  %S |N ');'
//			}
  '		}'
//			if (FactoryManagerSrvSingleton::instance()-\>ptr() == 0) {
  '		if (FactoryManagerSrvSingleton::instance()->ptr() == 0) {'
//				throw CoreSrv::ForeignObject ();
  '			throw CoreSrv::ForeignObject ();'
//			}
  '		}'
//		}
  '	}'
//		try {
  '	try {'
//			return (*FactoryManagerSrvSingleton::instance())-\>keys ();
  '		return (*FactoryManagerSrvSingleton::instance())->keys ();'
//		} catch (CORBA::TRANSIENT&) {
  '	} catch (CORBA::TRANSIENT&) {'
//			if (s_renew_mode) {
  '		if (s_renew_mode) {'
//				s_renew_mode = false;
  '			s_renew_mode = false;'
//				LOG_W (("%SNFactoryManagerSrv is in invalid (inactive) state"));
  '			LOG_W (("'
  %S |N 'FactoryManagerSrv is in invalid (inactive) state"));'
//				throw CoreSrv::ForeignObject ();
  '			throw CoreSrv::ForeignObject ();'
//			}
  '		}'
//			GUARD (s_init_mutex);
  '		GUARD (s_init_mutex);'
//			LOG_D (("Try to renew %SNFactoryManagerSrv"));
  '		LOG_D (("Try to renew '
  %S |N 'FactoryManagerSrv"));'
//			
  '		'
//			s_renew_mode = true;
  '		s_renew_mode = true;'
//			(*FactoryManagerSrvSingleton::instance()) = 0;
  '		(*FactoryManagerSrvSingleton::instance()) = 0;'
//			%SNFactoryKeySet* ret = keys ();
  '		'
  %S |N 'FactoryKeySet* ret = keys ();'
//			s_renew_mode = false;
  '		s_renew_mode = false;'
//			
  '		'
//			return ret;
  '		return ret;'
//		}
  '	}'
//	}]
  '}' 
 %END-IF
//#UC END# *470321950119for470F71BF03C8*
; // dump_interface_factory_keys_method


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Вложенные стереотипы

//: ServerInterface::Class::remover::Operation
end. // <<ServerInterface>>

implementation @ :: <<ServerInterface>> <<remover>> ;
//? Уничтожитель
//? Метод обратный фабричному, т.е. метод приводящий к разрушению (временному или постоянному) созданного фабрикой объекта.
//= ServerFactoryOperationInternal::Class
//= InterfaceGeneratorWithJava::MDAGenerator

// Параметры стереотипа
//e g
// - возможность использовать исключения
//Y code_remover.gif
//L code_remover
//T 
// - может не иметь "цели" (типа/результата)
//m f
// - не может быть реализован/иметь перекрытую реализацию
//A
// - стереотипы "цели" (типа/результата)

// Генераторы
// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor471F1823007D*
//#UC END# *47022C88029Ffor471F1823007D*
; // h


// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor471F1823007D*
//#UC END# *47022CB8034Bfor471F1823007D*
; // cpp


// генератор idl спецификаций (.idl)
//+ idl
<<generator>> idl OBJECT IN %S
//#UC START# *47022BBE0261for471F1823007D*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	#void %SN (<{, }%CX>)
 out_indent 'void '
 %S |N ' ('
 %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
  %C |X 
 %END-FOR
 ')'
//	#	raises (CoreSrv::ForeignObject<, %f_type(%E)>);
 out_indent '	raises (CoreSrv::ForeignObject'
 %FOR ', '
  [%f] type %( %E )% 
 %END-FOR
 ');'
//#UC END# *47022BBE0261for471F1823007D*
; // idl


// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for471F1823007D*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	#%t_visibility(%S,"%XU")static void %SN (%t_arg(%{INT},"in") obj_<, %f_arg_full_decl(%C)>) throws ru.garant.shared.CoreSrv.ForeignObject<, %f_type(%E)> {
 out_indent [%t] visibility %( %S %, %X |U )% 'static void '
 %S |N ' ('
 [%t] arg %( ( get_global_var ( 'INT' ) ) %, 'in' )% ' obj_'
 %FOR ', '
  [%f] arg_full_decl %( %C )% 
 %END-FOR
 ') throws ru.garant.shared.CoreSrv.ForeignObject'
 %FOR ', '
  [%f] type %( %E )% 
 %END-FOR
 ' {'
//	#	if (FactoryManagerSrvSingleton.getInstance() == null) {
 out_indent '	if (FactoryManagerSrvSingleton.getInstance() == null) {'
//	#		synchronized (FactoryManagerSrvSingleton.class) {
 out_indent '		synchronized (FactoryManagerSrvSingleton.class) {'
//	#			try {
 out_indent '			try {'
//	#				org.omg.CORBA.Object obj = ru.garant.shared.CoreSrv.cos_naming_op.resolvePath (
 out_indent '				org.omg.CORBA.Object obj = ru.garant.shared.CoreSrv.cos_naming_op.resolvePath ('
//	#					LibHomeFactory.get().getOrbFacet().getNsRoot(), "%f_full_name(%{INT})"
 out_indent '					LibHomeFactory.get().getOrbFacet().getNsRoot(), "'
 [%f] full_name %( ( get_global_var ( 'INT' ) ) )% '"'
//	#				);
 out_indent '				);'
//	#				FactoryManagerSrvSingleton.setInstance(%{INT}NFactoryManagerSrvHelper.narrow (obj));
 out_indent '				FactoryManagerSrvSingleton.setInstance('
 ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrvHelper.narrow (obj));'
//	#			} catch (java.lang.Exception ex) {
 out_indent '			} catch (java.lang.Exception ex) {'
//	#				Logs.LOG_SEX (ex);
 out_indent '				Logs.LOG_SEX (ex);'
//	#			}
 out_indent '			}'
//	#			if (FactoryManagerSrvSingleton.getInstance() == null) {
 out_indent '			if (FactoryManagerSrvSingleton.getInstance() == null) {'
//	#				throw new ru.garant.shared.CoreSrv.ForeignObject ();
 out_indent '				throw new ru.garant.shared.CoreSrv.ForeignObject ();'
//	#			}
 out_indent '			}'
//	#		}
 out_indent '		}'
//	#	}
 out_indent '	}'
//	[{%SV!=PublicAccess}
 %IF ( ( %S |V ) %!= 'PublicAccess' ) 

//	#	%f_type(%{INT})FactoryManagerLocal lsrv = null;
  out_indent '	'
  [%f] type %( ( get_global_var ( 'INT' ) ) )% 'FactoryManagerLocal lsrv = null;'
//	#	try {
  out_indent '	try {'
//	#		org.omg.PortableServer.Servant srv = LibHomeFactory::get().getOrbFacet().getRootPoa().reference_to_servant (FactoryManagerSrvSingleton.getInstance());
  out_indent '		org.omg.PortableServer.Servant srv = LibHomeFactory::get().getOrbFacet().getRootPoa().reference_to_servant (FactoryManagerSrvSingleton.getInstance());'
//	#		lsrv = (%f_type(%{INT})FactoryManagerLocal)srv;
  out_indent '		lsrv = ('
  [%f] type %( ( get_global_var ( 'INT' ) ) )% 'FactoryManagerLocal)srv;'
//	#	} catch (org.omg.PortableServer.POA.WrongAdapter ex) {
  out_indent '	} catch (org.omg.PortableServer.POA.WrongAdapter ex) {'
//	#		Logs.LOG_SEX (ex);
  out_indent '		Logs.LOG_SEX (ex);'
//	#	}
  out_indent '	}'
//	#	if (lsrv == null) {
  out_indent '	if (lsrv == null) {'
//	#		throw new ru.garant.shared.CoreSrv.ForeignObject ();
  out_indent '		throw new ru.garant.shared.CoreSrv.ForeignObject ();'
//	#	}]
  out_indent '	}' 
 %END-IF
//	#	try {
 out_indent '	try {'
//	#		Integer objHash_ = new Integer ([{%SV=PublicAccess}{lsrv}FactoryManagerSrvSingleton.getInstance()].%f_to_java(%SN) (obj_<, %f_to_java(%CN)>));
 out_indent '		Integer objHash_ = new Integer ('
 %IF ( ( %S |V ) %== 'PublicAccess' ) 
  %ELSE
   'lsrv' 
  %THEN
  'FactoryManagerSrvSingleton.getInstance()' 
 %END-IF
 '.'
 [%f] to_java %( %S |N )% ' (obj_'
 %FOR ', '
  [%f] to_java %( %C |N )% 
 %END-FOR
 '));'
//	%P<{}{%CS=factory|%CS=multi factory}[{%Cs=cached|%Cs=const,cached}\
 %P
 %FOR %ITEM-CONDITION ( ( %C |S ) %== 'factory' %|| 
   ( ( %C |S ) %== 'multi factory'  ) ) 
  %IF ( ( %C |s ) %== 'cached' %|| 
    ( ( %C |s ) %== 'const,cached'  ) ) 
//	#			synchronized ([{%C%Cx=true}{CachedObjectFor%f_to_borland(%CN)}CachedObjectsFor%f_to_borland(%CN)Sngl].class) {
   out_indent '			synchronized ('
   %IF ( ( %C ->C |x  ) %==  true ) 
    %ELSE
     'CachedObjectFor'
     [%f] to_borland %( %C |N )% 
    %THEN
    'CachedObjectsFor'
    [%f] to_borland %( %C |N )% 'Sngl' 
   %END-IF
   '.class) {'
//	#				[{%C%Cx=false}if (cachedObjectHashFor%f_to_borland(%CN)_.equals (objHash_)) {
   out_indent '				'
   %IF ( ( %C ->C |x  ) %==  false ) 
    'if (cachedObjectHashFor'
    [%f] to_borland %( %C |N )% '_.equals (objHash_)) {'
//	#					CachedObjectFor%f_to_borland(%CN).setInstance(null);
    out_indent '					CachedObjectFor'
    [%f] to_borland %( %C |N )% '.setInstance(null);'
//	#				}][{%C%Cx=true}
    out_indent '				}' 
   %END-IF
   %IF ( ( %C ->C |x  ) %==  true ) 

//	#					ObjectCreationIdFor%f_to_borland(%CN) key = CachedObjectsIndexFor%f_to_borland(%CN)Sngl.instance().get (objHash_);
    out_indent '					ObjectCreationIdFor'
    [%f] to_borland %( %C |N )% ' key = CachedObjectsIndexFor'
    [%f] to_borland %( %C |N )% 'Sngl.instance().get (objHash_);'
//	#					if (key != null) {
    out_indent '					if (key != null) {'
//	#						CachedObjectsFor%f_to_borland(%CN)Sngl.instance().remove (key);
    out_indent '						CachedObjectsFor'
    [%f] to_borland %( %C |N )% 'Sngl.instance().remove (key);'
//	#						CachedObjectsIndexFor%f_to_borland(%CN)Sngl.instance().remove (objHash_);
    out_indent '						CachedObjectsIndexFor'
    [%f] to_borland %( %C |N )% 'Sngl.instance().remove (objHash_);'
//	#					}]
    out_indent '					}' 
   %END-IF
//	#			}]>
   out_indent '			}' 
  %END-IF
 %END-FOR
 //	#	} catch (org.omg.CORBA.TRANSIENT ex) {
 out_indent '	} catch (org.omg.CORBA.TRANSIENT ex) {'
//	#		if (sRenewMode) {
 out_indent '		if (sRenewMode) {'
//	#			sRenewMode = false;
 out_indent '			sRenewMode = false;'
//	#			Logs.LOG_W ("WARNING: %{INT}NFactoryManagerSrv is in invalid (inactive) state");
 out_indent '			Logs.LOG_W ("WARNING: '
 ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrv is in invalid (inactive) state");'
//	#			throw  new ru.garant.shared.CoreSrv.ForeignObject ();
 out_indent '			throw  new ru.garant.shared.CoreSrv.ForeignObject ();'
//	#		}
 out_indent '		}'
//	#		synchronized (FactoryManagerSrvSingleton.class) {
 out_indent '		synchronized (FactoryManagerSrvSingleton.class) {'
//	#			Logs.LOG_D ("DEBUG: Try to renew %{INT}NFactoryManagerSrv");
 out_indent '			Logs.LOG_D ("DEBUG: Try to renew '
 ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrv");'
//	#			sRenewMode = true;
 out_indent '			sRenewMode = true;'
//	#			FactoryManagerSrvSingleton.setInstance (null);
 out_indent '			FactoryManagerSrvSingleton.setInstance (null);'
//	#			%SN (obj_<, %CN>);
 out_indent '			'
 %S |N ' (obj_'
 %FOR ', '
  %C |N 
 %END-FOR
 ');'
//	#			sRenewMode = false;
 out_indent '			sRenewMode = false;'
//	#		}
 out_indent '		}'
//	#	}
 out_indent '	}'
//	#}
 out_indent '}'
//#UC END# *470321950119for471F1823007D*
; // java


// генератор реализации фабрик интерфейсов на java (.java)
//+ fctr.java
<<generator>> fctr.java OBJECT IN %S
//#UC START# *470321C1038Afor471F1823007D*
//#UC END# *470321C1038Afor471F1823007D*
; // fctr.java


// генератор заголовочных файлов для фабрик интерфейсов (.h)
//+ fctr.h
<<generator>> fctr.h OBJECT IN %S
//#UC START# *4705C5490109for471F1823007D*
//#UC END# *4705C5490109for471F1823007D*
; // fctr.h


// генератор файлов реализации для фабрик интерфейсов (.cpp)
//+ fctr.cpp
<<generator>> fctr.cpp OBJECT IN %S
//#UC START# *4705C54B01F4for471F1823007D*
//#UC END# *4705C54B01F4for471F1823007D*
; // fctr.cpp


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа ServerFactoryOperationInternal::Class
// генерит реализацию экспортируемой фабрики
//%f _dump_as_exported_cpp
; // st_space_key

: dump_as_exported_cpp OBJECT IN %S
//#UC START# *4AE7F60D03DAfor471F1823007D*
//#UC END# *4AE7F60D03DAfor471F1823007D*
; // dump_as_exported_cpp


// реализация абстрактного стереотипа ServerFactoryOperationInternal::Class
// генерит реализацию неэкспортируемой фабрики
//%f _dump_as_non_exported_cpp
: dump_as_non_exported_cpp OBJECT IN %S
//#UC START# *4AE7F6490336for471F1823007D*
//#UC END# *4AE7F6490336for471F1823007D*
; // dump_as_non_exported_cpp


// реализация абстрактного стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for471F1823007D*
//c                              {}
//r {<{}{%PS=ServerLibrary}{C}>!=0&%f_to_lower(%PN)=%f_to_lower(%SN)}: {имя %SS не должно совпадать с именем %P%SS}
//#UC END# *4704C0E30186for471F1823007D*
; // constraint


// реализация абстрактного стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor471F1823007D*
//	mng
 'mng'
//#UC END# *4705CBD6003Efor471F1823007D*
; // wiki_child_kind


// Вложенные стереотипы
//: ServerInterface::Class::remover::Operation::Parameter
end. // :: <<ServerInterface>> <<remover>> ;

implementation @ :: <<ServerInterface>> <<remover>> Parameter ;
//? Параметр
//= ServerFacet::Class::Operation::Parameter

// Параметры стереотипа
//Y code_param.gif
//L code_param

// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'



//: ServerInterface::Class::factory::Operation
; // st_space_key

end. // :: <<ServerInterface>> <<remover>> Parameter ;

implementation @ :: <<ServerInterface>> <<factory>> ;
//? Фабрика (одиночная)
//? Будет создан абстрактный интерфейс фабрики, который будут реализовывать конкретные фабрики (по одной на каждый сервант), создающие соответствующие серванты. Конкретные фабрики мугут инициализироваться своими специфичными параметрами. Созданные конкретные фабрики будут регистрироваться в менеджере фабрик. Последний осуществляет выбор нужной "активной" фабрики при получении запроса на создание экземпляра объекта. Для ОДИНОЧНОЙ фабрики - активной может быть только ОДНА такая фабрика - кто последний зарегистрировался тот и активен.
//= Interface::Class::factory::Operation
//= ServerFactoryOperationInternal::Class

// Параметры стереотипа
//Y code_factory.gif
//L code_factory
//m f
// - не может быть реализован/иметь перекрытую реализацию

// Генераторы
// генератор idl спецификаций (.idl)
//+ idl
<<generator>> idl OBJECT IN %S
//#UC START# *47022BBE0261for471F1E100186*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	[{%S{const_type}=combo}{%f_srv_factory_idl(%S)}%f_srv_factory_idl(%S)
 %IF ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) 
  %ELSE
   [%f] srv_factory_idl %( %S )% 
  %THEN
  [%f] srv_factory_idl %( %S )% 
//	

//	%f_srv_factory_idl(%S,"_ro")]
  [%f] srv_factory_idl %( %S %, '_ro' )% 
 %END-IF

//f _srv_factory_idl
; // idl

end. // :: <<ServerInterface>> <<factory>> ;

: srv_factory_idl OBJECT IN %S
//	#%t_ret(%{INT},"%Ss") %SN%1N (<{, }{%CS!=cache}%CX>)
 out_indent [%t] ret %( ( get_global_var ( 'INT' ) ) %, %S |s )% ' '
 %S |N %1 |N ' ('
 %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
  %ITEM-CONDITION ( ( %C |S ) %!= 'cache' ) 
  %C |X 
 %END-FOR
 ')'
//	#	raises (CoreSrv::NoActiveFactory<, %f_type(%E)>);
 out_indent '	raises (CoreSrv::NoActiveFactory'
 %FOR ', '
  [%f] type %( %E )% 
 %END-FOR
 ');'
//#UC END# *47022BBE0261for471F1E100186*
; // srv_factory_idl


// генератор заголовочных файлов C++ (.h)
//+ h
implementation @ :: <<ServerInterface>> <<factory>> ;
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor471F1E100186*
//	[{%S%f_is_exported()=true}{%P%f_dump_factory_operation_h(%S)}%f_docs(%S)\
 %IF ( ( %S %f is_exported %( )% ) %==  true ) 
  %ELSE
   %P %f dump_factory_operation_h %( %S )% 
  %THEN
  [%f] docs %( %S )% 
//	[{%S{const_type}=combo}{%f_srv_factory_h(%S)}%f_srv_factory_h(%S)
  %IF ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) 
   %ELSE
    [%f] srv_factory_h %( %S )% 
   %THEN
   [%f] srv_factory_h %( %S )% 
//	

//	%f_srv_factory_h(%S,"_ro")][{<{}{%CS=cache}{C}>!=0}
   [%f] srv_factory_h %( %S %, '_ro' )% 
  %END-IF
  %IF ( 
   %FOR %ITEM-CONDITION ( ( %C |S ) %== 'cache' ) 
    ( 'C' ) 
   %END-FOR
   %!= 0 ) 

//	

//	[{%S{const_type}=combo}{%f_srv_factory_for_server(%S)}%f_srv_factory_for_server(%S)
   %IF ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) 
    %ELSE
     [%f] srv_factory_for_server %( %S )% 
    %THEN
    [%f] srv_factory_for_server %( %S )% 
//	

//	%f_srv_factory_for_server(%S,"_ro")]]]]
    [%f] srv_factory_for_server %( %S %, '_ro' )% 
   %END-IF
  %END-IF
 %END-IF
 ']'

//f _srv_factory_for_server
; // h

end. // :: <<ServerInterface>> <<factory>> ;

: srv_factory_for_server OBJECT IN %S
//	[{%S%f_is_exported()=true}[{%XU=h}#]//Реализация фабрики %SN%1N для использования на стороне сервера
 %IF ( ( %S %f is_exported %( )% ) %==  true ) 
  %IF ( ( %X |U ) %== 'h' ) 
   out_indent 
  %END-IF
  '//Реализация фабрики '
  %S |N %1 |N ' для использования на стороне сервера'
//	[{%XU=h}#static ]%t_ret(%{INT}) [{%XU=cpp}%{INT}NFactory::]%SN%1N_srv (<{, }{%CS!=cache}%CX>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]%{INT}%f_dump_switch_arg_type() key])
  %IF ( ( %X |U ) %== 'h' ) 
   out_indent 'static ' 
  %END-IF
  [%t] ret %( ( get_global_var ( 'INT' ) ) )% ' '
  %IF ( ( %X |U ) %== 'cpp' ) 
   ( get_global_var ( 'INT' ) |N ) 'Factory::' 
  %END-IF
  %S |N %1 |N '_srv ('
  %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
   %ITEM-CONDITION ( ( %C |S ) %!= 'cache' ) 
   %C |X 
  %END-FOR
  %IF ( ( %S |S ) %== 'multi factory' %&& 
    ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
   %IF ( ( %C |x ) %==  true ) 
    ', ' 
   %END-IF
   ( get_global_var ( 'INT' ) %f dump_switch_arg_type %( )% ) ' key' 
  %END-IF
  ')'
//	[{%XU=h}#]	/*throw (CoreSrv::NoActiveFactory<, %f_type(%E)>)*/[{%XU=cpp}{;}
  %IF ( ( %X |U ) %== 'h' ) 
   out_indent 
  %END-IF
  '	/*throw (CoreSrv::NoActiveFactory'
  %FOR ', '
   [%f] type %( %E )% 
  %END-FOR
  ')*/'
  %IF ( ( %X |U ) %== 'cpp' ) 
   %ELSE
    ';' 
   %THEN

//	{
   '{'
//		%{INT}NFactoryManagerSrv_var factory_mng;
   '	'
   ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrv_var factory_mng;'
//		try {
   '	try {'
//			CORBA::Object_var obj = CoreSrv::resolve_path (&LibHomeFactory::get().get_orb_facet().get_ns_root(), "%f_full_name(%{INT})");
   '		CORBA::Object_var obj = CoreSrv::resolve_path (&LibHomeFactory::get().get_orb_facet().get_ns_root(), "'
   [%f] full_name %( ( get_global_var ( 'INT' ) ) )% ');'
//			factory_mng = %{INT}NFactoryManagerSrv::_narrow (obj);
   '		factory_mng = '
   ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrv::_narrow (obj);'
//		} CATCH_AND_LOG ("COS Naming can't find FactoryManagerSrv for %{INT}N");
   '	} CATCH_AND_LOG ("COS Naming can''t find FactoryManagerSrv for '
   ( get_global_var ( 'INT' ) |N ) ');'
//		
   '	'
//		if (CORBA::is_nil (factory_mng)) {
   '	if (CORBA::is_nil (factory_mng)) {'
//			throw CoreSrv::NoActiveFactory ();
   '		throw CoreSrv::NoActiveFactory ();'
//		}
   '	}'
//		
   '	'
//		return factory_mng-\>%SN%1N (<{, }{%CS!=cache}%CN>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctr_key]);
   '	return factory_mng->'
   %S |N %1 |N ' ('
   %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |S ) %!= 'cache' ) 
    %C |N 
   %END-FOR
   %IF ( ( %S |S ) %== 'multi factory' %&& 
     ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
    %IF ( ( %C |x ) %==  true ) 
     ', ' 
    %END-IF
    'fctr_key' 
   %END-IF
   ');'
//	}]]
   '}' 
  %END-IF
 %END-IF

//f _srv_factory_h
; // srv_factory_for_server

: srv_factory_h OBJECT IN %S
//	#static %t_ret(%{INT},"%Ss") %SN%1N (<{, }{%CS!=cache}%CX>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]%{INT}%f_dump_switch_arg_type() key])
 out_indent 'static '
 [%t] ret %( ( get_global_var ( 'INT' ) ) %, %S |s )% ' '
 %S |N %1 |N ' ('
 %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
  %ITEM-CONDITION ( ( %C |S ) %!= 'cache' ) 
  %C |X 
 %END-FOR
 %IF ( ( %S |S ) %== 'multi factory' %&& 
   ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
  %IF ( ( %C |x ) %==  true ) 
   ', ' 
  %END-IF
  ( get_global_var ( 'INT' ) %f dump_switch_arg_type %( )% ) ' key' 
 %END-IF
 ')'
//	#	/*throw ([{%S%f_is_exported()=true}{Core::Root}CoreSrv]::NoActiveFactory<, %f_type(%E)>)*/;
 out_indent '	/*throw ('
 %IF ( ( %S %f is_exported %( )% ) %==  true ) 
  %ELSE
   'Core::Root' 
  %THEN
  'CoreSrv' 
 %END-IF
 '::NoActiveFactory'
 %FOR ', '
  [%f] type %( %E )% 
 %END-FOR
 ')*/;'
//#UC END# *47022C88029Ffor471F1E100186*
; // srv_factory_h


// генератор файлов реализации C++ (.cpp)
//+ cpp
implementation @ :: <<ServerInterface>> <<factory>> ;
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor471F1E100186*
//	[{%S%f_is_exported()=true}{%P%f_dump_factory_operation_cpp(%S)}%f_docs(%S)\
 %IF ( ( %S %f is_exported %( )% ) %==  true ) 
  %ELSE
   %P %f dump_factory_operation_cpp %( %S )% 
  %THEN
  [%f] docs %( %S )% 
//	[{%S{const_type}=combo}{%f_srv_factory_cpp(%S)}%f_srv_factory_cpp(%S)
  %IF ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) 
   %ELSE
    [%f] srv_factory_cpp %( %S )% 
   %THEN
   [%f] srv_factory_cpp %( %S )% 
//	

//	%f_srv_factory_cpp(%S,"_ro")][{<{}{%CS=cache}{C}>!=0}
   [%f] srv_factory_cpp %( %S %, '_ro' )% 
  %END-IF
  %IF ( 
   %FOR %ITEM-CONDITION ( ( %C |S ) %== 'cache' ) 
    ( 'C' ) 
   %END-FOR
   %!= 0 ) 

//	

//	[{%S{const_type}=combo}{%f_srv_factory_for_server(%S)}%f_srv_factory_for_server(%S)
   %IF ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) 
    %ELSE
     [%f] srv_factory_for_server %( %S )% 
    %THEN
    [%f] srv_factory_for_server %( %S )% 
//	

//	%f_srv_factory_for_server(%S,"_ro")]]]
    [%f] srv_factory_for_server %( %S %, '_ro' )% 
   %END-IF
  %END-IF
 %END-IF

//f _srv_factory_cpp
; // cpp

end. // :: <<ServerInterface>> <<factory>> ;

: srv_factory_cpp OBJECT IN %S
//	%t_ret(%{INT},"%Ss") %{INT}NFactory::%SN%1N (<{, }{%CS!=cache}%CX>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]%{INT}%f_dump_switch_arg_type() fctr_key]) /*throw ([{%S%f_is_exported()=true}{Core::Root}CoreSrv]::NoActiveFactory[{%SS=multi factory&%S{transparent multy}=false}, [{%S%f_is_exported()=true}{Core::Root}CoreSrv]::UnknownFactoryKey]<, %f_type(%E)>)*/ {
 [%t] ret %( ( get_global_var ( 'INT' ) ) %, %S |s )% ' '
 ( get_global_var ( 'INT' ) |N ) 'Factory::'
 %S |N %1 |N ' ('
 %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
  %ITEM-CONDITION ( ( %C |S ) %!= 'cache' ) 
  %C |X 
 %END-FOR
 %IF ( ( %S |S ) %== 'multi factory' %&& 
   ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
  %IF ( ( %C |x ) %==  true ) 
   ', ' 
  %END-IF
  ( get_global_var ( 'INT' ) %f dump_switch_arg_type %( )% ) ' fctr_key' 
 %END-IF
 ') /*throw ('
 %IF ( ( %S %f is_exported %( )% ) %==  true ) 
  %ELSE
   'Core::Root' 
  %THEN
  'CoreSrv' 
 %END-IF
 '::NoActiveFactory'
 %IF ( ( %S |S ) %== 'multi factory' %&& 
   ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
  ', '
  %IF ( ( %S %f is_exported %( )% ) %==  true ) 
   %ELSE
    'Core::Root' 
   %THEN
   'CoreSrv' 
  %END-IF
  '::UnknownFactoryKey' 
 %END-IF
 %FOR ', '
  [%f] type %( %E )% 
 %END-FOR
 ')*/ {'
//		if (FactoryManagerSrvSingleton::instance()-\>ptr() == 0) {
 '	if (FactoryManagerSrvSingleton::instance()->ptr() == 0) {'
//			GUARD (s_init_mutex);
 '		GUARD (s_init_mutex);'
//			if (FactoryManagerSrvSingleton::instance()-\>ptr() == 0) {
 '		if (FactoryManagerSrvSingleton::instance()->ptr() == 0) {'
//				try {
 '			try {'
//					CORBA::Object_var obj = CoreSrv::resolve_path (&LibHomeFactory::get().get_orb_facet().get_ns_root(), "%f_full_name(%{INT})");
 '				CORBA::Object_var obj = CoreSrv::resolve_path (&LibHomeFactory::get().get_orb_facet().get_ns_root(), "'
 [%f] full_name %( ( get_global_var ( 'INT' ) ) )% '");'
//					*FactoryManagerSrvSingleton::instance() = %{INT}NFactoryManagerSrv::_narrow (obj);
 '				*FactoryManagerSrvSingleton::instance() = '
 ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrv::_narrow (obj);'
//				} CATCH_AND_LOG ("COS Naming can't find FactoryManagerSrv for %{INT}N");
 '			} CATCH_AND_LOG ("COS Naming can''t find FactoryManagerSrv for '
 ( get_global_var ( 'INT' ) |N ) '");'
//			}
 '		}'
//			if (FactoryManagerSrvSingleton::instance()-\>ptr() == 0) {
 '		if (FactoryManagerSrvSingleton::instance()->ptr() == 0) {'
//				throw CoreSrv::NoActiveFactory ();
 '			throw CoreSrv::NoActiveFactory ();'
//			}
 '		}'
//		}
 '	}'
//	[{%SV!=PublicAccess}
 %IF ( ( %S |V ) %!= 'PublicAccess' ) 

//		%{INT}NFactoryManagerLocal* lsrv = 0;
  '	'
  ( get_global_var ( 'INT' ) |N ) 'FactoryManagerLocal* lsrv = 0;'
//		try {
  '	try {'
//			PortableServer::Servant srv = LibHomeFactory::get().get_orb_facet().get_root_poa().reference_to_servant (*FactoryManagerSrvSingleton::instance());
  '		PortableServer::Servant srv = LibHomeFactory::get().get_orb_facet().get_root_poa().reference_to_servant (*FactoryManagerSrvSingleton::instance());'
//			lsrv = dynamic_cast\<%{INT}NFactoryManagerLocal*\>(srv);
  '		lsrv = dynamic_cast<'
  ( get_global_var ( 'INT' ) |N ) 'FactoryManagerLocal*>(srv);'
//		} catch (PortableServer::POA::WrongAdapter&) {
  '	} catch (PortableServer::POA::WrongAdapter&) {'
//		}
  '	}'
//		if (!lsrv) {
  '	if (!lsrv) {'
//			throw CoreSrv::NoActiveFactory ();
  '		throw CoreSrv::NoActiveFactory ();'
//		}
  '	}'
//	]	try {
 %END-IF
 '	try {'
//	[{%Ss!=cached&%Ss!=const,cached}		return [{%SV=PublicAccess}{lsrv}(*FactoryManagerSrvSingleton::instance())]-\>%SN%1N (<{, }%CN>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctr_key]);
 %IF ( ( %S |s ) %!= 'cached' %&& 
   ( ( %S |s ) %!= 'const,cached'  ) ) 
  '		return '
  %IF ( ( %S |V ) %== 'PublicAccess' ) 
   %ELSE
    'lsrv' 
   %THEN
   '(*FactoryManagerSrvSingleton::instance())' 
  %END-IF
  '->'
  %S |N %1 |N ' ('
  %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
   %C |N 
  %END-FOR
  %IF ( ( %S |S ) %== 'multi factory' %&& 
    ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
   %IF ( ( %C |x ) %==  true ) 
    ', ' 
   %END-IF
   'fctr_key' 
  %END-IF
  ');'
//	][{%Ss=cached|%Ss=const,cached}[{[{<{}{%CS!=cache}{%CC}>!=0}{false}true]=true|[{%SS=multi factory&%S{transparent multy}=false}{false}true]=true}
 %END-IF
 %IF ( ( %S |s ) %== 'cached' %|| 
   ( ( %S |s ) %== 'const,cached'  ) ) 
  %IF ( %IF ( 
    %FOR %ITEM-CONDITION ( ( %C |S ) %!= 'cache' ) 
     ( %C |C ) 
    %END-FOR
    %!= 0 ) 
    %ELSE
      false 
    %THEN
     true 
   %END-IF
   %==  true %|| 
    ( %IF ( ( %S |S ) %== 'multi factory' %&& 
     ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
    %ELSE
      false 
    %THEN
     true 
   %END-IF
   %==  true  ) ) 


//Пока при получении объекта их кэша проверяет влидность этого объекта

//в последствии от этого можно будет избавиться
//			bool created_new = false; //флаг о том, что объект был создан, а не получен из кэша
   '		bool created_new = false; //флаг о том, что объект был создан, а не получен из кэша'
//			GUARD(s_mutex_for_%SN);
   '		GUARD(s_mutex_for_'
   %S |N ');'
//			CachedObjectsFor%f_to_borland(%SN)::iterator f = CachedObjectsFor%f_to_borland(%SN)Sngl::instance()-\>find (ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%CN>));
   '		CachedObjectsFor'
   [%f] to_borland %( %S |N )% '::iterator f = CachedObjectsFor'
   [%f] to_borland %( %S |N )% 'Sngl::instance()->find (ObjectCreationIdFor'
   [%f] to_borland %( %S |N )% '('
   %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
    %C |N 
   %END-FOR
   '));'
//			if (f == CachedObjectsFor%f_to_borland(%SN)Sngl::instance()-\>end()) {
   '		if (f == CachedObjectsFor'
   [%f] to_borland %( %S |N )% 'Sngl::instance()->end()) {'
//				f = CachedObjectsFor%f_to_borland(%SN)Sngl::instance()-\>insert (
   '			f = CachedObjectsFor'
   [%f] to_borland %( %S |N )% 'Sngl::instance()->insert ('
//					CachedObjectsFor%f_to_borland(%SN)::value_type(
   '				CachedObjectsFor'
   [%f] to_borland %( %S |N )% '::value_type('
//						ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%CN>)
   '					ObjectCreationIdFor'
   [%f] to_borland %( %S |N )% '('
   %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
    %C |N 
   %END-FOR
   ')'
//						, [{%SV=PublicAccess}{lsrv}(*FactoryManagerSrvSingleton::instance())]-\>%SN%1N (<{, }{%CS!=cache}%CN>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctr_key])
   '					, '
   %IF ( ( %S |V ) %== 'PublicAccess' ) 
    %ELSE
     'lsrv' 
    %THEN
    '(*FactoryManagerSrvSingleton::instance())' 
   %END-IF
   '->'
   %S |N %1 |N ' ('
   %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |S ) %!= 'cache' ) 
    %C |N 
   %END-FOR
   %IF ( ( %S |S ) %== 'multi factory' %&& 
     ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
    %IF ( ( %C |x ) %==  true ) 
     ', ' 
    %END-IF
    'fctr_key' 
   %END-IF
   ')'
//					)
   '				)'
//				).first;
   '			).first;'
//				(*CachedObjectsIndexFor%f_to_borland(%SN)Sngl::instance())\[f-\>second-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())\] = f;
   '			(*CachedObjectsIndexFor'
   [%f] to_borland %( %S |N )% 'Sngl::instance())[f->second->_hash (std::numeric_limits<CORBA::ULong>::max ())] = f;'
//				created_new = true;
   '			created_new = true;'
//			}
   '		}'
//			if (created_new == false) {
   '		if (created_new == false) {'
//				//если объект получили из кэша - нужно проверить, что он валиден
   '			//если объект получили из кэша - нужно проверить, что он валиден'
//				bool need_recreate = false;
   '			bool need_recreate = false;'
//				try {
   '			try {'
//					need_recreate = f-\>second-\>_non_existent ();
   '				need_recreate = f->second->_non_existent ();'
//				} catch (...) {
   '			} catch (...) {'
//					need_recreate = true;
   '				need_recreate = true;'
//				}
   '			}'
//				if (need_recreate) {
   '			if (need_recreate) {'
//					CachedObjectsFor%f_to_borland(%SN)Sngl::instance()-\>erase (f);
   '				CachedObjectsFor'
   [%f] to_borland %( %S |N )% 'Sngl::instance()->erase (f);'
//					f = CachedObjectsFor%f_to_borland(%SN)Sngl::instance()-\>insert (
   '				f = CachedObjectsFor'
   [%f] to_borland %( %S |N )% 'Sngl::instance()->insert ('
//						CachedObjectsFor%f_to_borland(%SN)::value_type(
   '					CachedObjectsFor'
   [%f] to_borland %( %S |N )% '::value_type('
//							ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%CN>)
   '						ObjectCreationIdFor'
   [%f] to_borland %( %S |N )% '('
   %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
    %C |N 
   %END-FOR
   ')'
//							, [{%SV=PublicAccess}{lsrv}(*FactoryManagerSrvSingleton::instance())]-\>%SN%1N (<{, }{%CS!=cache}%CN>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctr_key])
   '						, '
   %IF ( ( %S |V ) %== 'PublicAccess' ) 
    %ELSE
     'lsrv' 
    %THEN
    '(*FactoryManagerSrvSingleton::instance())' 
   %END-IF
   '->'
   %S |N %1 |N ' ('
   %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |S ) %!= 'cache' ) 
    %C |N 
   %END-FOR
   %IF ( ( %S |S ) %== 'multi factory' %&& 
     ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
    %IF ( ( %C |x ) %==  true ) 
     ', ' 
    %END-IF
    'fctr_key' 
   %END-IF
   ')'
//						)
   '					)'
//					).first;
   '				).first;'
//					(*CachedObjectsIndexFor%f_to_borland(%SN)Sngl::instance())\[f-\>second-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ())\] = f;
   '				(*CachedObjectsIndexFor'
   [%f] to_borland %( %S |N )% 'Sngl::instance())[f->second->_hash (std::numeric_limits<CORBA::ULong>::max ())] = f;'
//				}
   '			}'
//			}
   '		}'
//			return *f-\>second;
   '		return *f->second;'
//	][{[{<{}{%CS!=cache}{%CC}>!=0}{false}true]=false&%SS!=multi factory}
  %END-IF
  %IF ( %IF ( 
    %FOR %ITEM-CONDITION ( ( %C |S ) %!= 'cache' ) 
     ( %C |C ) 
    %END-FOR
    %!= 0 ) 
    %ELSE
      false 
    %THEN
     true 
   %END-IF
   %==  false %&& 
    ( ( %S |S ) %!= 'multi factory'  ) ) 


//Пока при получении объекта их кэша проверяет влидность этого объекта

//в последствии от этого можно будет избавиться
//			bool created_new = false; //флаг о том, что объект был создан, а не получен из кэша
   '		bool created_new = false; //флаг о том, что объект был создан, а не получен из кэша'
//			if (CachedObjectFor%f_to_borland(%SN)::instance()-\>ptr() == 0) {
   '		if (CachedObjectFor'
   [%f] to_borland %( %S |N )% '::instance()->ptr() == 0) {'
//				GUARD(s_mutex_for_%SN);
   '			GUARD(s_mutex_for_'
   %S |N ');'
//				if (CachedObjectFor%f_to_borland(%SN)::instance()-\>ptr() == 0) {
   '			if (CachedObjectFor'
   [%f] to_borland %( %S |N )% '::instance()->ptr() == 0) {'
//					*CachedObjectFor%f_to_borland(%SN)::instance() = [{%SV=PublicAccess}{lsrv}(*FactoryManagerSrvSingleton::instance())]-\>%SN%1N (<{, }{%CS!=cache}%CN>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctr_key]);
   '				*CachedObjectFor'
   [%f] to_borland %( %S |N )% '::instance() = '
   %IF ( ( %S |V ) %== 'PublicAccess' ) 
    %ELSE
     'lsrv' 
    %THEN
    '(*FactoryManagerSrvSingleton::instance())' 
   %END-IF
   '->'
   %S |N %1 |N ' ('
   %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |S ) %!= 'cache' ) 
    %C |N 
   %END-FOR
   %IF ( ( %S |S ) %== 'multi factory' %&& 
     ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
    %IF ( ( %C |x ) %==  true ) 
     ', ' 
    %END-IF
    'fctr_key' 
   %END-IF
   ');'
//					s_cached_object_hash_for_%SN = (*CachedObjectFor%f_to_borland(%SN)::instance())-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ());
   '				s_cached_object_hash_for_'
   %S |N ' = (*CachedObjectFor'
   [%f] to_borland %( %S |N )% '::instance())->_hash (std::numeric_limits<CORBA::ULong>::max ());'
//					created_new = true;
   '				created_new = true;'
//				}
   '			}'
//			}
   '		}'
//			if (created_new == false) {
   '		if (created_new == false) {'
//				//если объект получили из кэша - нужно проверить, что он валиден
   '			//если объект получили из кэша - нужно проверить, что он валиден'
//				bool need_recreate = false;
   '			bool need_recreate = false;'
//				try {
   '			try {'
//					need_recreate = CachedObjectFor%f_to_borland(%SN)::instance()-\>ptr()-\>_non_existent ();
   '				need_recreate = CachedObjectFor'
   [%f] to_borland %( %S |N )% '::instance()->ptr()->_non_existent ();'
//				} catch (...) {
   '			} catch (...) {'
//					need_recreate = true;
   '				need_recreate = true;'
//				}
   '			}'
//				if (need_recreate) {
   '			if (need_recreate) {'
//					GUARD(s_mutex_for_%SN);
   '				GUARD(s_mutex_for_'
   %S |N ');'
//					*CachedObjectFor%f_to_borland(%SN)::instance() = 0;
   '				*CachedObjectFor'
   [%f] to_borland %( %S |N )% '::instance() = 0;'
//					*CachedObjectFor%f_to_borland(%SN)::instance() = [{%SV=PublicAccess}{lsrv}(*FactoryManagerSrvSingleton::instance())]-\>%SN%1N (<{, }{%CS!=cache}%CN>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctr_key]);
   '				*CachedObjectFor'
   [%f] to_borland %( %S |N )% '::instance() = '
   %IF ( ( %S |V ) %== 'PublicAccess' ) 
    %ELSE
     'lsrv' 
    %THEN
    '(*FactoryManagerSrvSingleton::instance())' 
   %END-IF
   '->'
   %S |N %1 |N ' ('
   %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
    %ITEM-CONDITION ( ( %C |S ) %!= 'cache' ) 
    %C |N 
   %END-FOR
   %IF ( ( %S |S ) %== 'multi factory' %&& 
     ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
    %IF ( ( %C |x ) %==  true ) 
     ', ' 
    %END-IF
    'fctr_key' 
   %END-IF
   ');'
//					s_cached_object_hash_for_%SN = (*CachedObjectFor%f_to_borland(%SN)::instance())-\>_hash (std::numeric_limits\<CORBA::ULong\>::max ());
   '				s_cached_object_hash_for_'
   %S |N ' = (*CachedObjectFor'
   [%f] to_borland %( %S |N )% '::instance())->_hash (std::numeric_limits<CORBA::ULong>::max ());'
//				}
   '			}'
//			}
   '		}'
//			return *CachedObjectFor%f_to_borland(%SN)::instance()-\>ptr();
   '		return *CachedObjectFor'
   [%f] to_borland %( %S |N )% '::instance()->ptr();'
//	]]	} catch (CORBA::TRANSIENT& ) {
  %END-IF
 %END-IF
 '	} catch (CORBA::TRANSIENT& ) {'
//			if (s_renew_mode) {
 '		if (s_renew_mode) {'
//				s_renew_mode = false;
 '			s_renew_mode = false;'
//				LOG_W (("%{INT}NFactoryManagerSrv is in invalid (inactive) state"));
 '			LOG_W (("'
 ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrv is in invalid (inactive) state"));'
//				throw CoreSrv::NoActiveFactory ();
 '			throw CoreSrv::NoActiveFactory ();'
//			}
 '		}'
//			GUARD (s_init_mutex);
 '		GUARD (s_init_mutex);'
//			LOG_D (("Try to renew %{INT}NFactoryManagerSrv"));
 '		LOG_D (("Try to renew '
 ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrv"));'
//			
 '		'
//			s_renew_mode = true;
 '		s_renew_mode = true;'
//			(*FactoryManagerSrvSingleton::instance()) = 0;
 '		(*FactoryManagerSrvSingleton::instance()) = 0;'
//			%{INT}N[{%Ss!=cached&%Ss!=const,cached}{&}_var] ret = %SN%1N (<{, }{%CS!=cache}%CN>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctr_key]);
 '		'
 ( get_global_var ( 'INT' ) |N ) %IF ( ( %S |s ) %!= 'cached' %&& 
   ( ( %S |s ) %!= 'const,cached'  ) ) 
  %ELSE
   '&' 
  %THEN
  '_var' 
 %END-IF
 ' ret = '
 %S |N %1 |N ' ('
 %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
  %ITEM-CONDITION ( ( %C |S ) %!= 'cache' ) 
  %C |N 
 %END-FOR
 %IF ( ( %S |S ) %== 'multi factory' %&& 
   ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
  %IF ( ( %C |x ) %==  true ) 
   ', ' 
  %END-IF
  'fctr_key' 
 %END-IF
 ');'
//			s_renew_mode = false;
 '		s_renew_mode = false;'
//			
 '		'
//			return ret[{%Ss!=cached&%Ss!=const,cached}._retn()];
 '		return ret'
 %IF ( ( %S |s ) %!= 'cached' %&& 
   ( ( %S |s ) %!= 'const,cached'  ) ) 
  '._retn()' 
 %END-IF
 ';'
//		}
 '	}'
//	}
 '}'
//#UC END# *47022CB8034Bfor471F1E100186*
; // srv_factory_cpp


// генератор классов, интерфейсов на java (.java)
//+ java
implementation @ :: <<ServerInterface>> <<factory>> ;
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for471F1E100186*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	[{%S{const_type}=combo}{%f_srv_factory_java(%S)}%f_srv_factory_java(%S)
 %IF ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) 
  %ELSE
   [%f] srv_factory_java %( %S )% 
  %THEN
  [%f] srv_factory_java %( %S )% 
//	

//	%f_srv_factory_java(%S,"_ro")]
  [%f] srv_factory_java %( %S %, '_ro' )% 
 %END-IF

//f _srv_inherited_factory_java
; // java

end. // :: <<ServerInterface>> <<factory>> ;

: srv_inherited_factory_java OBJECT IN %S
//	#	try {
 out_indent '	try {'
//	#		%f_type(%{FACTORY_PARENT}) ret = %f_type(%{FACTORY_PARENT})FactoryManager.%{FACTORY_PARENT}%f_fctr_mng_get_instance_name() ().%f_to_java(%SN) (<{, }%f_to_java(%CN)>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctrKey]);
 out_indent '		'
 [%f] type %( ( get_global_var ( 'FACTORY_PARENT' ) ) )% ' ret = '
 [%f] type %( ( get_global_var ( 'FACTORY_PARENT' ) ) )% 'FactoryManager.'
 ( get_global_var ( 'FACTORY_PARENT' ) %f fctr_mng_get_instance_name %( )% ) ' ().'
 [%f] to_java %( %S |N )% ' ('
 %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
  [%f] to_java %( %C |N )% 
 %END-FOR
 %IF ( ( %S |S ) %== 'multi factory' %&& 
   ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
  %IF ( ( %C |x ) %==  true ) 
   ', ' 
  %END-IF
  'fctrKey' 
 %END-IF
 ');'
//	[{%{INT}S=LocalInterface&%f_use_as_srv_type(%{INT}%R)=true}{#		if (ret instanceof %f_type(%{INT})) \{
 %IF ( ( ( get_global_var ( 'INT' ) |S ) ) %== 'LocalInterface' %&& 
   ( ( [%f] use_as_srv_type %( ( get_global_var ( 'INT' )  ->R ) )% ) %==  true  ) ) 
  %ELSE
   out_indent '		if (ret instanceof '
   [%f] type %( ( get_global_var ( 'INT' ) ) )% ') {'
//	#			return (%f_type(%{INT})) ret;}#		org.omg.PortableServer.Servant srv = %{INT}<{}{%PM=Library::Category|%PM=ServerLibrary::Category}{%P}%f_dump_java_package(%P).%PN.LibHomeFactory>.get().getOrbFacet().getRootPoa().reference_to_servant (ret);
   out_indent '			return ('
   [%f] type %( ( get_global_var ( 'INT' ) ) )% ') ret;' 
  %THEN
  out_indent '		org.omg.PortableServer.Servant srv = '
  ( get_global_var ( 'INT' ) ) 
  %FOR %ITEM-CONDITION ( ( %P |M ) %== 'Library::Category' %|| 
    ( ( %P |M ) %== 'ServerLibrary::Category'  ) ) 
   ( %P ) 
   [%f] dump_java_package %( %P )% '.'
   %P |N '.LibHomeFactory' 
  %END-FOR
  '.get().getOrbFacet().getRootPoa().reference_to_servant (ret);'
//	#		if (srv instanceof %f_type(%{INT})) {
  out_indent '		if (srv instanceof '
  [%f] type %( ( get_global_var ( 'INT' ) ) )% ') {'
//	#			return (%f_type(%{INT})) srv;]
  out_indent '			return ('
  [%f] type %( ( get_global_var ( 'INT' ) ) )% ') srv;' 
 %END-IF
//	#		} else {
 out_indent '		} else {'
//	#			throw new NoActiveFactory (%{INT}["%P%PN::%PN::%SNFactory"]);
 out_indent '			throw new NoActiveFactory ('
 ( get_global_var ( 'INT' ) ) %IF-NOT-EMPTY
  %P ->P |N  '::'
  %P |N '::'
  %S |N 'Factory' 
 %END-IF
 ');'
//	#		}
 out_indent '		}'
//	#	} catch (java.lang.Throwable e) {
 out_indent '	} catch (java.lang.Throwable e) {'
//	#		throw new NoActiveFactory (e);
 out_indent '		throw new NoActiveFactory (e);'
//	#	}
 out_indent '	}'
//	

//f _srv_factory_java
; // srv_inherited_factory_java

: srv_factory_java OBJECT IN %S
//	#%t_visibility(%S,"%XU")static %t_ret(%{INT},"%Ss") %SN%1N (<{, }%f_arg_full_decl(%C)>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]%{INT}%f_dump_switch_arg_type() fctrKey]) throws NoActiveFactory[{%SS=multi factory}, UnknownFactoryKey]<, %f_type(%E)> {
 out_indent [%t] visibility %( %S %, %X |U )% 'static '
 [%t] ret %( ( get_global_var ( 'INT' ) ) %, %S |s )% ' '
 %S |N %1 |N ' ('
 %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
  [%f] arg_full_decl %( %C )% 
 %END-FOR
 %IF ( ( %S |S ) %== 'multi factory' %&& 
   ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
  %IF ( ( %C |x ) %==  true ) 
   ', ' 
  %END-IF
  ( get_global_var ( 'INT' ) %f dump_switch_arg_type %( )% ) ' fctrKey' 
 %END-IF
 ') throws NoActiveFactory'
 %IF ( ( %S |S ) %== 'multi factory' ) 
  ', UnknownFactoryKey' 
 %END-IF
 %FOR ', '
  [%f] type %( %E )% 
 %END-FOR
 ' {'
//	[{%{INT}U=%{FACTORY_PARENT}U}{%f_srv_inherited_factory_java(%S)}#	if (FactoryManagerSrvSingleton.getInstance() == null) {
 %IF ( ( ( get_global_var ( 'INT' ) |U ) ) %== ( ( get_global_var ( 'FACTORY_PARENT' ) |U ) ) ) 
  %ELSE
   [%f] srv_inherited_factory_java %( %S )% 
  %THEN
  out_indent '	if (FactoryManagerSrvSingleton.getInstance() == null) {'
//	#		synchronized (FactoryManagerSrvSingleton.class) {
  out_indent '		synchronized (FactoryManagerSrvSingleton.class) {'
//	#			try {
  out_indent '			try {'
//	#				org.omg.CORBA.Object obj = ru.garant.shared.CoreSrv.cos_naming_op.resolvePath (
  out_indent '				org.omg.CORBA.Object obj = ru.garant.shared.CoreSrv.cos_naming_op.resolvePath ('
//	#					LibHomeFactory.get().getOrbFacet().getNsRoot(), "%f_full_name(%{INT})"
  out_indent '					LibHomeFactory.get().getOrbFacet().getNsRoot(), "'
  [%f] full_name %( ( get_global_var ( 'INT' ) ) )% 
//	#				);
  out_indent '				);'
//	#				FactoryManagerSrvSingleton.setInstance(%{INT}NFactoryManagerSrvHelper.narrow (obj));
  out_indent '				FactoryManagerSrvSingleton.setInstance('
  ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrvHelper.narrow (obj));'
//	#			} catch (java.lang.Exception ex) {
  out_indent '			} catch (java.lang.Exception ex) {'
//	#				Logs.LOG_SEX (ex);
  out_indent '				Logs.LOG_SEX (ex);'
//	#			}
  out_indent '			}'
//	#			if (FactoryManagerSrvSingleton.getInstance() == null) {
  out_indent '			if (FactoryManagerSrvSingleton.getInstance() == null) {'
//	#				throw new ru.garant.shared.CoreSrv.NoActiveFactory ();
  out_indent '				throw new ru.garant.shared.CoreSrv.NoActiveFactory ();'
//	#			}
  out_indent '			}'
//	#		}
  out_indent '		}'
//	#	}
  out_indent '	}'
//	[{%SV!=PublicAccess}
  %IF ( ( %S |V ) %!= 'PublicAccess' ) 

//	#	%f_type(%{INT})FactoryManagerLocal lsrv = null;
   out_indent '	'
   [%f] type %( ( get_global_var ( 'INT' ) ) )% 'FactoryManagerLocal lsrv = null;'
//	#	try {
   out_indent '	try {'
//	#		org.omg.PortableServer.Servant srv = LibHomeFactory::get().getOrbFacet().getRootPoa().reference_to_servant (FactoryManagerSrvSingleton.getInstance());
   out_indent '		org.omg.PortableServer.Servant srv = LibHomeFactory::get().getOrbFacet().getRootPoa().reference_to_servant (FactoryManagerSrvSingleton.getInstance());'
//	#		lsrv = (%f_type(%{INT})FactoryManagerLocal)srv;
   out_indent '		lsrv = ('
   [%f] type %( ( get_global_var ( 'INT' ) ) )% 'FactoryManagerLocal)srv;'
//	#	} catch (org.omg.PortableServer.POA.WrongAdapter ex) {
   out_indent '	} catch (org.omg.PortableServer.POA.WrongAdapter ex) {'
//	#		Logs.LOG_SEX (ex);
   out_indent '		Logs.LOG_SEX (ex);'
//	#	}
   out_indent '	}'
//	#	if (lsrv == null) {
   out_indent '	if (lsrv == null) {'
//	#		throw new ru.garant.shared.CoreSrv.NoActiveFactory ();
   out_indent '		throw new ru.garant.shared.CoreSrv.NoActiveFactory ();'
//	#	}
   out_indent '	}'
//	][{%Ss!=cached&%Ss!=const,cached}#	return [{%SV=PublicAccess}{lsrv}FactoryManagerSrvSingleton.getInstance()].%SN%1N (<{, }%f_to_java(%CN)>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctrKey]);
  %END-IF
  %IF ( ( %S |s ) %!= 'cached' %&& 
    ( ( %S |s ) %!= 'const,cached'  ) ) 
   out_indent '	return '
   %IF ( ( %S |V ) %== 'PublicAccess' ) 
    %ELSE
     'lsrv' 
    %THEN
    'FactoryManagerSrvSingleton.getInstance()' 
   %END-IF
   '.'
   %S |N %1 |N ' ('
   %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
    [%f] to_java %( %C |N )% 
   %END-FOR
   %IF ( ( %S |S ) %== 'multi factory' %&& 
     ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
    %IF ( ( %C |x ) %==  true ) 
     ', ' 
    %END-IF
    'fctrKey' 
   %END-IF
   ');'
//	][{%Ss=cached|%Ss=const,cached}
  %END-IF
  %IF ( ( %S |s ) %== 'cached' %|| 
    ( ( %S |s ) %== 'const,cached'  ) ) 

//	#	try {
   out_indent '	try {'
//	[{%Cx=true|%SS=multi factory}\
   %IF ( ( %C |x ) %==  true %|| 
     ( ( %S |S ) %== 'multi factory'  ) ) 

//Закоментированно, т.к нужно научиться чистить клиентский кэш
//	#		synchronized (CachedObjectsFor%f_to_borland(%SN)Sngl.class) {
    out_indent '		synchronized (CachedObjectsFor'
    [%f] to_borland %( %S |N )% 'Sngl.class) {'
//	#			boolean createdNew = false;
    out_indent '			boolean createdNew = false;'
//	#			ObjectCreationIdFor%f_to_borland(%SN) key = new ObjectCreationIdFor%f_to_borland(%SN)(<{, }{"%CS"!="nokey"}%f_to_java(%CN)>);
    out_indent '			ObjectCreationIdFor'
    [%f] to_borland %( %S |N )% ' key = new ObjectCreationIdFor'
    [%f] to_borland %( %S |N )% '('
    %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
     %ITEM-CONDITION ( ( %C |S ) %!= 'nokey' ) 
     [%f] to_java %( %C |N )% 
    %END-FOR
    ');'
//	#			%t_ret(%{INT},"%Ss") ret = CachedObjectsFor%f_to_borland(%SN)Sngl.instance().get (key);
    out_indent '			'
    [%t] ret %( ( get_global_var ( 'INT' ) ) %, %S |s )% ' ret = CachedObjectsFor'
    [%f] to_borland %( %S |N )% 'Sngl.instance().get (key);'
//	#			if (ret == null) {
    out_indent '			if (ret == null) {'
//	#				ret = [{%SV=PublicAccess}{lsrv}FactoryManagerSrvSingleton.getInstance()].%SN%1N (<{, }%f_to_java(%CN)>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctrKey]);
    out_indent '				ret = '
    %IF ( ( %S |V ) %== 'PublicAccess' ) 
     %ELSE
      'lsrv' 
     %THEN
     'FactoryManagerSrvSingleton.getInstance()' 
    %END-IF
    '.'
    %S |N %1 |N ' ('
    %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
     [%f] to_java %( %C |N )% 
    %END-FOR
    %IF ( ( %S |S ) %== 'multi factory' %&& 
      ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
     %IF ( ( %C |x ) %==  true ) 
      ', ' 
     %END-IF
     'fctrKey' 
    %END-IF
    ');'
//	#				CachedObjectsFor%f_to_borland(%SN)Sngl.instance().put (key, ret);
    out_indent '				CachedObjectsFor'
    [%f] to_borland %( %S |N )% 'Sngl.instance().put (key, ret);'
//	#				CachedObjectsIndexFor%f_to_borland(%SN)Sngl.instance().put (ret._hash (Integer.MAX_VALUE), key);
    out_indent '				CachedObjectsIndexFor'
    [%f] to_borland %( %S |N )% 'Sngl.instance().put (ret._hash (Integer.MAX_VALUE), key);'
//	#				createdNew = true;
    out_indent '				createdNew = true;'
//	#			}
    out_indent '			}'
//	#			if (createdNew == false) {
    out_indent '			if (createdNew == false) {'
//	#				boolean needRecreate = false;
    out_indent '				boolean needRecreate = false;'
//	#				try {
    out_indent '				try {'
//	#					needRecreate = ret._non_existent ();
    out_indent '					needRecreate = ret._non_existent ();'
//	#				} catch (java.lang.Throwable ex) {
    out_indent '				} catch (java.lang.Throwable ex) {'
//	#					needRecreate = true;
    out_indent '					needRecreate = true;'
//	#				}
    out_indent '				}'
//	#				if (needRecreate) {
    out_indent '				if (needRecreate) {'
//	#					CachedObjectsFor%f_to_borland(%SN)Sngl.instance().remove (key);
    out_indent '					CachedObjectsFor'
    [%f] to_borland %( %S |N )% 'Sngl.instance().remove (key);'
//	#					ret = [{%SV=PublicAccess}{lsrv}FactoryManagerSrvSingleton.getInstance()].%SN%1N (<{, }%f_to_java(%CN)>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctrKey]);
    out_indent '					ret = '
    %IF ( ( %S |V ) %== 'PublicAccess' ) 
     %ELSE
      'lsrv' 
     %THEN
     'FactoryManagerSrvSingleton.getInstance()' 
    %END-IF
    '.'
    %S |N %1 |N ' ('
    %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
     [%f] to_java %( %C |N )% 
    %END-FOR
    %IF ( ( %S |S ) %== 'multi factory' %&& 
      ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
     %IF ( ( %C |x ) %==  true ) 
      ', ' 
     %END-IF
     'fctrKey' 
    %END-IF
    ');'
//	#					CachedObjectsFor%f_to_borland(%SN)Sngl.instance().put (key, ret);
    out_indent '					CachedObjectsFor'
    [%f] to_borland %( %S |N )% 'Sngl.instance().put (key, ret);'
//	#					CachedObjectsIndexFor%f_to_borland(%SN)Sngl.instance().put (ret._hash (Integer.MAX_VALUE), key);
    out_indent '					CachedObjectsIndexFor'
    [%f] to_borland %( %S |N )% 'Sngl.instance().put (ret._hash (Integer.MAX_VALUE), key);'
//	#				}
    out_indent '				}'
//	#			}
    out_indent '			}'
//	#			return ret;
    out_indent '			return ret;'
//	][{%Cx=false&%SS!=multi factory}
   %END-IF
   %IF ( ( %C |x ) %==  false %&& 
     ( ( %S |S ) %!= 'multi factory'  ) ) 


//Закоментированно, т.к нужно научиться чистить клиентский кэш
//	#		synchronized (CachedObjectFor%f_to_borland(%SN).class) {
    out_indent '		synchronized (CachedObjectFor'
    [%f] to_borland %( %S |N )% '.class) {'
//	#			boolean createdNew = false;
    out_indent '			boolean createdNew = false;'
//	#			if (CachedObjectFor%f_to_borland(%SN).instance() == null) {
    out_indent '			if (CachedObjectFor'
    [%f] to_borland %( %S |N )% '.instance() == null) {'
//	#				CachedObjectFor%f_to_borland(%SN).setInstance([{%SV=PublicAccess}{lsrv}FactoryManagerSrvSingleton.getInstance()].%SN%1N (<{, }%f_to_java(%CN)>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctrKey]));
    out_indent '				CachedObjectFor'
    [%f] to_borland %( %S |N )% '.setInstance('
    %IF ( ( %S |V ) %== 'PublicAccess' ) 
     %ELSE
      'lsrv' 
     %THEN
     'FactoryManagerSrvSingleton.getInstance()' 
    %END-IF
    '.'
    %S |N %1 |N ' ('
    %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
     [%f] to_java %( %C |N )% 
    %END-FOR
    %IF ( ( %S |S ) %== 'multi factory' %&& 
      ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
     %IF ( ( %C |x ) %==  true ) 
      ', ' 
     %END-IF
     'fctrKey' 
    %END-IF
    '));'
//	#				cachedObjectHashFor%f_to_borland(%SN)_ = new Integer (CachedObjectFor%f_to_borland(%SN).instance()._hash (Integer.MAX_VALUE));
    out_indent '				cachedObjectHashFor'
    [%f] to_borland %( %S |N )% '_ = new Integer (CachedObjectFor'
    [%f] to_borland %( %S |N )% '.instance()._hash (Integer.MAX_VALUE));'
//	#				createdNew = true;
    out_indent '				createdNew = true;'
//	#			}
    out_indent '			}'
//	#			if (createdNew == false) {
    out_indent '			if (createdNew == false) {'
//	#				boolean needRecreate = false;
    out_indent '				boolean needRecreate = false;'
//	#				try {
    out_indent '				try {'
//	#					needRecreate = CachedObjectFor%f_to_borland(%SN).instance()._non_existent ();
    out_indent '					needRecreate = CachedObjectFor'
    [%f] to_borland %( %S |N )% '.instance()._non_existent ();'
//	#				} catch (java.lang.Throwable ex) {
    out_indent '				} catch (java.lang.Throwable ex) {'
//	#					needRecreate = true;
    out_indent '					needRecreate = true;'
//	#				}
    out_indent '				}'
//	#				if (needRecreate) {
    out_indent '				if (needRecreate) {'
//	#					CachedObjectFor%f_to_borland(%SN).setInstance(null);
    out_indent '					CachedObjectFor'
    [%f] to_borland %( %S |N )% '.setInstance(null);'
//	#					CachedObjectFor%f_to_borland(%SN).setInstance([{%SV=PublicAccess}{lsrv}FactoryManagerSrvSingleton.getInstance()].%SN%1N (<{, }%f_to_java(%CN)>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctrKey]));
    out_indent '					CachedObjectFor'
    [%f] to_borland %( %S |N )% '.setInstance('
    %IF ( ( %S |V ) %== 'PublicAccess' ) 
     %ELSE
      'lsrv' 
     %THEN
     'FactoryManagerSrvSingleton.getInstance()' 
    %END-IF
    '.'
    %S |N %1 |N ' ('
    %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
     [%f] to_java %( %C |N )% 
    %END-FOR
    %IF ( ( %S |S ) %== 'multi factory' %&& 
      ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
     %IF ( ( %C |x ) %==  true ) 
      ', ' 
     %END-IF
     'fctrKey' 
    %END-IF
    '));'
//	#					cachedObjectHashFor%f_to_borland(%SN)_ = new Integer (CachedObjectFor%f_to_borland(%SN).instance()._hash (Integer.MAX_VALUE));
    out_indent '					cachedObjectHashFor'
    [%f] to_borland %( %S |N )% '_ = new Integer (CachedObjectFor'
    [%f] to_borland %( %S |N )% '.instance()._hash (Integer.MAX_VALUE));'
//	#				}
    out_indent '				}'
//	#			}
    out_indent '			}'
//	#			return CachedObjectFor%f_to_borland(%SN).instance();
    out_indent '			return CachedObjectFor'
    [%f] to_borland %( %S |N )% '.instance();'
//	]\
   %END-IF
//	#		}
   out_indent '		}'
//	#	} catch (org.omg.CORBA.SystemException ex) {
   out_indent '	} catch (org.omg.CORBA.SystemException ex) {'
//	#		if (sRenewMode) {
   out_indent '		if (sRenewMode) {'
//	#			sRenewMode = false;
   out_indent '			sRenewMode = false;'
//	#			Logs.LOG_E ("%{INT}NFactoryManagerSrv is in invalid (inactive) state");
   out_indent '			Logs.LOG_E ("'
   ( get_global_var ( 'INT' ) |N ) 'FactoryManagerSrv is in invalid (inactive) state");'
//	#			throw new ru.garant.shared.CoreSrv.NoActiveFactory ();
   out_indent '			throw new ru.garant.shared.CoreSrv.NoActiveFactory ();'
//	#		}
   out_indent '		}'
//	#		synchronized (FactoryManagerSrvSingleton.class) {
   out_indent '		synchronized (FactoryManagerSrvSingleton.class) {'
//	#			sRenewMode = true;
   out_indent '			sRenewMode = true;'
//	#			FactoryManagerSrvSingleton.setInstance (null);
   out_indent '			FactoryManagerSrvSingleton.setInstance (null);'
//	#			%t_ret(%{INT},"%Ss") ret = %SN%1N (<{, }%f_to_java(%CN)>[{%SS=multi factory&%S{transparent multy}=false}[{%Cx=true}, ]fctrKey]);
   out_indent '			'
   [%t] ret %( ( get_global_var ( 'INT' ) ) %, %S |s )% ' ret = '
   %S |N %1 |N ' ('
   %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
    [%f] to_java %( %C |N )% 
   %END-FOR
   %IF ( ( %S |S ) %== 'multi factory' %&& 
     ( ( %S get_up ( 'transparent multy' ) ) %==  false  ) ) 
    %IF ( ( %C |x ) %==  true ) 
     ', ' 
    %END-IF
    'fctrKey' 
   %END-IF
   ');'
//	#			sRenewMode = false;
   out_indent '			sRenewMode = false;'
//	

//	#			return ret;
   out_indent '			return ret;'
//	#		}
   out_indent '		}'
//	#	}
   out_indent '	}'
//	]]#}
  %END-IF
 %END-IF
 out_indent '}'
//#UC END# *470321950119for471F1E100186*
; // srv_factory_java


// Функции стереотипа
//%f _st_space_key
implementation @ :: <<ServerInterface>> <<factory>> ;
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа ServerFactoryOperationInternal::Class
// генерит реализацию экспортируемой фабрики
//%f _dump_as_exported_cpp
; // st_space_key

: dump_as_exported_cpp OBJECT IN %S
//#UC START# *4AE7F60D03DAfor471F1E100186*
//#UC END# *4AE7F60D03DAfor471F1E100186*
; // dump_as_exported_cpp


// реализация абстрактного стереотипа ServerFactoryOperationInternal::Class
// генерит реализацию неэкспортируемой фабрики
//%f _dump_as_non_exported_cpp
: dump_as_non_exported_cpp OBJECT IN %S
//#UC START# *4AE7F6490336for471F1E100186*
//#UC END# *4AE7F6490336for471F1E100186*
; // dump_as_non_exported_cpp


// перекрытие базового стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for471F1E100186*
//c                              {}
//r {<{}{%PS=ServerLibrary}{C}>!=0&%f_to_lower(%PN)=%f_to_lower(%SN)}: {имя %SS не должно совпадать с именем %P%SS}
//r {%Ss=synchro}:                                                     {синхро-фабрики не могут быть использованные в серверных интерфейсах}
//#UC END# *4704C0E30186for471F1E100186*
; // constraint


// перекрытие базового стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor471F1E100186*
//	mng
 'mng'
//#UC END# *4705CBD6003Efor471F1E100186*
; // wiki_child_kind


// Вложенные стереотипы
//: ServerInterface::Class::factory::Operation::Parameter
end. // :: <<ServerInterface>> <<factory>> ;

implementation @ :: <<ServerInterface>> <<factory>> Parameter ;
//? Параметр
//= ServerFacet::Class::Operation::Parameter

// Параметры стереотипа
//Y code_param.gif
//L code_param

// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'



//: ServerInterface::Class::multi factory::Operation
; // st_space_key

end. // :: <<ServerInterface>> <<factory>> Parameter ;

implementation @ :: <<ServerInterface>> <<"multi factory">> ;
//? Фабрика (множественная)
//? Будет создан абстрактный интерфейс фабрики, который будут реализовывать конкретные фабрики (по одной на каждый сервант), создающие соответствующие серванты. Конкретные фабрики мугут инициализироваться своими специфичными параметрами. Созданные конкретные фабрики будут регистрироваться в менеджере фабрик. Последний осуществляет выбор нужной "активной" фабрики при получении запроса на создание экземпляра объекта. Для МНОЖЕСТВЕННОЙ фабрики - активными являются ВСЕ зарегистрированные фабрики, выбор конкретной осущестьвляеться по ключу - дополнительному параметру.
//= Interface::Class::multi factory::Operation
//= ServerFactoryOperationInternal::Class

// Параметры стереотипа
//m f
// - не может быть реализован/иметь перекрытую реализацию

// Генераторы
// генератор idl спецификаций (.idl)
//+ idl
<<generator>> idl OBJECT IN %S
//#UC START# *47022BBE0261for471F1E81034B*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	[{%S{const_type}=combo}{%f_srv_m_factory_idl(%S)}%f_srv_m_factory_idl(%S)
 %IF ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) 
  %ELSE
   [%f] srv_m_factory_idl %( %S )% 
  %THEN
  [%f] srv_m_factory_idl %( %S )% 
//	

//	%f_srv_m_factory_idl(%S,"_ro")]
  [%f] srv_m_factory_idl %( %S %, '_ro' )% 
 %END-IF

//f _srv_m_factory_idl
; // idl

end. // :: <<ServerInterface>> <<"multi factory">> ;

: srv_m_factory_idl OBJECT IN %S
//	#%t_ret(%{INT},"%Ss") %SN%1N (<{, }{}%CX>[{%S{transparent multy}=false}[{%Cx=true}], %{INT}%f_dump_switch_arg_type() key])
 out_indent [%t] ret %( ( get_global_var ( 'INT' ) ) %, %S |s )% ' '
 %S |N %1 |N ' ('
 %FOR %ITEM-SEPARATOR ', ' ; // %ITEM-SEPARATOR 
  %C |X 
 %END-FOR
 %IF ( ( %S get_up ( 'transparent multy' ) ) %==  false ) 
  %IF ( ( %C |x ) %==  true ) 
  %END-IF
  ', '
  ( get_global_var ( 'INT' ) %f dump_switch_arg_type %( )% ) ' key' 
 %END-IF
 ')'
//	#	raises (CoreSrv::[{%S{transparent multy}=false}{NoActiveFactory}UnknownFactoryKey]<, %f_type(%E)>);
 out_indent '	raises (CoreSrv::'
 %IF ( ( %S get_up ( 'transparent multy' ) ) %==  false ) 
  %ELSE
   'NoActiveFactory' 
  %THEN
  'UnknownFactoryKey' 
 %END-IF
 %FOR ', '
  [%f] type %( %E )% 
 %END-FOR
 ');'
//#UC END# *47022BBE0261for471F1E81034B*
; // srv_m_factory_idl


// генератор заголовочных файлов C++ (.h)
//+ h
implementation @ :: <<ServerInterface>> <<"multi factory">> ;
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor471F1E81034B*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	[{%S%f_is_exported()=true}{%P%f_dump_multi_factory_operation_h(%S)}[{%S{const_type}=combo}{%f_srv_factory_h(%S)}%f_srv_factory_h(%S)
 %IF ( ( %S %f is_exported %( )% ) %==  true ) 
  %ELSE
   %P %f dump_multi_factory_operation_h %( %S )% 
  %THEN
  %IF ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) 
   %ELSE
    [%f] srv_factory_h %( %S )% 
   %THEN
   [%f] srv_factory_h %( %S )% 
//	

//	%f_srv_factory_h(%S,"_ro")]]
   [%f] srv_factory_h %( %S %, '_ro' )% 
  %END-IF
 %END-IF
//#UC END# *47022C88029Ffor471F1E81034B*
; // h


// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor471F1E81034B*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	[{%S%f_is_exported()=true}{%P%f_dump_multi_factory_operation_cpp(%S)}[{%S{const_type}=combo}{%f_srv_factory_cpp(%S)}%f_srv_factory_cpp(%S)
 %IF ( ( %S %f is_exported %( )% ) %==  true ) 
  %ELSE
   %P %f dump_multi_factory_operation_cpp %( %S )% 
  %THEN
  %IF ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) 
   %ELSE
    [%f] srv_factory_cpp %( %S )% 
   %THEN
   [%f] srv_factory_cpp %( %S )% 
//	

//	%f_srv_factory_cpp(%S,"_ro")]]
   [%f] srv_factory_cpp %( %S %, '_ro' )% 
  %END-IF
 %END-IF
//#UC END# *47022CB8034Bfor471F1E81034B*
; // cpp


// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for471F1E81034B*
//	%f_docs(%S)\
 [%f] docs %( %S )% 
//	[{%S{const_type}=combo}{%f_srv_factory_java(%S)}%f_srv_factory_java(%S)
 %IF ( ( %S get_up ( 'const_type' ) ) %== 'combo' ) 
  %ELSE
   [%f] srv_factory_java %( %S )% 
  %THEN
  [%f] srv_factory_java %( %S )% 
//	

//	%f_srv_factory_java(%S,"_ro")]
  [%f] srv_factory_java %( %S %, '_ro' )% 
 %END-IF
//#UC END# *470321950119for471F1E81034B*
; // java


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа ServerFactoryOperationInternal::Class
// генерит реализацию экспортируемой фабрики
//%f _dump_as_exported_cpp
; // st_space_key

: dump_as_exported_cpp OBJECT IN %S
//#UC START# *4AE7F60D03DAfor471F1E81034B*
//#UC END# *4AE7F60D03DAfor471F1E81034B*
; // dump_as_exported_cpp


// реализация абстрактного стереотипа ServerFactoryOperationInternal::Class
// генерит реализацию неэкспортируемой фабрики
//%f _dump_as_non_exported_cpp
: dump_as_non_exported_cpp OBJECT IN %S
//#UC START# *4AE7F6490336for471F1E81034B*
//#UC END# *4AE7F6490336for471F1E81034B*
; // dump_as_non_exported_cpp


// перекрытие базового стереотипа Документация::MDAGenerator
// проверка ограничений накладываемых на элемент
//%t _constraint
<<transformator>> constraint OBJECT IN %S
//#UC START# *4704C0E30186for471F1E81034B*
//c                              {}
//r {<{}{%PS=ServerLibrary}{C}>!=0&%f_to_lower(%PN)=%f_to_lower(%SN)}: {имя %SS не должно совпадать с именем %P%SS}
//r {%Ss=synchro}:                                                     {синхро-фабрики не могут быть использованные в серверных интерфейсах}
//#UC END# *4704C0E30186for471F1E81034B*
; // constraint


// перекрытие базового стереотипа Документация::MDAGenerator
// выводит описание элемента (операция, атрибут) в wiki
//%f _wiki_child_kind
: wiki_child_kind OBJECT IN %S
//#UC START# *4705CBD6003Efor471F1E81034B*
//	mng
 'mng'
//#UC END# *4705CBD6003Efor471F1E81034B*
; // wiki_child_kind


// Вложенные стереотипы
//: ServerInterface::Class::multi factory::Operation::Parameter
end. // :: <<ServerInterface>> <<"multi factory">> ;

implementation @ :: <<ServerInterface>> <<"multi factory">> Parameter ;
//? Параметр
//= ServerFacet::Class::Operation::Parameter

// Параметры стереотипа
//Y code_param.gif
//L code_param

// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'



//: ServerInterface::Class::factory switch::Attribute
; // st_space_key

end. // :: <<ServerInterface>> <<"multi factory">> Parameter ;

implementation @ :: <<ServerInterface>> <<"factory switch">> ;
//? Селектор мультифабрики
//? Определяет тип селектора и допустимые значения, в качестве селектора могут выступать все простые типы и перечисления (Enum).
//= Interface::Class::factory switch::Attribute

// Генераторы
// Генерация модели в MDKnow
//+ wiki
<<generator>> wiki OBJECT IN %S
//#UC START# *46E6D4BB0339for47B133E102FA*
//#UC END# *46E6D4BB0339for47B133E102FA*
; // wiki


// генератор idl спецификаций (.idl)
//+ idl
<<generator>> idl OBJECT IN %S
//#UC START# *47022BBE0261for47B133E102FA*
//#UC END# *47022BBE0261for47B133E102FA*
; // idl


// генератор idl спецификаций для AMI (.idl)
//+ idl_ami
<<generator>> idl_ami OBJECT IN %S
//#UC START# *47022C0F01E4for47B133E102FA*
//#UC END# *47022C0F01E4for47B133E102FA*
; // idl_ami


// генератор заголовочных файлов C++ (.h)
//+ h
<<generator>> h OBJECT IN %S
//#UC START# *47022C88029Ffor47B133E102FA*
//#UC END# *47022C88029Ffor47B133E102FA*
; // h


// генератор файлов реализации C++ (.cpp)
//+ cpp
<<generator>> cpp OBJECT IN %S
//#UC START# *47022CB8034Bfor47B133E102FA*
//#UC END# *47022CB8034Bfor47B133E102FA*
; // cpp


// генератор inline файлов реализации C++ (.i.h)
//+ i.h
<<generator>> i.h OBJECT IN %S
//#UC START# *47022CCF00EAfor47B133E102FA*
//#UC END# *47022CCF00EAfor47B133E102FA*
; // i.h


// генератор классов, интерфейсов на java (.java)
//+ java
<<generator>> java OBJECT IN %S
//#UC START# *470321950119for47B133E102FA*
//#UC END# *470321950119for47B133E102FA*
; // java


// генератор реализации фабрик интерфейсов на java (.java)
//+ fctr.java
<<generator>> fctr.java OBJECT IN %S
//#UC START# *470321C1038Afor47B133E102FA*
//#UC END# *470321C1038Afor47B133E102FA*
; // fctr.java


// С++ TIE-обвязка для DLL (_tie.h)
//+ dll.h
<<generator>> dll.h OBJECT IN %S
//#UC START# *47032EC4032Cfor47B133E102FA*
//#UC END# *47032EC4032Cfor47B133E102FA*
; // dll.h


// С++ TIE-обвязка для DLL (_tie.cpp)
//+ dll.cpp
<<generator>> dll.cpp OBJECT IN %S
//#UC START# *47032ED002DEfor47B133E102FA*
//#UC END# *47032ED002DEfor47B133E102FA*
; // dll.cpp


// Delphi интерфейсы для адаптера (.pas)
//+ pas
<<generator>> pas OBJECT IN %S
//#UC START# *470F152700FAfor47B133E102FA*
//#UC END# *470F152700FAfor47B133E102FA*
; // pas


// Родные Delphi интерфейсы (.pas)
//+ intf.pas
<<generator>> intf.pas OBJECT IN %S
//R  
//#UC START# *470F1571031Cfor47B133E102FA*
//#UC END# *470F1571031Cfor47B133E102FA*
; // intf.pas


// Реализация на Delphi(.pas)
//+ impl.pas
<<generator>> impl.pas OBJECT IN %S
//R  
//#UC START# *470F15B800CBfor47B133E102FA*
//#UC END# *470F15B800CBfor47B133E102FA*
; // impl.pas


// Вторая интерфейсная секция стереотипа. Например реализация свойств класса.
//+ intf2.pas
<<generator>> intf2.pas OBJECT IN %S
//R  
//#UC START# *477398E501C0for47B133E102FA*
//#UC END# *477398E501C0for47B133E102FA*
; // intf2.pas


// 3-я секция интерфейса. Например поле для свойства.
//+ intf3.pas
<<generator>> intf3.pas OBJECT IN %S
//R  
//#UC START# *4774D2A20372for47B133E102FA*
//#UC END# *4774D2A20372for47B133E102FA*
; // intf3.pas


// Генератор файлов форм (.dfm)
//+ dfm
<<generator>> dfm OBJECT IN %S
//R  
//#UC START# *49F5795900ECfor47B133E102FA*
//#UC END# *49F5795900ECfor47B133E102FA*
; // dfm


// Скрипты TC (.sd)
//+ sd
<<generator>> sd OBJECT IN %S
//R  
//#UC START# *4DE79AFC0030for47B133E102FA*
//#UC END# *4DE79AFC0030for47B133E102FA*
; // sd


// Хак для [$281531116]
//+ link_to_requests_hack
<<generator>> link_to_requests_hack OBJECT IN %S
//#UC START# *4E65F581015Afor47B133E102FA*
//#UC END# *4E65F581015Afor47B133E102FA*
; // link_to_requests_hack


// Функции стереотипа
//%f _st_space_key
: st_space_key OBJECT IN %S
//	MDP
 'MDP'


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Унаследованная реализация

// реализация абстрактного стереотипа Документация::MDAGenerator
// вывод описание авто-генерируемых методов в wiki
//%f _wiki_up_add_gen
; // st_space_key

: wiki_up_add_gen OBJECT IN %S
//#UC START# *470484D50138for47B133E102FA*
//#UC END# *470484D50138for47B133E102FA*
; // wiki_up_add_gen



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

end. // :: <<ServerInterface>> <<"factory switch">> ;

