unit vtNavigator;

// $Id: vtNavigator.pas,v 1.84 2013/04/24 09:35:37 lulin Exp $

// $Log: vtNavigator.pas,v $
// Revision 1.84  2013/04/24 09:35:37  lulin
// - портируем.
//
// Revision 1.83  2012/08/10 13:47:18  kostitsin
// [$382421266]
//
// Revision 1.82  2012/05/28 12:29:58  lulin
// {RequestLink:356848399}
//
// Revision 1.81  2012/05/12 16:32:52  kostitsin
// [$362130929]
//
// Revision 1.80  2012/04/23 09:13:19  lulin
// {RequestLink:357338233}
//
// Revision 1.79  2012/04/04 08:57:06  lulin
// {RequestLink:237994598}
//
// Revision 1.78  2012/03/21 17:22:25  lulin
// {RequestLink:349116364}
//
// Revision 1.77  2012/03/15 15:57:17  lulin
// {RequestLink:344754050}
//
// Revision 1.76  2012/03/15 14:09:33  lulin
// {RequestLink:344754050}
//
// Revision 1.75  2012/03/15 11:32:27  lulin
// {RequestLink:344754050}
// - чистка кода.
//
// Revision 1.74  2012/03/15 10:55:37  lulin
// {RequestLink:344754050}
//
// Revision 1.73  2012/03/15 07:27:32  lulin
// {RequestLink:344754050}
// - чистим код.
//
// Revision 1.72  2012/03/07 15:08:17  gensnet
// Устраняем побочные проблемы.
// http://mdp.garant.ru/pages/viewpage.action?pageId=342866773
//
// Revision 1.71  2012/03/02 14:28:33  lulin
// - тестируем работу с файлами.
//
// Revision 1.70  2012/02/29 16:10:39  lulin
// {RequestLink:342856651}.
//
// Revision 1.69  2012/01/30 13:31:00  gensnet
// http://mdp.garant.ru/pages/viewpage.action?pageId=331187752
//
// Revision 1.68  2012/01/25 16:32:01  kostitsin
// http://mdp.garant.ru:8080/pages/viewpage.action?pageId=324009991&focusedCommentId=330141913
//
// Revision 1.67  2012/01/25 16:12:58  kostitsin
// http://mdp.garant.ru/pages/viewpage.action?pageId=324009991
//
// Revision 1.66  2011/12/21 13:50:46  kostitsin
// http://mdp.garant.ru/pages/viewpage.action?pageId=296095220
//
// Revision 1.65  2011/10/17 09:34:18  lulin
// {RequestLink:293896724}.
//
// Revision 1.64  2011/09/21 18:13:38  lulin
// {RequestLink:278836572}.
//
// Revision 1.62  2011/09/21 16:31:28  lulin
// {RequestLink:278836572}.
//
// Revision 1.61  2011/06/17 11:59:04  lulin
// {RequestLink:228688486}.
//
// Revision 1.60  2011/06/16 16:45:46  lulin
// {RequestLink:269076692}.
//
// Revision 1.59  2011/05/19 12:22:35  lulin
// {RequestLink:266409354}.
//
// Revision 1.58  2011/02/17 09:59:59  lulin
// {RequestLink:253659765}.
// - вычищаем мусорок.
//
// Revision 1.57  2010/03/03 16:52:37  lulin
// {RequestLink:193825692}.
//
// Revision 1.56  2010/03/02 15:18:57  lulin
// {RequestLink:193825692}.
//
// Revision 1.55  2009/10/15 14:43:08  lulin
// {RequestLink:166856141}.
//
// Revision 1.54  2009/08/06 16:08:21  lulin
// {RequestLink:159352843}.
//
// Revision 1.53  2009/03/02 10:27:44  oman
// - fix: MouseCapture перехватывает клавиатурный ввод (К-137467726)
//
// Revision 1.52  2008/08/11 12:20:32  mmorozov
// - bugfix: AV (K<106037846>);
//
// Revision 1.51  2008/07/02 05:51:18  mmorozov
// - warning fix.
//
// Revision 1.50  2008/04/17 07:04:47  oman
// - fix: При скрытой кнопке не рисовали заголовок - неверно считали доступное место (cq28885)
//
// Revision 1.49  2008/03/19 14:00:05  mmorozov
// - bugfix: навигатор неправильно располагался в режиме автоскрытия, результат правок версии 1.32, по cq25732 (CQ: OIT5-28338) + таймер автоскрытия не освобождался в результате если вовремя закрыть было AV;
//
// Revision 1.48  2008/03/19 11:04:42  oman
// - fix: Не вызывали inherited => циклились...
//
// Revision 1.47  2008/03/13 07:19:15  mmorozov
// - не показывалась подсказка для кнопки "закрыть" (в рамках CQ: OIT5-28340);
//
// Revision 1.46  2008/03/13 06:53:10  mmorozov
// - библиотека не собиралась;
//
// Revision 1.45  2008/03/12 15:59:13  lulin
// - <K>: 86479266.
//
// Revision 1.44  2008/03/12 13:55:19  mmorozov
// - new: реализация кнопки закрыть в навигаторе (CQ: OIT5-28340);
//
// Revision 1.43  2008/03/07 12:50:46  mmorozov
// - rename properties;
//
// Revision 1.42  2008/03/07 09:36:07  mmorozov
// - изменения при работе с обработчиками формы (в рамках CQ: OIT5-28340);
//
// Revision 1.41  2008/02/21 08:58:37  lulin
// - bug fix: не собиралась библиотека.
//
// Revision 1.40  2008/02/20 10:47:04  lulin
// - удалена ненужная базовая функция очистки.
//
// Revision 1.39  2008/02/06 09:30:42  lulin
// - базовые списки объектов выделяем в отдельные файлы.
//
// Revision 1.38  2008/02/01 15:14:38  lulin
// - избавляемся от излишней универсальности списков.
//
// Revision 1.37  2008/02/01 12:17:49  lulin
// - избавляемся от излишней универсальности списков.
//
// Revision 1.36  2007/12/20 12:46:53  lulin
// - модуль vcmExternalInterfaces теперь полностью генерируется с модели.
//
// Revision 1.35  2007/09/11 08:29:36  mmorozov
// - bugfix: иногда оставалась подсказка (CQ: OIT5-26249) + сопутствующий рефакторинг;
//
// Revision 1.34  2007/09/07 08:51:25  mmorozov
// - new behaviour: для открепленного навигатора используем вместо кнопки закрыть кнопку прикрепить (CQ: OIT5-25522);
//
// Revision 1.33  2007/08/14 19:31:40  lulin
// - оптимизируем очистку памяти.
//
// Revision 1.32  2007/07/17 07:17:37  oman
// - fix: При включении автоскрытия неверно ставили
//  размеры/положение (cq25732)
//
// Revision 1.31  2007/03/14 13:56:25  lulin
// - вычистил мусор.
//
// Revision 1.30  2007/03/14 12:27:26  lulin
// - не записываем мусор.
//
// Revision 1.29  2007/02/12 16:40:32  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.28  2007/01/30 08:46:43  lulin
// - cleanup.
//
// Revision 1.27  2007/01/30 08:36:26  lulin
// - удален ненужный интерфейс.
//
// Revision 1.26  2007/01/17 13:50:40  oman
// - new: Локализация библиотек - vt (cq24078)
//
// Revision 1.25  2006/12/12 11:42:28  mmorozov
// - new: возможность определять класс плавающего окна;
//
// Revision 1.24  2006/12/10 18:59:03  lulin
// - класс формы переименован в соответствии с библиотекой.
//
// Revision 1.23  2006/12/08 15:03:54  lulin
// - bug fix: не собиралась библиотека.
//
// Revision 1.22  2006/12/07 14:21:06  mmorozov
// - new: используем единые настройки для компонента с вкладками (CQ: OIT5-23819);
//
// Revision 1.21  2006/12/05 14:33:33  lulin
// - контрол переехал в визуальную библиотеку.
//
// Revision 1.20  2006/11/03 11:00:37  lulin
// - объединил с веткой 6.4.
//
// Revision 1.19.6.1  2006/10/13 11:12:52  mmorozov
// - bugfix: сплиттер отбирал фокус ввода у активного контрола  (CQ: OIT5-17227);
//
// Revision 1.19  2006/05/17 12:17:13  oman
// - fix: Табконтрол для vtNavigator'а вообще не обрабатывал шриткаты.
//
// Revision 1.18  2006/04/14 12:38:13  lulin
// - запрещаем перекрывать деструктор.
//
// Revision 1.17  2006/04/12 13:52:01  mmorozov
// - bugfix: портилось выравнивание компонент на форме из-за не своевременных действий RemindersLine (CQ: 20243);
//
// Revision 1.16  2006/01/27 13:01:52  mmorozov
// bugfix: видимо окончательный вариант того как дожны работать ограничения на изменение размера навигатора;
//
// Revision 1.15  2006/01/26 13:42:42  mmorozov
// bugfix: ограничения на resize-е навигатора;
//
// Revision 1.14  2006/01/25 14:17:49  mmorozov
// - bugfix: handle главного окна дергался без проверки на выделение, в результате имели большие тормоза при запуске системы;
//
// Revision 1.13  2006/01/24 12:09:51  lulin
// - cleanup.
//
// Revision 1.12  2006/01/24 11:06:44  mmorozov
// - new behaviour: введены ограничения на изменение размеров навигатора; корректировка размеров при восстановлении окна; при стыковке плавающих навигаторов к форме и т.д.;
//
// Revision 1.11  2005/11/22 15:22:01  mmorozov
// bugfix: на компонентах формы с _Align = alNone, которые были выше навигтора оставались полосы от сплиттера после перетаскивания, т.к. они были выше (ZOrder) и их никто не перерисовывал  (cq: 00015856);
//
// Revision 1.10  2005/10/20 04:20:13  lulin
// - cleanup.
//
// Revision 1.9  2005/10/19 08:14:20  mmorozov
// bugfix: сломалось управление закладками;
//
// Revision 1.8  2005/10/06 10:51:05  lulin
// - класс панелей переехал в более правильное место.
//
// Revision 1.7  2005/08/11 10:34:51  mmorozov
// - bugfix (сплиттинг);
//
// Revision 1.6  2005/07/22 13:02:58  lulin
// - модуль с базовыми формами переехал в библиотеку L3.
//
// Revision 1.5  2005/07/15 13:04:42  mmorozov
// bugfix: положение курсора над сплиттером после перетаскивания;
//
// Revision 1.4  2005/07/15 12:58:04  mmorozov
// bugfix: изменение размеров навигатора на форме;
//
// Revision 1.3  2005/07/07 08:47:13  mmorozov
// bugfix: если фокус находился в плавающем навигаторе, то при минимизации приложения, навигатор оставался на экране;
// new: вывод в лог для debug режима (в закомментированном виде);
//
// Revision 1.2  2005/06/27 13:13:36  mmorozov
// no message
//
// Revision 1.1  2005/06/09 09:47:51  mmorozov
// - компоненты перенесены в библиотеку VT;
//
// Revision 1.251  2005/06/03 11:48:55  mmorozov
// new: vtNavigator properties:
// - BtnAutoHideOffHint;
// - BtnAutoHideOnHint;
// - BtnMinimazedOnHint;
// - BtnMinimazedOffHint;
// - BtnCloseHint;
// new: используем созданные свойства вместо констант;
//
// Revision 1.250  2005/05/26 17:44:34  lulin
// - базовая канва вывода переехала из Эвереста в L3.
//
// Revision 1.249  2005/04/19 15:41:34  lulin
// - переходим на "правильный" ProcessMessages.
//
// Revision 1.248  2005/03/29 12:12:17  mmorozov
// - не компилировалась библиотека;
//
// Revision 1.247  2005/03/29 11:51:13  mmorozov
// new: TnpHeader использует TevCanvas для вывода текста;
// new: устанавливаем charset для TnpPageControl;
//
// Revision 1.246  2005/02/25 15:56:15  mmorozov
// bugfix: если навигатор находился в режиме автоскрытия, потом выдергивалась и вставлялась закладка, то он переставал раскрываться;
//
// Revision 1.245  2005/02/16 06:30:33  mmorozov
// bugfix: баг с отрисовкой сплиттера;
//
// Revision 1.244  2005/02/15 12:57:49  mmorozov
// new: использование интерфейса IafwDropDownWindow (не реагируем на выпадающие окна);
//
// Revision 1.243  2005/02/04 16:07:53  mmorozov
// bugfix: hint над кнопкой сплиттера на Win95, 98 был маленьким желтым квадратиком;
//
// Revision 1.242  2005/02/03 09:03:02  mmorozov
// bugfix: иногда оставался hint;
// new behaviour: при уходе фокуса в другое приложение, окно прячем hint сплиттера;
//
// Revision 1.241  2005/02/02 14:35:39  mmorozov
// change: вычисление рамки будущего плавающего навигатора при отстыковки по DblClick, или программной отстыковки закладки;
//
// Revision 1.240  2005/02/02 14:04:39  mmorozov
// bugfix: вычисление координат для плавающего навигатора;
//
// Revision 1.239  2005/02/02 07:15:31  mmorozov
// change: заменен логический оператор;
//
// Revision 1.238  2005/02/02 07:08:24  mmorozov
// bugfix: плавающий навиагатор вылезал на панель задач;
//
// Revision 1.237  2005/01/31 09:55:35  mmorozov
// - не компилировалась библиотека;
//
// Revision 1.236  2005/01/31 08:45:59  mmorozov
// new: hint при задержке указателя над кнопкой сплиттера;
//
// Revision 1.235  2005/01/28 17:29:47  mmorozov
// new behaviour: навигаторы не прячутся при появлении плавающих форм (в частности формы поиска контекста);
// new behaviour: при наличии плавающих окон окна навигатора всегда находились поверх плавающих окон, т.е. между ними нельзя было переключится;
//
// Revision 1.234  2005/01/26 13:34:30  mmorozov
// bugfix: навигатор может мнгновенно скрываться/показываться в режиме AutoHide;
//
// Revision 1.233  2005/01/22 14:29:03  mmorozov
// - оптимизация работы навигатора в режиме AutoHide;
//
// Revision 1.232  2005/01/13 12:10:52  mmorozov
// bugfix: при остыковке закладки от навигатора на форме искались только плавающие формы отстыкованые от данного навигатора, нужно было от всех;
//
// Revision 1.231  2005/01/13 09:41:14  mmorozov
// opt: автоскрытие навигатора;
// bugfix: в режиме автоскрытия если начинали перетаскивать рамка была не верной;
//
// Revision 1.230  2005/01/11 16:24:48  lulin
// - обновлена документация.
//
// Revision 1.229  2005/01/11 15:10:42  mmorozov
// bugfix: после внесенных изменений для навигатора в режиме AutoHide неправильно расчитывалась рамка при перетаскивании;
//
// Revision 1.228  2005/01/09 13:01:41  mmorozov
// bugfix: впервые отстыкованный с помощью настроек навигатор был свернут в трубочку;
//
// Revision 1.227  2004/12/25 11:52:03  mmorozov
// bugfix: восстановление размера плавающих окон;
//
// Revision 1.226  2004/11/19 14:05:44  am
// change: в разных режимах показываем разные хинты для кнопки закрепления навигатора
// change: поменял местами иконы кнопки закрепления (было "не как у всех")
//
// Revision 1.225  2004/11/19 08:58:24  am
// change: хинт к кнопке "Зафиксировать панель навигатора" -> "Зафиксировать панель навигации"
//
// Revision 1.224  2004/11/19 08:17:01  mmorozov
// bugfix: по правой кнопке мыши сплиттер прорисовывался;
//
// Revision 1.223  2004/11/19 07:37:10  mmorozov
// change:  DrawGradient сделана глобальной;
// change: по-другому рисуем навигатор в DesignTime-е;
//
// Revision 1.222  2004/11/18 16:54:28  mmorozov
// new: навигатор в DesignTime честно виден на форме;
//
// Revision 1.221  2004/11/18 16:29:47  lulin
// - отвязываем библиотеки от VCM без использования inc'ов.
//
// Revision 1.220  2004/11/18 14:43:47  mmorozov
// bugfix: в случае если фокус находился в плавающем навигаторе и происходило открытие меню на главной форме, то выделение пунктов меню не рисовалось в области занимаемой навигатором под меню (XPStyle); в классическом стиле после вызова меню оно располагалось под навигатором;
//
// Revision 1.219  2004/11/18 12:55:18  mmorozov
// change: comment;
//
// Revision 1.218  2004/11/18 12:46:56  mmorozov
// bugfix: при вычислении минимального размера для плавающего навигатора учитывался сплиттер, а не должен;
//
// Revision 1.217  2004/11/18 11:04:29  mmorozov
// new: сплиттер навигатора остается при минимизации, восстановить минимизированный навигатор можно либо сплиттингом, либо нажать на кнопку сплиттера;
//
// Revision 1.216  2004/11/17 17:02:28  mmorozov
// change: рисуем стрелку на кнопке сплиттера новым цветом;
//
// Revision 1.215  2004/11/17 15:44:29  mmorozov
// new: у сплиттера появилась кнопка для минимизации навигатора;
//
// Revision 1.214  2004/11/12 13:35:27  mmorozov
// - bugfix, рефакторинг;
// new: TvcmForm хранит положение плавающей формы, в которой она находилась, для восстановления положения плавающего окна в пределах сессии и между сессиями;
//
// Revision 1.213  2004/11/10 14:21:41  mmorozov
// new: плавающий навигатор записывает, восстанавливает своё состояние при работе с TvcmForm;
//
// Revision 1.212  2004/11/09 12:16:51  mmorozov
// change: при минимизации плавающего навигатора не пересоздаём окно, используем SetWindowLong;
//
// Revision 1.211  2004/10/28 06:30:36  mmorozov
// bugfix: при добавлении первой закладки в минимизированный навигатор его размер не менялся (размер вычислялся когда закладка ещё не была видима);
// bugfix: после случая описанного выше номализация навигатора не вызывала изменение его размеров;
//
// Revision 1.210  2004/10/25 09:44:55  mmorozov
// change: точно вычисляем размер области закладок, без всяких +1, +2 и т.д.;
//
// Revision 1.209  2004/10/22 19:38:07  mmorozov
// bugfix: method SetUndockSize;
//
// Revision 1.208  2004/10/22 16:58:31  mmorozov
// bugfix: пропадала кнопка "Автоскрытие" при переключении с минимизирован к автоскрытию;
//
// Revision 1.207  2004/10/21 20:01:23  mmorozov
// bugfix: если курсор находился над заголовком, то забирал фокус ввода;
// change: теперь честно если курсор находится над кнопками то Cursor = crDefault;
//
// Revision 1.206  2004/10/21 19:31:12  mmorozov
// cleanup: TnpHeader.SetState;
//
// Revision 1.205  2004/10/21 17:33:23  mmorozov
// new: кнопки навигатора переведены на ImageList;
// new: properties (BtnCloseImageIndex, BtnAutoHideOnImageIndex, BtnAutoHideOffImageIndex, BtnHideLeftImageIndex, BtnHideRightImageIndex, BtnHideUpImageIndex, BtnHideDownImageIndex, ButtonsImageList);
//
// Revision 1.204  2004/10/14 06:50:22  mmorozov
// bugfix: при установке состояния "автоскрытие" ничего не делается если закладок нет;
//
// Revision 1.203  2004/10/11 11:41:42  mmorozov
// bugfix: положение кнопок заголовка;
//
// Revision 1.202  2004/10/09 10:48:30  mmorozov
// bugfix: при стыковки, навигатору на форме теперь устанавливаются размеры плавающего навигатора, если у него не было закладок;
//
// Revision 1.201  2004/10/08 15:47:23  lulin
// - bug fix: не компилировалось.
//
// Revision 1.200  2004/10/08 12:15:51  am
// change: перетащил весь навигатор на объекты, прямо или косвенно наследующиеся от l3
//
// Revision 1.199  2004/10/05 12:53:42  mmorozov
// change: сигнатура DoStateChanged;
// new behaviour: вызываем OnStateChange только при изменении состояния, не вызываем при добавлении, удалении закладок;
//
// Revision 1.198  2004/09/30 13:30:18  mmorozov
// bugfix: после отстыковки закладки из плавающего навигатора нажатие на следующую приводило к смещения навигатора;
//
// Revision 1.197  2004/09/30 12:55:44  mmorozov
// - warnings fix;
//
// Revision 1.196  2004/09/30 07:44:30  mmorozov
// bugfix: механизм пристыковки закладок из плавающего навигатора к навигатору на форме;
//
// Revision 1.195  2004/09/30 07:22:07  mmorozov
// new behaviour: при появлении модальной формы навигаторы прячутся;
//
// Revision 1.194  2004/09/29 13:37:53  mmorozov
// bugfix: AutoHideUpdate работает только для режима автоскрытия;
//
// Revision 1.193  2004/09/29 10:40:17  mmorozov
// new: method TnpPageControl.Notification (удаляем из списка зарегистрированных);
// - bugfixs;
//
// Revision 1.192  2004/09/29 10:01:48  mmorozov
// bugfix: каскадирование;
//
// Revision 1.191  2004/09/29 09:47:01  mmorozov
// new: каскадно размещаем плавающие навигаторы при отстыковки закладок навигатора на форме по DblClick-у;
//
// Revision 1.190  2004/09/29 09:34:27  fireton
// - bug fix: управление закладками с клавиатуры
//
// Revision 1.189  2004/09/29 08:45:19  mmorozov
// bugfix: в закладках PageControl-а плавающего навигатора не отображались иконки;
//
// Revision 1.188  2004/09/29 08:34:11  mmorozov
// new: method TnpPageControl.DockDrop;
// new: class TnpNavigatorControls;
// new: class TnpNavigatorControlsList;
// new: global function _npNavigatorControlsList;
// new behaviour: при закрытии плавающего навигатора закладки пристыковываются к тем навигаторам на форме, от которых они были отстыкованы;
// new behaviour: DblClick на закладке плавающего навигатора приводит  к ее пристыковке к навигатору на форме;
//
// Revision 1.187  2004/09/28 11:39:24  mmorozov
// remove: CM_npUpdateNavigatorSize;
// change:  упрощаем логику работы (AutoHideUpdate);
// bugfix: при изменении ширины главного окна правый плавающий навигатор менял позицию только после отпускания мыши;
//
// Revision 1.186  2004/09/24 12:20:29  am
// bugfix: никаких хуков в дизайнтайме (одна из причин того, что падает MainForm)
//
// Revision 1.185  2004/09/23 15:16:13  mmorozov
// new: при закрытии плавающего навигатора обнуляем FloatID;
//
// Revision 1.184  2004/09/22 14:01:21  mmorozov
// change: TnpSurface.Paint рисуем только если нет закладок;
//
// Revision 1.183  2004/09/22 13:47:46  mmorozov
// new: method TnpSurface.Paint;
//
// Revision 1.182  2004/09/22 13:34:15  mmorozov
// change: по умолчанию сплиттер не видим, видимость меняется при добавлении первой заклдаки;
// new: в TnpSurface.WMEraseBkgnd заливаем цветом;
//
// Revision 1.181  2004/09/21 09:44:26  mmorozov
// new: рисуем границу у минимизированного плавающего навигатора (иначе оставались рудименты от других окон);
// - чистка неиспользуемого кода;
//
// Revision 1.180  2004/09/20 15:31:15  mmorozov
// new: реализован сплиттер (избавляемся от проблем прорисовки не клиентской области, resiza-а, избавляется от лишнего кода);
//
// Revision 1.179  2004/09/17 16:41:26  mmorozov
// - bugfixs;
//
// Revision 1.178  2004/09/17 13:21:24  mmorozov
// - cleanup;
//
// Revision 1.177  2004/09/17 12:32:48  mmorozov
// Переработан модуль:
// - удален класс TnpMgr;
// - не перехватываем оконную процедуру у главного окна;
// - при активизации приложения по заголовку окна плавающие навигаторы не перемиргивают;
// - при закрытии модальных окон плавающие навигаторы восстанавливаются;
// - ведем список созданных навигаторов для быстрого доступа к ним);
// - существенно упрощена обработка сообщений WM_ACTIVATE;
//
// Revision 1.176  2004/09/15 12:28:25  fireton
// - change: изменены хинты к кнопкам навигатора
//
// Revision 1.175  2004/09/15 12:17:00  fireton
// - change: изменены хинты к кнопкам навигатора
//
// Revision 1.174  2004/09/14 14:08:29  mmorozov
// new: дополнительная проверка обработчика PageControl.OnUnDock;
//
// Revision 1.173  2004/09/08 07:52:47  mmorozov
// bugfix: при открытии приложения с формой в правом навигаторе иконка у кнопки минимизировать была повернута в другую сторону;
//
// Revision 1.172  2004/09/07 11:16:45  mmorozov
// bugfix: при стыковке закладки в правый навигатор в режиме автоскрытия в одном месте были кноки минимизации и автоскрытия, также прорисовывалась иконка;
//
// Revision 1.171  2004/09/07 10:28:17  mmorozov
// change: не создаём imagelist при перестакивании закладок от одного навигатора к другому;
//
// Revision 1.170  2004/09/07 09:36:15  mmorozov
// new: method TnpSurface.InitAutoHidePosition;
// new: method vtNavigator.RecalcSize;
// new: property vtNavigator._IsMinimazed;
// - bugfixs;
//
// Revision 1.169  2004/09/06 16:38:44  mmorozov
// bugfix: не прорисовывались границы toolbar-ов при изменении состава toolbar-ов;
// - избавляемся от мерцания компонентов в навигаторе на форме и в плавающем навигаторе;
//
// Revision 1.168  2004/09/03 11:47:36  mmorozov
// new: TnpPageControl - без границ;
//
// Revision 1.167  2004/09/03 07:20:16  mmorozov
// change: включено антимерцание;
// bugfix: перед отображением плавающего навигатора устанавливаем ему BoundsRect (чтобы не прыгал);
//
// Revision 1.166  2004/09/02 17:24:34  mmorozov
// new: vtNavigator поддерживает IvcmToolbarNotifier;
// bugfix: после отрисовки сплиттера не освобождался bitmap (TnpHeader);
// new: TnpHeader.UpdateSize;
// change: SetBtnsPosition -> UpdatePositions;
// change: LoadHideBmp -> UpdateHideBmp;
// change: LoadAutoHideBmp -> UpdateAutoHideBmp;
//
// Revision 1.165  2004/09/02 13:05:51  law
// - все dynamic методы заменил на virtual.
//
// Revision 1.164  2004/09/01 10:59:27  mmorozov
// change: CM_NP_AFTER_FLOAT_DOCKED -> CM_NP_UP_COMPS_IN_ZORDER;
// new: method TnpSurface.DrawSplitter;
// - bugfixs;
//
// Revision 1.163  2004/09/01 07:50:25  mmorozov
// new: property vtNavigator.IsEmpty;
// bugfix: у навигатора без закладок рисовался сплиттер;
//
// Revision 1.162  2004/08/31 15:08:40  mmorozov
// - bugfixes;
//
// Revision 1.161  2004/08/31 14:25:19  mmorozov
// new: реализация сплиттера;
//
// Revision 1.160  2004/08/25 12:04:43  am
// bugfix: убрал SetFocus из ModeHide (навигатор перехватывал фокус при плавном закрытии. CQ8209)
//
// Revision 1.159  2004/08/24 14:38:31  mmorozov
// bugfix: в _pm_GetControlCount перед использованием проверяем наличие PageControl-а;
//
// Revision 1.158  2004/08/23 12:38:45  mmorozov
// new: property vtNavigator.ShowActivePageInHeader (выводить иконку и название активной закладки в заголовке навигатора);
//
// Revision 1.157  2004/08/23 11:31:18  mmorozov
// change: упрощена логика работы с отображением плавающих навигаторов формы;
// new:  навигаторы не прячутся при открытии выпадающих окошек как на форме которой принадлежат так и на самом плавающем навигаторе;
//
// Revision 1.156  2004/08/19 11:52:59  mmorozov
// bugfix: при стыковке первой закладки к навигатору поднимаем по оси Z компоненты с _Align = alNone на том же родителе, чтобы навигатор их не заслонял;
//
// Revision 1.155  2004/08/18 09:10:49  am
// bugfix: вставил доп. проверку в _pm_GetControlCount
//
// Revision 1.154  2004/08/16 13:18:26  am
// bugfix: при выставлении фокуса не проверяли, можно ли выставлять
// bugfix: зацикливание сообщений в специфическом случае
//
// Revision 1.153  2004/08/04 16:05:57  mmorozov
// - не компилировалась библиотека;
//
// Revision 1.152  2004/08/04 15:49:52  mmorozov
// - вернули вытертое;
//
// Revision 1.151  2004/08/04 15:27:13  demon
// - cleanup: warnings and hints
//
// Revision 1.150  2004/07/28 09:18:21  mmorozov
// change: отрисовываем элементы заголовка системными цветами;
//
// Revision 1.149  2004/07/27 12:11:48  fireton
// - change: добавление _TElCustomPageControl способности отрисовывать иконки из TvtPNGImageList
//
// Revision 1.148  2004/07/20 09:46:05  mmorozov
// bugfix: не отключаем OnUnDock, потому что формы могут быть вытащены не только пользователем но при _ReinsertForms;
//
// Revision 1.147  2004/07/14 10:27:44  mmorozov
// bugfix: когда уже вставленной в навигатор форме говорили снова вставиться, закладке pagecontrol-а приходило сообщение CMUnDockClient, она выставляла контролу Aling = alNone, после чего навигатор смотрел что поданый компонент уже пристыкован и в итоге форма на закладке была не видна;
//
// Revision 1.146  2004/06/29 10:50:45  mmorozov
// new behaviour: при отстыковки навигатора устанавливаем BoundsRect после установки навигатору свойства Visible (для того, чтобы навигатор можно было отпустить на втором мониторе);
//
// Revision 1.145  2004/06/18 13:11:31  mmorozov
// no message
//
// Revision 1.144  2004/06/17 06:59:59  mmorozov
// - размер шрифта и цвет шрифта активной закладки в навигаторе отличался от остальный ElPageControl-ов в Немезисе;
//
// Revision 1.143  2004/05/17 14:45:37  am
// change: правки в рамках обновления навигаторов при смене конфигурация
//
// Revision 1.142  2004/05/05 11:31:29  mmorozov
// bugfix: заголовок навигатора захватыват сообщения от мыши только если окно активно (при клике по заголовку навигатора не активного окна оно не становилось активным);
//
// Revision 1.141  2004/04/23 09:27:31  mmorozov
// bugfix: при отрисовке gripper-а используем системное значение границы resize-а окна;
//
// Revision 1.140  2004/04/22 08:39:42  mmorozov
// new behaviour: resize окна плавающего навигатора можно делать если курсор находится в области gripper-а окна (не только у границы окна);
//
// Revision 1.139  2004/04/13 05:59:58  mmorozov
// bugfix: AV при закрытии приложения;
//
// Revision 1.138  2004/04/09 12:25:42  mmorozov
// bugfix: нельзя было вытащить закладку из минимизированного навигатора с _Align = alRight;
//
// Revision 1.137  2004/04/08 13:02:41  mmorozov
// new: показываем hint-ы у кнопок навигатора;
//
// Revision 1.136  2004/04/06 12:18:50  mmorozov
// change: отрисовка сплиттера (серенький);
//
// Revision 1.135  2004/04/06 06:30:21  mmorozov
// - comments;
//
// Revision 1.134  2004/04/02 11:06:53  mmorozov
// - чистка кода;
//
// Revision 1.133  2004/04/01 10:28:30  mmorozov
// new: комментарии;
// new: в заголовке навигатора показываем курсор SizeALL (стрелки во все стороны);
// bugfix: при перемещении плавающего навигатора после его отпускания курсор смещался немного вверх;
//
// Revision 1.132  2004/04/01 08:08:50  mmorozov
// no message
//
// Revision 1.131  2004/04/01 07:44:20  mmorozov
// bugfix: отрисовка заголовка в навигаторе;
//
// Revision 1.130  2004/03/31 12:13:43  mmorozov
// bugfix: перетаскивание навигатора в режиме AutoHide;
//
// Revision 1.129  2004/03/30 15:18:09  mmorozov
// new: у плавающей формы рисуем панель resize-а;
//
// Revision 1.128  2004/03/30 10:29:09  mmorozov
// new: поддержка классом TFloatingNavigator интерфейса IvcmFloatingDockSiteClass;
// bugfix: при вытаскивании закладки из навигатора на форме, не пристыковываем ее к навигатору, в котором она находилась раньше, создаём новый;
//
// Revision 1.127  2004/03/29 17:10:07  mmorozov
// new: идентификаторы плавающих навигаторов;
//
// Revision 1.126  2004/03/29 10:26:41  mmorozov
// new behavior: если закладка одна, то нажатие на кнопку управления активностью формы приводит к минимизации навигатора;
//
// Revision 1.125  2004/03/26 18:17:50  mmorozov
// new: обрабатываем сообщения управления активностью;
//
// Revision 1.124  2004/03/25 08:43:35  mmorozov
// bugfix;
//
// Revision 1.123  2004/03/25 08:34:25  mmorozov
// new: увеличен размер кнопок заголовка навигатора;
// new: возможность перетаскивать плавающий навигатор за закладку, если она одна;
// new: корректная отрисовка тени при перетаскивании и позиционирование навигатора;
//
// Revision 1.122  2004/03/22 08:33:34  mmorozov
// - вызываем OnStateChanged при нажатии на кнопку автоскрытие;
//
// Revision 1.121  2004/03/17 14:13:30  mmorozov
// new behavior: в режиме AutoHide навигатор всегда наплывает на контекст;
//
// Revision 1.120  2004/03/17 07:54:20  mmorozov
// new: вызываем событие OnSaveSize, когда из навигатора удаляют последнуюю закладку;
//
// Revision 1.119  2004/03/17 07:16:29  mmorozov
// delete: property ManualSizeNormal;
// new: event OnLoadSize;
//
// Revision 1.118  2004/03/15 17:50:27  mmorozov
// bugfix: избавляемся от различного рода мерцаний;
//
// Revision 1.117  2004/03/15 11:54:13  mmorozov
// new: избавляемся от мерцания при созднии плавающего навигатора;
//
// Revision 1.116  2004/03/11 12:25:49  mmorozov
// new: для плавающего навигатора в качестве Owner указываем навигатор на форме, который его породил;
//
// Revision 1.115  2004/03/11 09:09:20  am
// new: prop ManualSetSize
//
// Revision 1.114  2004/03/11 08:57:19  mmorozov
// new: при закрытии плавающего навигатора спрашиваем у форм CloseQuery;
//
// Revision 1.113  2004/03/05 16:51:32  mmorozov
// - класс TIntStack и некоторые методы перенесены в ElPgCtl;
//
// Revision 1.112  2004/03/05 13:29:27  mmorozov
// new: класс TIntStack;
// - устанавливаем PageControl`s _Name как у навигатора;
//
// Revision 1.111  2004/03/05 09:27:45  mmorozov
// - избавляемся от Hints;
//
// Revision 1.110  2004/03/04 15:13:25  mmorozov
// - TElPageControlNavigator переименован в TPageControlNavigator;
// - IsActiveForm переименован в __IsActiveControl;
// - SetActiveForm переименован в _SetActiveControl;
// - GetActiveForm переименован в _GetActiveControl;
// bugfix: рамеры навигатора отстыкованного от плавающего;
//
// Revision 1.109  2004/03/03 09:45:27  mmorozov
// new: при стыковке к пустому навигатору рисуем область дока по размерам объекта который стыкуют;
//
// Revision 1.108  2004/03/02 14:50:38  mmorozov
// new: при стыковке к пустому навигатору он принимает размеры навигатора от которого отстыковывают;
// new: увеличина область стыковки к пустому навигатору;
//
// Revision 1.107  2004/02/26 15:01:32  mmorozov
// - изменения в связи с переменной высотой кода;
//
// Revision 1.106  2004/02/25 08:33:14  mmorozov
// - событие OnClickOnTabSheet переименовано в _OnTabSheetClick;
//
// Revision 1.105  2004/02/18 11:41:18  mmorozov
// new: State можно устанавливать;
//
// Revision 1.104  2004/02/18 11:11:45  mmorozov
// no message
//
// Revision 1.103  2004/02/18 10:58:16  mmorozov
// - правка TNavigatorState;
// - OnStateChange на изменение свойства Swim;
//
// Revision 1.102  2004/02/18 10:52:44  mmorozov
// - чистка кода;
//
// Revision 1.101  2004/02/18 10:46:39  mmorozov
// new: property vtNavigator.OnStateChange (вызывается при изменении состояние навигатора (автоскрытие, минимизация, восстановление размера));
//
// Revision 1.100  2004/02/13 15:11:26  mmorozov
// bugfix: HideNavigator;
//
// Revision 1.99  2004/02/13 13:45:02  am
// bugfix: HideNavigator
//
// Revision 1.98  2004/02/13 12:04:08  mmorozov
// new: property vtNavigator.HideNavigator;
//
// Revision 1.97  2004/01/15 12:01:49  mmorozov
// new: method vtNavigator._IsMinimized;
//
// Revision 1.96  2004/01/15 11:07:23  mmorozov
// new: method vtNavigator.IsActiveForm;
//
// Revision 1.95  2004/01/15 10:28:05  mmorozov
// new: method vtNavigator.GetActiveForm;
//
// Revision 1.94  2004/01/14 16:34:39  mmorozov
// new: vtNavigator поддерживает IvcmState и транслирует TPageControl-у вызов операций IvcmState;
//
// Revision 1.93  2004/01/13 09:29:19  mmorozov
// bugfix: стыковка навигаторов;
//
// Revision 1.92  2003/12/30 13:13:07  mmorozov
// bugfix: от навигатора оставалась часть его заголовка если он был плавающим на форме и из него были вытащины все закладки;
// bugfix: не верное возвращение размера навигатора (высота закладок), в плавающем состоянии;
//
// Revision 1.91  2003/12/30 10:16:09  mmorozov
// bugfix: работа навигатора с использованием различных значений свойств AutoHideFloat, Swim;
//
// Revision 1.90  2003/12/30 09:01:14  mmorozov
// - в методе ModeAutoUpdate удалена повторная установка размеров;
// - перед переходом в состояние "навигатор свернут" сначала уменьшаем размер TPageControl-а, потом vtNavigator;
//
// Revision 1.89  2003/12/26 12:18:41  mmorozov
// new: event TOnSaveSizeNavigator;
// new: published property vtNavigator.OnSaveSize;
//
// Revision 1.88  2003/12/26 10:38:15  mmorozov
// new behaviour: читаем размеры из настроек;
//
// Revision 1.87  2003/12/25 08:26:07  mmorozov
// bugfix: при изменении размеров формы схопнутый навигатор не менял размеры PageControl-а;
//
// Revision 1.86  2003/12/22 17:33:42  mmorozov
// no message
//
// Revision 1.85  2003/12/17 17:09:55  mmorozov
// + перечислимый тип TDrawSplitterType;
// + набор TDrawSplitterTypes;
// - удален класс TNavigatorSplitter;
// + при resize-е сплиттер рисуем сами;
// + при resize-е навигатора ограничиваем область изменения ширины (высоты навигатора);
//
// Revision 1.84  2003/12/17 11:02:21  mmorozov
// - bugfix: AV при закрытии приложения с плавающими навигаторами;
//
// Revision 1.83  2003/12/17 09:55:48  mmorozov
// - bugfix: реализовано переключение между окнами с плавающими навигаторами;
//
// Revision 1.82  2003/12/16 12:33:11  mmorozov
// + "схлопываем" навигатор если при resize-е размер меньше cnMiniSizeOnResize;
//
// Revision 1.81  2003/12/16 11:25:14  mmorozov
// + bugfix: при нажатии на кнопку мыши вне области "всплывающего" навигатора он останавливался;
//
// Revision 1.80  2003/12/15 16:02:25  mmorozov
// - не перехватывам курсор при переходе через границу resize-а навигатора если она была уже захвачена;
//
// Revision 1.79  2003/12/10 15:05:54  mmorozov
// - работа над поведением отстыкованых навигаторов при переключении между окнами (промежуточный коммит);
//
// Revision 1.78  2003/11/25 08:35:20  mmorozov
// - splitter навигатора захватывает фокус только если окно активно;
//
// Revision 1.77  2003/11/21 12:03:59  migel
// - fix: не показываем плавующее окно в таскбаре и по `Alt+Tab` (CQ: 3889).
//
// Revision 1.76  2003/10/10 14:05:51  mmorozov
// - при перетаскивании всего навигатора сохраняется активная закладка;
//
// Revision 1.75  2003/10/10 09:22:01  mmorozov
// + установка _ImageIndex закладок и Images PageControl-а при получении Control(s) от другого PageControl;
//
// Revision 1.74  2003/10/09 12:21:01  mmorozov
// + свойство vtNavigator.Images, для доступа к _TElCustomPageControl.Images;
//
// Revision 1.73  2003/10/08 11:54:35  mmorozov
// - подержка истории перенесена в _TElCustomPageControl;
//
// Revision 1.72  2003/10/02 14:54:09  mmorozov
// - поддержка истории перенесена из ElPageControl в наследник;
//
// Revision 1.71  2003/09/26 13:37:21  mmorozov
// no message
//
// Revision 1.70  2003/09/25 09:25:38  mmorozov
// + procedure TMgrNavigator.mnError;
// + procedure vtNavigator.CMUpdateNavigatorSize;
// + function CBTHook;
//
// - изменена procedure vtNavigator.Resize;
// - изменена procedure vtNavigator.SetNormalSize;
// - изменена procedure vtNavigator.ReceiveMessage;
//
// Revision 1.69  2003/09/25 05:41:38  mmorozov
// - изменена procedure vtNavigator.DockDrop;
//
// Revision 1.68  2003/09/16 08:31:07  migel
// + изменен метод vtNavigator.StartDragControl;
//
// Revision 1.67  2003/09/16 08:20:08  migel
// + метод vtNavigator.StartDragControl;
//
// Revision 1.66  2003/09/16 07:23:06  migel
// - изменена vtNavigator.ModeHide;
//
// Revision 1.65  2003/09/16 06:52:31  migel
// - изменена CreateNavigator;
//
// Revision 1.64  2003/09/16 06:37:27  migel
// - изменена TNavigatorHeader.MouseDown;
// - изменена vtNavigator.EndDockControl;
//
// Revision 1.63  2003/09/12 13:27:48  mmorozov
// + свойство TMgrNavigator.FMgrForm;
//
// Revision 1.60  2003/08/29 16:19:42  mmorozov
// no message
//
// Revision 1.59  2003/08/28 13:46:22  mmorozov
// + метод SetUndockPoint;
// + метод SetUndockSize;
//
// Revision 1.58  2003/08/28 12:11:39  mmorozov
// - переименование BtnHide -> DoHide;
// - модификация метода AnalyzeResize;
// - модификация метода ModeNormalUpdate;
//
// Revision 1.57  2003/08/22 12:26:24  mmorozov
// - корректировка координат нового плавающего навигатора;
//
// Revision 1.56  2003/08/15 07:05:59  mmorozov
// - в TMgrNavigator.MgrWindowProc закоментирован Exit;
//
// Revision 1.55  2003/08/12 08:01:15  max
// - проверка в PageControlUndock NewTarget <> Self;
//
// Revision 1.54  2003/08/08 11:56:49  max
// - bug fix;
//
// Revision 1.53  2003/07/29 14:42:39  mmorozov
// - при активизации формы минимизированный навигатор открывается;
// - коррекное включение режима автоскрытия у минизированного навигатора;
//
// Revision 1.52  2003/07/25 16:47:49  mmorozov
// - при переключении фокуса между формами с плавающими навигаторами происходило мелькание;
//
// Revision 1.51  2003/07/25 13:24:36  mmorozov
// - каждый раз при вызове ModeHide определяется fSizeMini;
//
// Revision 1.50  2003/07/23 15:11:11  mmorozov
// - устранение ошибки при перетаскивании за заголовок навигатора в режиме автоскрытия;
//
// Revision 1.49  2003/07/23 12:41:12  mmorozov
// - при выравнивании alRight и alBottom на форме неправильно работал
// режим всплывания навигатора;
// - свойство Float перенесено из раздела published в раздел public;
//
// Revision 1.48  2003/07/17 08:12:37  mmorozov
// - при минимизации окна плавающие навигаторы оставались на
// экране;
//
// Revision 1.47  2003/07/17 06:40:59  mmorozov
// - в плавающем режиме стыковку можно было осуществить к самому
// навигатору после чего он изчезал;
//
// Revision 1.46  2003/07/16 12:46:02  mmorozov
// + свойство fDelayIntervalOnShow;
// + свойство FDelayIntervalOnHide;
//
// Revision 1.45  2003/07/16 12:07:13  mmorozov
// + класс TElPageControlNavigator;
//
// Revision 1.44  2003/07/16 08:30:45  mmorozov
// + свойство DockSiteOnlyCustomForm, если True то пристыковываться к
// ElPageControl разрешено только объектам наследникам от _TCustomForm;
//
// Revision 1.43  2003/07/16 06:55:19  mmorozov
// - в режимах AutoHide и DelayOnAutoHide при отстыковке закладки
// двойным  кликом создается навигатор нормального размера;
// - коррекция размера рамки при перемещении плавающего
// навигатора;
//
// Revision 1.42  2003/07/16 06:09:04  mmorozov
// - всплывание в режиме автоскрытия работает при
// FState = N_STATE_SHOW;
//
// Revision 1.41  2003/07/15 16:27:33  mmorozov
// - удалены тестовые процедуры;
//
// Revision 1.40  2003/07/15 16:23:26  mmorozov
// + добавлено свойство AutoHideFloat;
//
// Revision 1.39  2003/07/15 15:09:19  mmorozov
// + ограничение размеров навигатора в режиме на форме и в
// плавающем режиме при изменении размеров;
//
// Revision 1.38  2003/07/15 13:58:54  mmorozov
// + добавлена возможность задержки навигатора перед изменением
// состояния в режиме автоскрытия;
// + свойство DelayOnAutoHide определяет режим задержки;
// + свойство MSDelayOnAutoHide определяет продолжительность
// задержки в миллисекундах;
//
// Revision 1.37  2003/07/14 19:43:56  mmorozov
// - добавлена процедура SetActiveForm;
//
// Revision 1.36  2003/07/14 17:53:40  mmorozov
// - исправление ошибок;
//
// Revision 1.35  2003/07/14 16:34:54  mmorozov
// - при максимизации (минимизации) свернутый навигатор запоминал
// свои новые размеры как нормальные;
// - при открытии навигатора в новом окне происходило зацикливание;
// - исправление ошибок;
//
// Revision 1.34  2003/07/08 11:02:56  mmorozov
// - минимизация (максимизация) плавающего навигатора;
//
// Revision 1.33  2003/07/08 08:57:11  mmorozov
// - вновь создаваемые плавающие навигаторы позиционируются в том
// месте где пользователь отпустил кнопку мыши;
//
// Revision 1.31  2003/07/08 07:27:56  mmorozov
// - при отстыковке объекта рамка имеет размер формы (навигатора);
//
// Revision 1.30  2003/07/07 16:12:55  mmorozov
// - максимизация (минимизация) формы вместе с плавающими
// навигаторами;
// - скрытие (отображение) навигаторов при потери (получении) формой
// (приложением) фокуса:
// - добавлен менеджер навигаторов TMgrNavigator;
//
// Revision 1.29  2003/07/03 13:53:21  mmorozov
// - при вызове методов интерфейса IvcmControlsContainer _pm_GetControlCount и _pm_GetControlCount должны возвращатся закладки всех навигаторов порожденных от навигатора на форме;
// - плавающие навигаторы уничтожаются вместе с формой которая их породила;
//
// Revision 1.27  2003/07/01 11:31:35  mmorozov
// - реализован интерфейс IvcmControlsContainer;
//
// Revision 1.26  2003/07/01 07:37:09  mmorozov
// - при двойном клике на вкадке ElPageControl не обрабатывалось событие
// отстыковки компонента;
// - добавлено свойство UnDockFromFloat. Если свойство
// UnDockFromFloat = True и Float = True, то для отстыкованного
// "в никуда" компонента создается новый плавающий навигатор.
// При создании навигаторов одного из другого значение свойства
// копируется;
//
// Revision 1.25  2003/06/30 13:53:19  mmorozov
// - создан плавающий навигатор;
//
// Revision 1.24  2003/06/26 12:37:28  mmorozov
// - при движении по дереву, когда всплывают подсказки заголовок не мигает;
//
// Revision 1.23  2003/06/23 09:10:17  mmorozov
// - компонент не давал форме изменить свои размеры если курсор
// проходил через границу "сплиттинга" навигатора;
// - при "докинге" компонента в навигатор он принимает размеры
// навигатора из которого принимается компонент если у него нет ни
// одной закладки;
//
// Revision 1.22  2003/06/20 15:53:50  mmorozov
// - перерисован Splitter
//
// Revision 1.21  2003/06/20 14:57:25  mmorozov
// - можно перетаскивать объекты через границу перетаскивания;
// - исправлено моргание шрифта на вкладке PageControl;
//
// Revision 1.20  2003/06/20 12:20:17  mmorozov
// - при изменении размеров отображается Splitter
//
// Revision 1.19  2003/06/19 17:43:05  mmorozov
// - навигатор изменяет размеры при выравнивании alTop, alBottom
//
// Revision 1.18  2003/06/19 17:26:52  mmorozov
// - добавлена возможность изменять размеры навигатора при
// выравнивании влево и вправо;
//
// Revision 1.16  2003/06/19 12:13:37  mmorozov
// - при измененении положения навигатора в кнопки заголовка
// загружаются соответветствующие положению bmp
//
// Revision 1.15  2003/06/19 09:27:25  mmorozov
// - добавлено свойство Swim, которое определяет как отображается
// навигатор в режиме автоскрытия. Если Swim = True, то навигатор
// "наплывает" на компоненты, в противном отодвигает рядом
// стоящие компоненты;
//
// Revision 1.14  2003/06/17 07:52:37  mmorozov
// - появился заголовок за который можно перетаскивать навигатор;
// - заголовок содержит кнопки скрыть и включить/отключить режим
// автоскрытия;
// - скрытый навигатор открывается по щелчку на любой вкладке;
//
// Revision 1.13  2003/06/10 07:18:00  mmorozov
// TPageControl заменен на _TElCustomPageControl
//
// Revision 1.12  2003/06/04 13:46:32  nikitin75
// +OnStateChange
//
// Revision 1.11  2003/06/04 12:12:03  nikitin75
// + intermediate update
//
// Revision 1.10  2003/05/23 12:20:22  nikitin75
// update
//
// Revision 1.9  2003/05/23 08:40:08  nikitin75
// update
//
// Revision 1.8  2003/05/22 13:27:50  law
// - change: вставлены директивы CVS.
//

{$Include vtNavigator.inc}

interface

uses
  Windows,
  Messages,
  SysUtils,
  Variants,
  Classes,
  Graphics,
  ImgList,
  Controls,
  Forms,
  Dialogs,
  ExtCtrls,
  ComCtrls,
  StdCtrls,
  ElPgCtl,
  Buttons,
  Math,

  l3Base,
  l3WinControlCanvas,
  l3ObjectList,
  l3ObjectRefList,
  l3ProtoObject,

  vcmExternalInterfaces
  {$IfDef Nemesis}
  ,
  vcmForm
  {$EndIf Nemesis}
  {$IfDef NavigatorPanelNeedsTb97}
  ,
  tb97ctls
  {$EndIf NavigatorPanelNeedsTb97}
  ,
  afwInterfaces,
  afwCustomCommonControl,

  vtCustomCommonPanel,

  l3Forms,

  vtNavigatorForm,
  vtNavigatorFormList,
  vtPanel
  ;

const

/// Messages ///////////////////////////////////////////////////////////////////
  CM_npAfterUndock = (WM_USER + 1);
    {-}
  CM_npChangeActivate = (WM_USER + 3);
    {* - используется при необходимости изменить активность. }
  CM_npDeleteFromList = (WM_USER + 4);
    {* - удалить навигатор из списка навигатора, который его породил wParam
         содержит pointer на удаляемый навигатор. }
  CM_npDoActionWithFormControls = (WM_USER + 5);
    {* - асинхронно посылается после пристыковывания плавающего навигатора на
         форму. }
  CM_npTabPositionChanged = (WM_USER + 6);
    {* - уведомляем компоненты об изменении расположения закладок. }
  CM_npDockToFloatWindow = (WM_USER + 7);
    {* - сделать форму (закладку) плавающей. WParam - указатель на компонент
         который нужно отстыковать; }
////////////////////////////////////////////////////////////////////////////////

{$Include ElPgCtlConsts.inc}

type
  TnpDrawSplitterType = (dstErase, dstPaint);

  TnpDrawSplitterTypes = set of TnpDrawSplitterType;

  TnpButtonType = (
   {* Тип кнопки. }
    nbtAutoHide,
    nbtMinimazed,
    nbtClose
  );//TnpButtonType

  TvtNavigator = class;

  TnpHeader = class;

  TnpSurface = class;

  TnpObject = class(Tl3ProtoObject)
  end;//TnpObject

  TnpCustomControl = class(TafwCustomCommonControl)
  end;//TnpCustomControl

  TnpCustomPanel = class(TvtCustomCommonPanel, IvcmDockType)
  protected
    function Get_ControlIsPanel: Boolean;
  end;//TnpCustomPanel

  TnpPageControl = class(TElCustomPageControl)
  {* - pagecontrol используемый в навигаторе. }
  private
  // internal fields
    f_Navigator: TvtNavigator;
  private
  // messages
    procedure CMDockNotification(var Message: TCMDockNotification);
      message CM_DOCKNOTIFICATION;
      {* - при изменении видимости первого пристыковыванного компонента
           показываем навигатор. }
    procedure PMIsActiveControl(var Message : TMessage);
      message PM_ISACTIVECONTROL;
      {* - определяет активен ли компонент. Если навигатор находится в свернутом
           состоянии, то компонент в любом случае не активен. }
    procedure PMSetActivePageWithControl(var Message : TMessage);
      message PM_SETACTIVEPAGEWITHCONTROL;
      {* - при активации закладки, если навигатор был свернут, то он
           разворачивается. }
    procedure WMEraseBkgnd(var Message: TMessage);
      message WM_ERASEBKGND;
      {-}
    procedure WMKeyDown(Var Msg: TWMKeyDown);
      message WM_KEYDOWN;
      {-}
    procedure WMSysKeyDown(var Msg: TWMSysKeyDown);
      message WM_SYSKEYDOWN;
      {-}
  protected
  // protected methods
    function  IsHandledShortcut(var Msg: TWMKeyDown): Boolean;
      {-}
    procedure GetSiteInfo(Client            : TControl;
                          var InfluenceRect : TRect;
                          MousePos          : TPoint;
                          var CanDock       : Boolean);
      override;
      {-}
    procedure RequestTabPosition;
      override;
      {-}
  public
  // public methods
    constructor Create(AOwner : TComponent);
      override;
      {-}
    procedure DoActivePrevPage;
      override;
      {-}
    procedure Notification(AComponent : TComponent;
                           Operation  : TOperation);
      override;
      {* - удаляем из списка компонентов навигатора на форме. }
    procedure DockDrop(Source: TDragDockObject; X, Y: Integer);
      override;
      {-}
  end;//TnpPageControl

  RnpPageControl = class of TnpPageControl;

  TnpHideDirect = (hdNone, hdHide, hdShow);
    {* - направление скрытия навигатора в режиме nsAutoHide. }

  TnpChangeLink = class(TnpObject)
  {* - используется для уведомления об изменении состояния навигатора
       (nsAutoHide, nsNormal, nsMinimazed). }
  private
  // property fields
    fOnStateChanged : TNotifyEvent;
  public
  // public properties
    property OnStateChanged : TNotifyEvent
      read fOnStateChanged
      write fOnStateChanged;
      {-} 
  end;//TnpChangeLink

  TnpContainerSurface = class(TnpCustomControl)
  private
  // property fields
    f_Surface : TnpSurface;
  private
  // messages
    procedure WMEraseBkgnd(var Message : TWMEraseBkgnd);
      message WM_ERASEBKGND;
      {* - иначе границы toolbar-ов не прорисовываются. }
  private
  // property methods
    procedure pm_SetSurface(const Value : TnpSurface);
      {-}
  public
  // public methods
    class function Make(aSurface : TnpSurface) : TnpContainerSurface;
      {-}
  public
  // public properties
    property Surface : TnpSurface
      read f_Surface
      write pm_SetSurface;
      {-}
  end;//TnpContainerSurface

  TnpSplitter = class(TnpCustomControl)
  {* - сплиттер используемый в навигаторе. }
  private
  // property fields
    f_Surface          : TnpSurface;
    f_MouseDownPoint   : TPoint;
    f_IsHideButtonDown : Boolean;
    f_HideButtonHint   : THintWindow;
    f_IsMouseDown      : Boolean;
  private
  // internal methods
    procedure splShowHint(X, Y : Integer);
      {-}
    procedure splHideHint;
      {-}
    function CreateButtonHint : THintWindow;
      {-}
    procedure UpdateCursor(aButton : Boolean = True);
      {-}
    procedure DrawButton(aCanvas : TCanvas = nil);
      {-}
    function GetButtonRect : TRect;
      {* - определяет прямоугольник для кнопки. }
    procedure SetSizeCursor;
      {* - устанавливает курсор для изменения размеров. }
    function  IsHandledShortcut(var Msg: TWMKeyDown): Boolean;
      {-}
    procedure WMKeyDown(Var Msg: TWMKeyDown);
      message WM_KEYDOWN;
      {-}
    procedure WMSysKeyDown(var Msg: TWMSysKeyDown);
      message WM_SYSKEYDOWN;
      {-}
    procedure CNKeyDown(Var Msg: TWMKeyDown);
      message CN_KEYDOWN;
      {-}
    procedure CNSysKeyDown(var Msg: TWMSysKeyDown);
      message CN_SYSKEYDOWN;
      {-}
  private
  // property methods
    procedure pm_SetSurface(const Value: TnpSurface);
      {-}
    procedure pm_SetButtonDown(const Value : Boolean);
      {-}
  protected
  // protected methods
    procedure Paint;
      override;
      {-}
    procedure MouseMove(Shift  : TShiftState;
                        X, Y   : Integer);
      override;
      {-}
    procedure MouseDown(Button : TMouseButton;
                        Shift  : TShiftState;
                        X, Y   : Integer);
      override;
      {-}
    procedure MouseUp(Button : TMouseButton;
                      Shift  : TShiftState;
                      X, Y   : Integer);
      override;
      {-}
    procedure Cleanup;
      override;
      {-}
  protected
  // protected properties
    property IsHideButtonDown: Boolean
      read f_IsHideButtonDown
      write pm_SetButtonDown;
      {-}
    property HideButtonHint: THintWindow
      read f_HideButtonHint
      write f_HideButtonHint;
      {* - подсказка к кнопке "скрыть\развернуть". }
    property IsMouseDown: Boolean
      read f_IsMouseDown
      write f_IsMouseDown;
      {-}
  public
  // public methods
    constructor Create(aOwner : TComponent);
      override;
      {-}
    class function Make(aSurface : TnpSurface) : TnpSplitter;
      {-}
  public
  // public methods
    property Surface: TnpSurface
      read f_Surface
      write pm_SetSurface;
      {-}
  end;//TnpSplitter

  TnpSurface = class(TnpCustomControl)
  {* - Подложка. На подложке лежат TnpHeader (заголовок ) и PageControl. }
  private
  // property fields
    f_Navigator   : TvtNavigator;
    f_Header      : TnpHeader;
    f_PageControl : TnpPageControl;
    f_Container   : TnpContainerSurface;
    f_Splitter    : TnpSplitter;
    f_Link        : TnpChangeLink;
    //f_Panel       : TvtPanel;
  private
  // internal methods
    procedure InitAutoHidePosition;
      {* - обновить Left окна. }
    procedure OnStateChanged(Sender : TObject);
      {-}
  private
  // property methods
    function pm_GetSize: Integer;
      {-}
    procedure pm_SetNavigator(const Value : TvtNavigator);
      {-}
    procedure pm_SetHeader(const Value : TnpHeader);
      {-}
    procedure pm_SetPageControl(const Value : TnpPageControl);
      {-}
  private
  // messages
    procedure WMEraseBkgnd(var Message : TMessage);
      message WM_ERASEBKGND;
      {-}
  protected
  // protected methods
    procedure AdjustClientRect(var Rect : TRect);
      override;
      {-}
    procedure Paint;
      override;
      {-}
  public
  // public methods
    constructor Create(AOwner : TComponent);
      override;
      {-}
    procedure Cleanup;
      override;
      {-}
    procedure SetSizeMini;
      {-}
    procedure DefineSplitterAlign;
      {-}
  public
  // public properties
    property Size : Integer
      read pm_GetSize;
      {-}
    property Navigator : TvtNavigator
      read f_Navigator
      write pm_SetNavigator;
      {-}
    property PageControl : TnpPageControl
      read f_PageControl
      write pm_SetPageControl;
      {-}
    property Header : TnpHeader
      read f_Header
      write pm_SetHeader;
      {-}
    property Splitter: TnpSplitter
      read f_Splitter;
      {-}
  end;//TnpSurface

  TnpButton = class({$IfDef NavigatorPanelNeedsTb97}
                    TCustomToolbarButton97
                    {$Else}
                    TSpeedButton
                    {$EndIf NavigatorPanelNeedsTb97})
  {* - кнопки использующиеся в TvtNavigator. }
  private
  // internal fields
    f_BtnType   : TnpButtonType;
    f_Navigator : TvtNavigator;
  private
  // messages
    procedure CMHintShow(var Message : TCMHintShow);
      message CM_HINTSHOW;
      {-}
    procedure WMMouseMove(var Message : TWMMouseMove);
      message WM_MOUSEMOVE;
      {-}
  public
  // public methods
    constructor Create(aOwner     : TComponent;
                       aNavigator : TvtNavigator;
                       aBtnType   : TnpButtonType);
      reintroduce;
      {-}
    function MakeHint : String;
      {-}
  end;//TnpButton

  TnpHeader = class(TnpCustomControl)
  {* - панель отображающаяся в навигаторе. Содержит кнопки включения(отключения
       автоскрытия) и скрытия панели до размеров вкладки. Событие OnMouseDown
       инициализирует перетаскиваение активного компонента. }
  private
    f_Canvas           : Tl3WinControlCanvas;
    f_IsDragBegining   : Boolean;
    f_Navigator        : TvtNavigator;
    f_Link             : TnpChangeLink;
    f_Size             : Integer;
    // Buttons
    f_HideButton       : TnpButton;
    f_AutoHideButton   : TnpButton;
    f_CloseButton      : TnpButton;
    // Images
    f_ButtonsImageList : TCustomImageList;
    f_CloseImage       : TImageIndex;
    f_AutoHideOnImage  : TImageIndex;
    f_AutoHideOffImage : TImageIndex;
    f_HideRightImage   : TImageIndex;
    f_HideLeftImage    : TImageIndex;
    f_HideUpImage      : TImageIndex;
    f_HideDownImage    : TImageIndex;
  private
  // internal methods
    procedure HideCloseButton;
      {-}
    procedure ShowCloseButton(const aHandler: IvcmFormHandler);
      {-}
    procedure CloseButtonVisible(aValue: Boolean);
      {* - изменить видимость кнопки закрыть, установить кнопку видимой без
           установленного обработчика OnClick нельзя. }
    procedure UpdateImages;
      {* - обновить иконки на кнопках. }
    procedure UpdateSize;
      {-}
    procedure UpdatePositions;
      {-}
    procedure UpdateHideImage;
      {-}
    procedure UpdateCloseImage;
      {-}
    procedure UpdateAutoHideImage;
      {-}
    function GetRectLines: TRect;
      {-}
    procedure DoStateChanged;
      {-}
    procedure OnStateChanged(Sender : TObject);
      {* - событие возникает при изменении состояния навигатора. }
  private
  // property methods
    procedure pm_SetHideUpImage(const Value : TImageIndex);
      {-}
    procedure pm_SetHideDownImage(const Value : TImageIndex);
      {-}
    procedure pm_SetButtonsImageList(const Value : TCustomImageList);
      {-}
    function pm_GetSize: Integer;
      {-}
    procedure pm_SetSize(const Value: Integer);
      {-}
    function pm_GetOnAutoHide : TNotifyEvent;
      {-}
    function pm_GetOnHide : TNotifyEvent;
      {-}
    procedure pm_SetOnAutoHide(const Value : TNotifyEvent);
      {-}
    procedure pm_SetOnHide(const Value : TNotifyEvent);
      {-}
    procedure pm_SetNavigator(const Value : TvtNavigator);
      {-}
    procedure pm_SetCloseImage(const Value : TImageIndex);
      {-}
    procedure pm_SetAutoHideOffImage(const Value : TImageIndex);
      {-}
    procedure pm_SetAutoHideOnImage(const Value : TImageIndex);
      {-}
    procedure pm_SetHideLeftImage(const Value : TImageIndex);
      {-}
    procedure pm_SetHideRightImage(const Value : TImageIndex);
      {-}
    function GetAlign: TAlign;
    procedure SetAlign(Value : TAlign);
      {-}
  private
  // properties
    property IsDragBegining: Boolean
      read f_IsDragBegining
      write f_IsDragBegining;
      {* - определяет была ли инициализирована операция Control.IsDragBegining от
           заголовка. }
  protected
  // inherited methods
    procedure AdjustClientRect(var Rect: TRect);
      override;
      {-}
    procedure Paint;
      override;
      {-}
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState;
      X, Y: Integer);
      override;
      {-}
  // messages
    procedure WMEraseBkgnd(var Message : TWMEraseBkgnd);
      message WM_ERASEBKGND;
      {-}
  public
  // public methods
    constructor Create(aOwner: TComponent);
      override;
      {-}
    procedure Cleanup;
      override;
      {-}
  public
  // public properties
    property Align: TAlign
      read GetAlign
      write SetAlign;
      {-}
    property CloseImage : TImageIndex
      read f_CloseImage
      write pm_SetCloseImage
      default 6;
      {* - иконка для кнопки "Закрыть" плавающего навигатора. }
    property AutoHideOnImage : TImageIndex
      read f_AutoHideOnImage
      write pm_SetAutoHideOnImage
      default 0;
      {* - иконка для кнопки "Автоскрытие". }
    property AutoHideOffImage : TImageIndex
      read f_AutoHideOffImage
      write pm_SetAutoHideOffImage
      default 1;
      {* - иконка для кнопки "Автоскрытие". }
    property HideLeftImage : TImageIndex
      read f_HideLeftImage
      write pm_SetHideLeftImage
      default 2;
      {* - иконка для кнопки "Скрыть навигатор". }
    property HideRightImage : TImageIndex
      read f_HideRightImage
      write pm_SetHideRightImage
      default 3;
      {* - иконка для кнопки "Скрыть навигатор". }
    property HideUpImage : TImageIndex
      read f_HideUpImage
      write pm_SetHideUpImage
      default 4;
      {* - иконка для кнопки "Скрыть навигатор". }
    property HideDownImage : TImageIndex
      read f_HideDownImage
      write pm_SetHideDownImage
      default 5;
      {* - иконка для кнопки "Скрыть навигатор". }
    property Size: Integer
      read pm_GetSize
      write pm_SetSize;
      {-}
    property OnHide : TNotifyEvent
      read pm_GetOnHide
      write pm_SetOnHide;
      {-}
    property OnAutoHide : TNotifyEvent
      read pm_GetOnAutoHide
      write pm_SetOnAutoHide;
      {-}
    property Navigator : TvtNavigator
      read f_Navigator
      write pm_SetNavigator;
      {-}
    property ButtonsImageList : TCustomImageList
      read f_ButtonsImageList
      write pm_SetButtonsImageList;
      {* - ImageList для кнопок. }
    property CloseButton: TnpButton
      read f_CloseButton;
      {* - кнопка закрыть. }
    property HideButton: TnpButton
      read f_HideButton;
      {* - кнопка скрыть. }
    property AutoHideButton: TnpButton
      read f_AutoHideButton;
      {* - кнопка автоскрытия. }
  end;//TnpHeader

  TnpFloatingWindow = class;

  RnpFloatingWindow = class of TnpFloatingWindow;

  TOnSaveSizeNavigator = procedure (Sender: TObject; aSize: Integer) of Object;
    {* - возникает при уничтожении навигатора, чтобы клиент мог сохранить
         размеры навигатора. }
  TOnLoadSizeNavigator = procedure (Sender : TObject; var aSize : Integer) of Object;
    {* - вызывается при пристыковки первой закладки, до этого момента навигатор
         мал и не видим. }

  TNavigatorState = (nsNormal, nsMinimazed, nsAutoHide);
    {* - состояния навигатора. Нормальное, Минимизирован, Автоскрыти. }

  TvtNavigator = class(TnpCustomPanel,
                       IvcmFormHandlersPublisher
                       {$IfDef Nemesis}
                       ,IvcmState
                       ,IvcmToolbarNotifier
                       {$EndIf Nemesis})
  {* - управляет стыковкой(отстыковкой) закладок;
     - управляет режимом автоскрытия; минимизирует навигатор;
     - изменяет размер навигатора; }
  private
  // internal fields
    f_MainForm              : TCustomForm;
      {* - главная форма на которой находится навигатор. }
    f_ClickOnTab            : Boolean;
      {* - пользователь щелкнул на закладке. }
    f_SplitterRect          : TRect;
    f_ActiveControl         : TControl;
      {* - элемент управления на активной закладке перед отстыковкой. }
    f_IsInitDockDrop        : Boolean;
    f_ClickPoint            : TPoint;
      {* - точка клика по отношению к координатам навигатора. }
    f_DockRect              : TRect;
    f_EndDockClient         : TControl;
    f_NavigatorList         : Tl3ObjectList;
    f_NavigatorOnForm       : TvtNavigator;
      {* - навигатор от которого произошол данный навигатор. Метод нужен для
           того чтобы методы возвращали все навигаторы которое произошли от
           навигатора на форме. }
    f_ParentNavigatorHandle : THandle;
    f_ImportNavigator       : TvtNavigator;
      {* - при осуществлении стыковки компонента если свойство заполнено, то
           импортиртируются все закладки из плавающего навигатора после чего он
           удаляется. }
    f_ExportPageControl     : TnpPageControl;
    f_FloatNavigator        : TnpFloatingWindow;
      {* - плавающий навигатор в котором находится TvtNavigator. }
    f_SetCursorResize        : Boolean;
    f_MouseDown              : Boolean;
    f_Header                 : TnpHeader;
    f_PageControl            : TnpPageControl;
    f_Surface                : TnpSurface;
    f_State                  : TNavigatorState;
    f_HideDirect             : TnpHideDirect;
    f_DblClickUnDock         : Boolean;
      {* - закладка была отстыкована по DblClick-у. }
    f_CountUndock            : Integer;
      {* - счетчик отстыкованных по DblClick-у закладок, нужен для каскадного
           расположения отстыкованных закладок. }
    f_SizeMini               : Integer;
      {* - размер навигатора в минимизированном состоянии. }
    f_ParentRestore          : Boolean;
      {* - родительской окно было восстановлено. }
    f_RelativeNavigator      : TvtNavigator;
    f_FormWasMinimized       : Boolean;
      {* - форма была минимизирована. }
  private
  // property fields
    f_IsFloatingOnShow       : Boolean;
    f_AutoHideFloat          : Boolean;
    f_TimerFloat             : TTimer;
      {* - используется для эффекта всплывание. }
    f_TimerDelay             : TTimer;
      {* - используется при генерации задержки в режиме автоскрытие с
           задержкой. }
    f_DoDelay                : Boolean;
    f_IsDelay                : Boolean;
      {* - переменная устанавливается при изменении состояния навигатора,
           сбрасывается при наступлении события OnTimer. }
    f_DelayOnAutoHide        : Boolean;
      {* - делать задержку при автоскрытии навигатора. }
    f_DelayIntervalOnShow    : Integer;
    f_DelayIntervalOnHide    : Integer;
    f_UnDockFromFloat        : Boolean;
      {* - свойство определяет можно ли из плавающего навигатора. }
    f_OnStateChanged         : TNotifyEvent;
    f_DockInSelf             : Boolean;
      {* - если форма плавает и клиент отстыкован в никуда, то стыкуем его
           обратно. }
    f_Float                  : Boolean;
      {* - навигатор является плавающим на форме. }
    f_SizeEmpty              : Integer;
      {* - размер пустой панели (закладок нет). }
    f_SizeNormal             : Integer;
      {* - размер навигатора в развернутом состоянии. }
    f_Swim                   : Boolean;
      {* - если True, то навигатор наплывает на компоненты находящиеся под ним,
           иначе при выплывании двигает их в сторону. }
    f_SingleFloatNavigator   : Boolean;
    f_OnSaveSize             : TOnSaveSizeNavigator;
    f_OnLoadSize             : TOnLoadSizeNavigator;
    f_ShowActivePageInHeader : Boolean;
    f_ChangeLinks            : Tl3ObjectList;
      {* - в списке содержатся TNotifyEvent клиентов подписанных на нотификацию
           об измнении состояния навигатора. }
    f_Activate               : Boolean;
    f_CloseHint           : String;
    f_AutoHideOffHint     : String;
    f_AutoHideOnHint      : String;
    f_MinimazedOffHint    : String;
    f_MinimazedOnHint     : String;
  private
  // IvcmFormHandlersPublisher
    procedure PublishFormHanders(const aCloseHandler: IvcmFormHandler);
    procedure IvcmFormHandlersPublisher.Publish = PublishFormHanders;
      {-}
  private
  // методы интерфейса IvcmToolbarNotifier
    {$IfDef Nemesis}
    procedure SmallToolbarSize(aValue : Integer);
      {-}
    {$EndIf Nemesis}  
  private
  // property methods
    function pm_GetRelativeNavigator: TvtNavigator;
      {* - навигатор сосед. }
    function pm_GetClientControl: TWinControl;
      {* - клиентский компонент с которым граничит навигатор. }
    function pm_GetCloseImage : TImageIndex;
      {-}
    procedure pm_SetCloseImage(const Value : TImageIndex);
      {-}
    function pm_GetAutoHideOnImage : TImageIndex;
      {-}
    procedure pm_SetAutoHideOnImage(const Value : TImageIndex);
      {-}
    function pm_GetAutoHideOffImage : TImageIndex;
      {-}
    procedure pm_SetAutoHideOffImage(const Value : TImageIndex);
      {-}
    function pm_GetHideLeftImage : TImageIndex;
      {-}
    procedure pm_SetHideLeftImage(const Value : TImageIndex);
      {-}
    function pm_GetHideRightImage : TImageIndex;
      {-}
    procedure pm_SetHideRightImage(const Value : TImageIndex);
      {-}
    function pm_GetHideUpImage : TImageIndex;
      {-}
    procedure pm_SetHideUpImage(const Value : TImageIndex);
      {-}
    function pm_GetHideDownImage : TImageIndex;
      {-}
    procedure pm_SetHideDownImage(const Value : TImageIndex);
      {-}
    procedure pm_SetActivate(const Value : Boolean);
      {-}
    procedure pm_SetShowActivePageInHeader(const aValue : Boolean);
      {-}
    function pm_GetIsMinimazed: Boolean;
      {-}
  private
  // internal methods
    function CorrectSize(const aSizeNormal: Integer): Integer;
      {* - откорректировать размер. }
    function RelativeAlign: TAlign;
      {* - выравнивание навигатора - соседа. }
    function FindRelative(const aAlign: TAlign): TvtNavigator;
      {* - найти навигатор на той же форме с указанным выравниванием. Делаем
           допущение, что на форме может быть только один навигатор с указанным
           типом выравнивания. }
    function CalcBounds(const aSizeNormal: Integer): TRect;
      {* - вычислить новые границы с указанным нормальным размером. }
    function CalcSize(const aBounds: TRect): Integer;
      {* - вычисляет размер. }
    function CorrectBounds(const aBounds: TRect): TRect;
      {* - корректирует новые размеры навигатора. Необходимо при перетаскивании
           навигатора и при сплиттинге. }
    procedure UpdateSize;
      {-}
    procedure AutoUpdateSize;
      {-}
    procedure NormalUpdateSize;
      {-}
    procedure ResetDragInfo;
      {* - сбрасывает флаги используемые при перетаскивании. }
    function IsUndockByUser : Boolean;
      {* - True, если закладки отстыкованы пользователем. }
    procedure OnDblClickUndock(var CanUnDock : Boolean;
                               aControl      : TControl);
      {* - не разрешаем отстыковывать закладку, пристыковываем её на форму. }
    procedure CreateSurface;
      {* - создаёт TnsSurface. }
    procedure CreateHeader;
      {* - создаёт TnsHeader. }
    procedure CreatePageControl;
      {* - создаёт TnpPageControl. }
    procedure InitMainForm(aOwner : TComponent);
      {* - устанавливает главную форму, которой принадлежит навигатор. }
    procedure RecalcSize;
      {-}
    procedure SetSize(const aValue : Integer;
                      aControl     : TControl = nil);
      {* - устанавливает размер навигатора в зависимости от _Align }
    procedure UpdateState;
      {* - действует используя f_State. }
    procedure PlaceSurface;
      {-}
    procedure AttachSurface;
      {-}
    procedure DetachSurface;
      {-}
    procedure SetSizeMini;
      {-}
    procedure DoAutoHide;
      {* - подготавливает компоненты при включении режима автоскрытия. }
    function CalcNewFloatBounds: TRect;
      {-}
    procedure SetDockRect(DragDockObject: TDragDockObject);
      {-}
    procedure InitDrag(aControl : TControl);
      {-}
    function CheckControl(aControl: TControl): Boolean;
      {-}
    function DoLoadSize : Integer;
      {-}
    function FindFloatNavigator: TnpFloatingWindow;
      {* - процедура возвращает плавающий навигатор, если он не создан, то nil. }
  private
  // messages
    procedure CMnpChangeActivate(var Message : TMessage);
      message CM_npChangeActivate;
      {* - см. комментарий к CM_npChangeActivate. }
    procedure CMAfterUndock(var Message: TMessage);
      message CM_npAfterUndock;
      {* - см. комментарий к CM_npAfterUndock. }
    procedure CMDelNavFromList(var Message: TMessage);
      message CM_npDeleteFromList;
      {* - см. комментарий к CM_npDeleteFromList. }
    procedure CMNPDoActionWithFormControls(var Message : TMessage);
      message CM_npDoActionWithFormControls;
      {* - см. комментарий к CM_npDoActionWithFormControls. }
    procedure CMnpDockToFloatWindow(var Message : TMessage);
      message CM_npDockToFloatWindow;
      {* - см. комментарий к CM_npDockToFloatWindow. }
    procedure WMEraseBkgnd(var Message : TWMEraseBkgnd);
      message WM_ERASEBKGND;
      {-}
  private
  // methods
    procedure UpdateCloseButton;
      {* - обновить кнопку закрыть вкладку. }
    function GetNewBoundsFromPoint(X, Y: Integer): TRect;
      {-}
    procedure AddNavigator(P: TnpFloatingWindow);
      {-}
    procedure AutoHideUpdate;
      {-}
    //procedure CheckSize(var aSize: Integer);
      {-}
    procedure CloseDelay;
      {-}
    procedure DelNavigator(P: TnpFloatingWindow);
      {-}
    function DockToFloatNavigator(aControl : TControl) : TnpFloatingWindow;
      {* - если клиент компонента не пристыкован ни к одному навигатору, то он
           автоматически пристыковывается к плавающему навигатору. }
    procedure Minimazed;
      {-}
    procedure DoSaveSize;
      {-}
    procedure DrawSplit(const aRect: TRect);
      {-}
    procedure InitDockDrop;
      {-}
    procedure ModeAutoUpdate;
      {-}
    procedure ModeHide;
      {-}
    procedure ModeNormalUpdate;
      {-}
    procedure ModeShow;
      {-}
    procedure ModeStateUpdate;
      {* - пока скрывает (если ничего не пристыковано) / показывает PageControl. }
    procedure ModeStateUpdateAfter;
      {* - посылает сообщение CM_npAfterUndock. }
    procedure MovePagesToNavigator(var Value: TvtNavigator; DockControl : TControl);
      {-}
    procedure OpenDelay;
      {-}
    procedure PaintSpliter(X, Y              : Integer;
                           aDrawSplitterType : TnpDrawSplitterTypes);
      {-}
    {$ifdef Nemesis}
    function SaveState(out theState : IUnknown;
                       aStateType   : TvcmStateType): Boolean;
      {-}
    function LoadState(const aState : IUnknown;
                       aStateType   : TvcmStateType): Boolean;
      {-}
    {$endif Nemesis}
  private
  // events
    procedure OnEndDockControl(Sender, Target: TObject; X, Y: Integer);
      {-}
    procedure OnTabSheetClick(Sender: TObject; Page: TElTabSheet);
      {-}
    procedure OnHide(Sender: TObject);
      {-}
    procedure OnAutoHide(Sender: TObject);
      {-}
    procedure OnPageControlResize(Sender: TObject);
      {-}
    procedure OnPageControlChange(Sender: TObject);
      {-}
    procedure OnTimerFloat(Sender: TObject);
      {-}
    procedure OnTimerDelay(Sender: TObject);
      {-}
    procedure OnPageControlUnDock(Sender    : TObject;
                                  Client    : TControl;
                                  NewTarget : TWinControl;
                                  var Allow : Boolean);
      {-}
    procedure OnStartDragControl(Sender       : TObject;
                                 aDragControl : TControl);
      {-}
    {$IfDef Nemesis}
    procedure OnFormPositionDockRect(Sender         : TObject;
                                     DragDockObject : TDragDockObject);
      {-}
    {$EndIf Nemesis}
  private
  // property methods
    function IsAutoHideOffHint : Boolean;
      {-}
    function IsAutoHideOnHint : Boolean;
      {-}
    function IsMinimazedOffHint : Boolean;
      {-}
    function IsMinimazedOnHint : Boolean;
      {-}
    function IsCloseHint : Boolean;
      {-}
    procedure pm_SetButtonsImageList(const Value : TCustomImageList);
      {-}
    function pm_GetButtonsImageList : TCustomImageList;
      {-}
    function GetActivePageIndex: Integer;
      {-}
    function GetAlign : TAlign;
      {-}
    function GetPage(Index: Integer): TElTabSheet;
      {-}
    function GetPageCount: Integer;
      {-}
    function GetSizeMini: Integer;
      {-}
    procedure SetActivePageIndex(const Value: Integer);
      {-}
    procedure SetAlign(Value : TAlign);
      {-}
    procedure SetSelfSize(ASize: Integer);
      {-}
    procedure SetSizeEmpty(Value: Integer);
      {-}
    procedure SetSizeNormal(Value: Integer);
      {-}
    procedure DoSplit;
      {-}
    procedure SetSwim(const Value: Boolean);
      {-}
    procedure SetFloat(const Value: Boolean);
      {-}
    procedure SetSingleFloatNavigator(const Value: Boolean);
      {-}
    procedure SetDelayOnAutoHide(const Value: Boolean);
      {-}
    procedure SetUndockSize;
      {-}
    function GetImages: TCustomImageList;
      {-}
    procedure SetImages(const Value: TCustomImageList);
      {-}
    procedure pm_SetNavigatorOnForm(const Value: TvtNavigator);
      {-}
    function GetState: TNavigatorState;
      {-}
    procedure SetState(const Value: TNavigatorState);
      {-}
    function GetNavigatorSizeNormal(aControl: TControl) : Integer;
      {-}
    function GetDockRect(aDockSize : Integer = -1): TRect;
      {-}
  protected
  // protected methods
    procedure Notification(AComponent : TComponent;
                           Operation  : TOperation);
      override;
      {-}
    procedure GetSiteInfo(Client            : TControl;
                          var InfluenceRect : TRect;
                          MousePos          : TPoint;
                          var CanDock       : Boolean);
      override;
      {-}
    procedure DoStateChanged(aNavigatorState : Boolean = False);
      virtual;
      {* - возникает при изменении состава закладок, или состояния навигатора
           (aNavigatorState). }
    procedure SetName(const Value: TComponentName);
      override;
      {-}
    procedure PositionDockRect(DragDockObject: TDragDockObject);
      override;
      {-}
    procedure Resize;
      override;
      {-}
    procedure DockOver(Source: TDragDockObject; X, Y: Integer;
      State: TDragState; var Accept: Boolean);
      override;
      {-}
    procedure Paint;
      override;
      {-}
    procedure SetParent(AParent : TWinControl);
      override;
      {-}
    function GetPageControlClass: RnpPageControl;
      virtual;
      {* - получить класс компонента с закладками. }
    function GetFloatingWindowClass: RnpFloatingWindow;
      virtual;
      {* - получить класс плавающего окна. }
  protected
  // protected properties
    property Surface: TnpSurface
      read f_Surface;
      {-}
    property RelativeNavigator: TvtNavigator
      read pm_GetRelativeNavigator;
      {* - навигатор сосед. }
    property ClientControl: TWinControl
      read pm_GetClientControl;
      {* - клиентский компонент с которым граничит навигатор. }
    property SizeMini : Integer
      read GetSizeMini;
      {-}
    property NavigatorOnForm: TvtNavigator
      read f_NavigatorOnForm
      write pm_SetNavigatorOnForm;
      {-}
    property Swim: Boolean
      read f_Swim
      write SetSwim
      default True;
      {-}
    property Activate : Boolean
      read f_Activate
      write pm_SetActivate;
      {* - активизирует, деактивизирует навигатор. }
    property Header : TnpHeader
      read f_Header;
      {-}
  public
  // public methods
    constructor Create(AOwner: TComponent);
      override;
      {-}
    procedure Cleanup;
      override;
      {-}
    procedure AfterDestroyCalled;
      override;
      {-}
    procedure RegisterStateChanged(aLink : TnpChangeLink);
      {* - подписать клиента на нотификацию об изменении состояния навигатора. }
    procedure UnRegisterStateChanged(aLink : TnpChangeLink);
      {* - отписать клиента от нотификации об изменении состояния навигатора. }
    function IsActiveControl(aControl: TControl): Boolean;
      {-}
    procedure DockDrop(Source: TDragDockObject; X, Y: Integer);
      override;
      {-}
    procedure SetBounds(ALeft, ATop, AWidth, AHeight: Integer);
      override;
      {-}
    function MinBtnHint : String;
      {-}
    procedure Assign(aDest : TPersistent);
      override;
      {-}
    procedure AssignNav(aDest : TvtNavigator);
      {-}
    procedure hCBT(const Code   : Integer;
                   const WParam : WPARAM;
                   const LParam : LPARAM);
      {* - сообщение получаемое от WH_CBT. }
    procedure hGetMessage(const aMessage : PMsg);
      {* - сообщение получаемое навигатором от WH_GETMESSAGE. }
  public
  // public properties
    property IsMinimazed : Boolean
      read pm_GetIsMinimazed;
      {-}
    property Pages[Index: Integer]: TElTabSheet
      read GetPage;
      {-}
    property ActivePageIndex: Integer
      read GetActivePageIndex
      write SetActivePageIndex;
      {-}
    property PageCount: Integer
      read GetPageCount;
      {-}
    property PageControl: TnpPageControl
      read f_PageControl;
      {-}
    property Float: Boolean
      read f_Float
      write SetFloat;
      {-}
    property State : TNavigatorState
      read GetState
      write SetState;
      {-}
    property ShowActivePageInHeader : Boolean
      read f_ShowActivePageInHeader
      write pm_SetShowActivePageInHeader;
      {* - выводить иконку и название активной закладки в заголовке навигатора. }
  published
  // published properties
    property AutoHideOffHint : String
      read f_AutoHideOffHint
      write f_AutoHideOffHint
      stored IsAutoHideOffHint;
      {-}
    property AutoHideOnHint : String
      read f_AutoHideOnHint
      write f_AutoHideOnHint
      stored IsAutoHideOnHint;
      {-}
    property MinimazedOnHint : String
      read f_MinimazedOnHint
      write f_MinimazedOnHint
      stored IsMinimazedOnHint;
      {-}
    property MinimazedOffHint : String
      read f_MinimazedOffHint
      write f_MinimazedOffHint
      stored IsMinimazedOffHint;
      {-}
    property CloseHint : String
      read f_CloseHint
      write f_CloseHint
      stored IsCloseHint;
      {-}
    property OnSaveSize : TOnSaveSizeNavigator
      read f_OnSaveSize
      write f_OnSaveSize;
      {-}
    property OnLoadSize : TOnLoadSizeNavigator
      read f_OnLoadSize
      write f_OnLoadSize;
      {-}
    property Images: TCustomImageList
      read GetImages
      write SetImages;
      {-}
    property AutoHideFloat: Boolean
      read f_AutoHideFloat
      write f_AutoHideFloat
      default False;
      {-}
    property DelayIntervalOnShow: Integer
      read f_DelayIntervalOnShow
      write f_DelayIntervalOnShow
      default 0;
      {-}
    property DelayIntervalOnHide: Integer
      read f_DelayIntervalOnHide
      write f_DelayIntervalOnHide
      default 1000;
      {-}
    property DelayOnAutoHide: Boolean
      read f_DelayOnAutoHide
      write SetDelayOnAutoHide
      default False;
      {-}
    property SingleFloatNavigator: Boolean
      read f_SingleFloatNavigator
      write SetSingleFloatNavigator
      default True;
      {-}
    property Align: TAlign
      read GetAlign
      write SetAlign
      default alTop;
      {-}
    property SizeEmpty: Integer
      read f_SizeEmpty
      write SetSizeEmpty;
      {-}
    property SizeNormal: Integer
      read f_SizeNormal
      write SetSizeNormal;
      {-}
    property OnStateChange : TNotifyEvent
      read f_OnStateChanged
      write f_OnStateChanged;
      {-}
    property UnDockFromFloat: Boolean
      read f_UnDockFromFloat
      write f_UnDockFromFloat;
      {-}
    property ButtonsImageList : TCustomImageList
      read pm_GetButtonsImageList
      write pm_SetButtonsImageList;
      {* - ImageList для кнопок. }
    property CloseImage : TImageIndex
      read pm_GetCloseImage
      write pm_SetCloseImage
      default 6;
      {* - иконка для кнопки "Закрыть" плавающего навигатора. }
    property AutoHideOnImage : TImageIndex
      read pm_GetAutoHideOnImage
      write pm_SetAutoHideOnImage
      default 0;
      {* - иконка для кнопки "Автоскрытие". }
    property AutoHideOffImage : TImageIndex
      read pm_GetAutoHideOffImage
      write pm_SetAutoHideOffImage
      default 1;
      {* - иконка для кнопки "Автоскрытие". }
    property HideLeftImage : TImageIndex
      read pm_GetHideLeftImage
      write pm_SetHideLeftImage
      default 2;
      {* - иконка для кнопки "Скрыть навигатор". }
    property HideRightImage : TImageIndex
      read pm_GetHideRightImage
      write pm_SetHideRightImage
      default 3;
      {* - иконка для кнопки "Скрыть навигатор". }
    property HideUpImage : TImageIndex
      read pm_GetHideUpImage
      write pm_SetHideUpImage
      default 4;
      {* - иконка для кнопки "Скрыть навигатор". }
    property HideDownImage : TImageIndex
      read pm_GetHideDownImage
      write pm_SetHideDownImage
      default 5;
      {* - иконка для кнопки "Скрыть навигатор". }
    property Alignment;
    property Anchors;
    property AutoSize;
    property BevelInner;
    property BevelOuter;
    property BevelWidth;
    property BiDiMode;
    property BorderWidth;
    property BorderStyle;
    property Caption;
    property Color;
    property Constraints;
    property Ctl3D;
    property UseDockManager default True;
    property DockSite
      default true;
    property DragCursor;
    property DragKind;
    property DragMode;
    property Enabled;
    property FullRepaint;
    property Font;
    property ParentBiDiMode;
    property ParentColor;
    property ParentCtl3D;
    property ParentFont;
    property ParentShowHint;
    property PopupMenu;
    property ShowHint;
    property TabOrder;
    property TabStop;
    property Visible;
    property OnCanResize;
    property OnClick;
    property OnConstrainedResize;
    property OnContextPopup;
    property OnDockDrop;
    property OnDockOver;
    property OnDblClick;
    property OnDragDrop;
    property OnDragOver;
    property OnEndDrag;
    property OnEnter;
    property OnExit;
    property OnGetSiteInfo;
    property OnMouseDown;
    property OnMouseMove;
    property OnMouseUp;
    property OnResize;
    property OnStartDrag;
    property OnUnDock;
  end;//TvtNavigator

  RvtNavigator = class of TvtNavigator;

  TnpFloatWindowState = (fwsNormal, fwsMinimized);
  {* - состояния плавающего окна. }

  TnpFloatingWindow = class(Tl3Form, IafwFloatingWindow)
    {* - плавающая форма содержащая плавающий навигатор. Форма создается если
         NewTarget отстыкованного компонента = nil. Форму можно перемещать за
         TnpHeader. При этом вызывается метод IsDragBegining первого компонента
         активной вкладки f_PageControl.ActivePage.Controls[0], если компонент не
         был пристыкован, то форма перемещается в место где была отпущена рамка. }
  private
  // internal fields
    f_FloatID    : Integer;
    f_SizeNormal : Integer;
    f_Navigator  : TvtNavigator;
    f_State      : TnpFloatWindowState;
    f_CloseDisabled : Boolean;
    f_ReactivateDisabled : Boolean;
  private
  // property methods
    procedure pm_SetState(const aValue : TnpFloatWindowState);
      {-}
  private
  // internal methods
    function GetGripperRect : TRect;
      {* - возращает TRect для отрисовки gripper-а. }
    function GetGripperHeight: Integer;
      {* - сторона квадрата в котором отрисовывается gripper. }
    function CheckGripperCursor : Boolean;
      {* - проверяет находится ли курсор в области gripper-а. }
    {$IfDef Nemesis}
    procedure UpdateFloatWindowsBounds;
      {* - устанавливает формам размеры плавающего окна. }
    {$EndIf Nemesis}
  private
  // messages
    procedure WMNCCalcSize(var Message : TWMNCCalcSize);
      message WM_NCCALCSIZE;
      {-}
    procedure WMNCPaint(var Message:TMessage);
      message WM_NCPAINT;
      {-}
    procedure WMNCHitTest(var Message : TWMNCHitTest);
      message WM_NCHitTest;
      {-}
    procedure WMEraseBkgnd(var Message : TWMEraseBkgnd);
      message WM_ERASEBKGND;
      {-}
  private
  // events
    procedure OnChangeState(Sender: TObject);
      {-}
    procedure OnCloseWindow(Sender: TObject);
      {-}
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
      {-}
    procedure FormOnResize(Sender: TObject);
      {-}
    procedure OnTabSheetClick(Sender: TObject; Page: TElTabSheet);
      {-}
    procedure OnDockDrop(Sender: TObject; Source: TDragDockObject;  X, Y: Integer);
      {-}
    procedure DisableClose;
      {-}
    procedure DisableReactivate;
      {-}
  protected
  // protected methods
    procedure CreateParams(var Params: TCreateParams);
      override;
      {-}
    function GetNavigatorClass: RvtNavigator;
      virtual;
      {* - ссылка на класс навигатора. }
    procedure Cleanup;
      override;
      {-}
  public
  // public methods
    function CloseQuery: Boolean;
      override;
      {-}
    constructor CreateNew(AOwner: TComponent; Dummy: Integer = 0);
      override;
      {-}
    procedure SetBounds(ALeft, ATop, AWidth, AHeight: Integer);
      override;
      {-}
  public
  // public properties
    property Navigator: TvtNavigator
      read f_Navigator
      write f_Navigator;
      {-}
    property FloatID : Integer
      read f_FloatID
      write f_FloatID;
      {* - идентификатор навигатора. }
    property State : TnpFloatWindowState
      read f_State
      write pm_SetState;
      {* - состояние плавающего окна. }
  end;//TnpFloatingWindow

{$R *.RES}

implementation

uses
 Types,
 StrUtils,
 vcmUtils, 

 OvcBase,
 OvcConst,

 afwFacade,

 l3String,
 l3ProtoObjectRefList,
 l3Defaults,
 l3CustomControlCanvas,

 {$IfDef Nemesis}
 vcmEntityForm,
 {$EndIf Nemesis}

 vtNavigatorUtils,
 vtInterfaces,
 vtNavigatorRes,
 vtNavigatorFormListPrim,

 npControlsList,
 npNavigatorList
 ;

type
  TnpDoActionWithFormControl =
  {* Действие которое надо выполнить с компонентом на форме, который не куда не
     привязан. }
  (acRedraw,
     {* - компонент нужно перерисовать. Используется после отпускания и
          перерисовки splitter-а навигатора, иначе на компонентах с
          _Align = alNone, оставалась полоса от сплиттера, т.к. их никто не
          перерисовывал (cq: 00015856). }
   acUpInZOrder
     {* - поднять по оси, чтобы после пристыковки навигатора, на заслонить
          лежащий в этом месте компонент. }
  );//TnpDoActionWithFormControl

const
/// Splitter ///////////////////////////////////////////////////////////////////
  cspSize       = 7;
    {* - ширина сплиттера. }
  cspButtonSize = 100;
    {* - ширина/высота кнопки по умолчанию. }
////////////////////////////////////////////////////////////////////////////////

/// Header const ///////////////////////////////////////////////////////////////
  cIntervalLine = 2;
    {* - интервал между линиями. }
  cBorderWidth  = 2;
    {* - ширина линии. }
  cLinesHeight   = 2 * cBorderWidth + cIntervalLine;
    {* - область в которой будут нарисованы линии. }
  cOffsetSecondLine = cBorderWidth + cIntervalLine;
    {* - смещение для второй линии. }
  cButtonSize           = 21;
    {* - размер кнопки заголовка. }
  cIntervalButtonLine   = 1;
    {* - расстояние между кнопккой и линией. }
  cIntervalHeaderButton = 2;
    {* - расстояние между заголовком и кнопкой. }
  cHeaderSize           = 21 + 2*cIntervalButtonLine;
////////////////////////////////////////////////////////////////////////////////

/// Bitmaps name ///////////////////////////////////////////////////////////////
  cBmpHideLeft     = 'HIDELEFT';
  cBmpHideRight    = 'HIDERIGHT';
  cBmpHideTop      = 'HIDETOP';
  cBmpHideBottom   = 'HIDEBOTTOM';
  cBmpAutoHideOff  = 'AUTOHIDEOFF';
  cBmpAutoHideOn   = 'AUTOHIDEON';
  cBmpClose        = 'CLOSE';
////////////////////////////////////////////////////////////////////////////////

/// Buttons hints //////////////////////////////////////////////////////////////
  cAutoHideOffHint  = 'Зафиксировать панель навигации';
  cAutoHideOnHint   = 'Сворачивать панель навигации';
  cMinimazedOnHint  = 'Свернуть';
  cMinimazedOffHint = 'Развернуть';
  cCloseHint        = 'Прикрепить навигатор';
////////////////////////////////////////////////////////////////////////////////

/// Navigator consts ///////////////////////////////////////////////////////////
  cInitSize = 5;
    {* - пустой навигатор. }
  cDefaultNormalSize = 200;
    {* - нормальный размер навигатора. }
  cMinNormalSize = 70;
    {* - минимальный нормальный размер навигатора, если меньше, то он
         сворачивается. }
  cMinClientControlSize = 100;
    {* - минимальная ширина компонента с _Align = alClient, который соседствует
         с навигатором. }
////////////////////////////////////////////////////////////////////////////////

/// Error messages /////////////////////////////////////////////////////////////
  cemIndexOutOfPageCount      = 'Индекс %d выходит за пределы количества компонентов навигатора';
  cemNavigatorAlreadyExists   = 'Добавляемый в список навигатор уже существует в списке родителя';
  cemDeleteNavigatorNotExists = 'Удаляемый навигатор в списке родителя отсутствует';
////////////////////////////////////////////////////////////////////////////////

/// Floating window flags //////////////////////////////////////////////////////
{* - флаги определяющие состояние плавающего окна. Когда vcm форма стыкуется к
     плавающему навигатору, то у нее читается флаг состояния. Он используется
     для  установки навигатора в то состояние, в котором он находился когда в
     нём была форма. }
  cFloatMinimized = $0001;
    {* - минимизирован. }
////////////////////////////////////////////////////////////////////////////////

function TnpCustomPanel.Get_ControlIsPanel: Boolean;
begin
 Result := False;
end;

procedure DoNotifyControls(aOwner       : TComponent;
                         aMsg         : Integer;
                         aWParam      : Integer;
                         aLParam      : Integer);
var
 l_Index : Integer;
begin
 with aOwner do
  for l_Index := 0 to Pred(ComponentCount) do
  begin
   if Components[l_Index] is TWinControl then
    with TWinControl(Components[l_Index]) do
     SendMessage(Handle, aMsg, aWParam, aLParam);
   DoNotifyControls(Components[l_Index], aMsg, aWParam, aLParam);
  end;//for l_Index
end;

procedure TvtNavigator.InitMainForm(aOwner : TComponent);
var
 lOwner : TComponent;
begin
 lOwner := aOwner;
 while Assigned(lOwner) do
 begin
  if (lOwner.Owner = Application) and (lOwner is TCustomForm) then
  begin
   f_MainForm := TCustomForm(lOwner);
   Break;
  end;//(lOwner.Owner = Application) and (lOwner is TCustomForm)
  lOwner := lOwner.Owner;
 end;//while Assigned(lOwner)
end;

function TvtNavigator.IsUndockByUser : Boolean;
begin
 Assert(f_Header <> nil);
 Result := f_Header.IsDragBegining or (f_ClickOnTab and not f_DblClickUnDock);
end;

procedure TvtNavigator.OnDblClickUndock(var CanUnDock : Boolean;
                                           aControl      : TControl);
{* - не разрешаем отстыковывать закладку, пристыковываем её на форму. }
begin
 f_DblClickUnDock := True;
 if f_Float then
 begin
  CanUnDock := False;
  TnpControlsList.Instance.DockOnForm(aControl);
  f_DblClickUnDock := False;
 end;//f_Float
end;

procedure TvtNavigator.CreateSurface;
begin
 f_Surface := TnpSurface.Create(Self);
 with f_Surface do
 begin
  Navigator := Self;
  Parent    := Self;
  Align     := alClient;
 end;//with f_Surface
end;

procedure TvtNavigator.CreateHeader;
begin
 f_Header := TnpHeader.Create(Self);
 f_Surface.Header := f_Header;
 f_Header.Navigator := Self;
 f_Header.Width := f_Header.Size;
 f_Header.OnUnDock := OnPageControlUnDock;
 f_Header.OnHide := OnHide;
 f_Header.OnAutoHide := OnAutoHide;
end;

procedure TvtNavigator.CreatePageControl;
begin
 f_PageControl := GetPageControlClass.Create(Self);
 f_Surface.PageControl := f_PageControl;
 with f_PageControl do
 begin
  Name               := Self.Name;
  f_Navigator := Self;
  DockSite           := True;
  Flat               := True;
  OnUnDock           := Self.OnPageControlUnDock;
  OnTabSheetClick    := Self.OnTabSheetClick;
  OnChange           := Self.OnPageControlChange;
  OnResize           := Self.OnPageControlResize;
  DragPageControl    := True;
  OnStartDragControl := Self.OnStartDragControl;
  OnDblClickUndock   := Self.OnDblClickUndock;
 end;//with f_PageControl
end;

constructor TvtNavigator.Create(AOwner : TComponent);
begin
 inherited Create(AOwner);
 f_NavigatorList := Tl3ObjectList.Create;
 (* Зарегистрируемся *)
 TnpNavigatorList.Instance.Reg(Self);
 (* Главная форма, которой принадлежит навигатор *)
 InitMainForm(AOwner);
 (* interited *)
 Width      := cInitSize;
 if not (csDesigning in ComponentState) then
  BevelOuter := bvNone;
 DockSite   := True;
 (* self *)
 f_SizeMini               := -1;
 f_CountUndock            := 0;
 f_HideDirect             := hdNone;
 f_ChangeLinks            := Tl3ObjectList.Create;
 f_State                  := nsNormal;
 f_IsFloatingOnShow       := False;
 f_IsInitDockDrop         := False;
 f_ShowActivePageInHeader := True;
 f_UnDockFromFloat        := True;
 f_SingleFloatNavigator   := True;
 f_SetCursorResize        := False;
 f_SizeEmpty              := cInitSize;
 f_SizeNormal             := cDefaultNormalSize;
 f_Swim                   := True;
 f_IsDelay                := False;
 f_DoDelay                := False;
 f_DelayIntervalOnShow    := 0;
 f_DelayIntervalOnHide    := 1000;
 f_DelayOnAutoHide        := False;
 f_TimerDelay             := TTimer.Create(Self);
 f_TimerDelay.Enabled     := False;
 f_TimerDelay.OnTimer     := OnTimerDelay;
 f_AutoHideFloat          := False;
 f_TimerFloat             := TTimer.Create(Self);
 f_TimerFloat.Enabled     := False;
 f_TimerFloat.Interval    := 1;
 f_TimerFloat.OnTimer     := OnTimerFloat;
 (* TnpSurface *)
 CreateSurface;
 (* TnpHeader *)
 CreateHeader;
 (* TnpPageControl *)
 CreatePageControl;
 (* Необходимо устанавливать здесь, потому, что в SetAlign используются
    TnpHeader, TnpPageControl *)
 Align := alLeft;
  f_CloseHint        := str_vtBtnCloseHint.AsStr;
  f_AutoHideOffHint  := str_vtAutoHideOffHint.AsStr;
  f_AutoHideOnHint   := str_vtAutoHideOnHint.AsStr;
  f_MinimazedOffHint := str_vtMinimazedOffHint.AsStr;
  f_MinimazedOnHint  := str_vtMinimazedOnHint.AsStr;
 f_FormWasMinimized := False;
end;

procedure TvtNavigator.ModeStateUpdate;
begin
 case f_State of
  nsAutoHide:
   ModeAutoUpdate;
  else
   ModeNormalUpdate;
 end;//case f_State
end;

procedure TvtNavigator.ModeStateUpdateAfter;
begin
 PostMessage(Handle, CM_npAfterUndock, 0, 0);
end;

procedure TvtNavigator.CMnpChangeActivate(var Message : TMessage);
//message CM_npChangeActivate;
var
 l_Activate : Boolean;
begin
 l_Activate := Boolean(Message.WParam);
 if l_Activate then
  if (f_FloatNavigator <> nil) AND f_FloatNavigator.f_ReactivateDisabled then
   Exit;
 Activate := l_Activate;
end;

procedure TvtNavigator.CMAfterUndock(var Message: TMessage);
begin
 ModeStateUpdate;
end;

procedure TvtNavigator.SetAlign(Value : TAlign);
begin
 if Value <> Align then
 begin
  case (Value) of
   alTop:
   begin
    inherited Align := Value;
    f_Header.Align := alLeft;
    f_PageControl.TabPosition := etpTop;
   end;
   alLeft:
   begin
    inherited Align := Value;
    f_Header.Align := alTop;
    f_PageControl.TabPosition := etpLeft;
   end;
   alRight:
   begin
    inherited Align := Value;
    f_Header.Align := alTop;
    f_PageControl.TabPosition := etpRight;
   end;
   alBottom:
    begin
     inherited Align := Value;
     f_Header.Align := alLeft;
     f_PageControl.TabPosition := etpBottom;
    end;
   else
    begin
     if not f_Float then
     begin
      inherited Align := alTop;
      f_Header.Align := alLeft;
     end
     else
     begin
      inherited Align := Value;
      f_Header.Align := alTop;
     end;
     f_PageControl.TabPosition := etpTop;
    end;
  end;
  f_Surface.DefineSplitterAlign;
  f_Header.UpdateImages;
  ModeStateUpdate;
 end;//Value <> Align
end;

function TvtNavigator.GetAlign : TAlign;
begin
 Result := inherited Align;
end;

procedure TvtNavigator.Notification(AComponent : TComponent;
                                    Operation  : TOperation);
  // override;
  {-}
var
 l_Item : Integer;
begin
 inherited Notification(aComponent, Operation);
 if (Operation = opRemove) then
 begin
  if TvtNavigatorFormList.Instance.FindData(TvtFormHandlerID_C(aComponent), l_Item) then
  begin
   AComponent.RemoveFreeNotification(Self);
   TvtNavigatorFormList.Instance.Delete(l_Item);
   UpdateCloseButton;
  end;//if TvtNavigatorFormList.Instance.FindData(l_Form, l_Item) then
 end;//if (Operation = opRemove) then
end;//Notification

procedure TvtNavigator.GetSiteInfo(Client            : TControl;
                                      var InfluenceRect : TRect;
                                      MousePos          : TPoint;
                                      var CanDock       : Boolean);
//override;
begin
 CanDock := f_Activate;
 if CanDock then
 begin
  inherited GetSiteInfo(Client, InfluenceRect, MousePos, CanDock);
  if (f_PageControl.PageCount = 0) and CanDock then
   InfluenceRect := GetDockRect;
 end;//CanDock
end;

procedure TvtNavigator.DoStateChanged(aNavigatorState : Boolean = False);
var
 l_Index : Integer;
begin
 (* ChangeLinks  *)
 for l_Index := 0 to Pred(f_ChangeLinks.Count) do
  with TnpChangeLink(f_ChangeLinks[l_Index]) do
   if Assigned(OnStateChanged) then
    OnStateChanged(Self);
 if aNavigatorState and Assigned(f_OnStateChanged) then
  f_OnStateChanged(Self);
end;

procedure TvtNavigator.PlaceSurface;
var
 l_Left, l_Top, l_Width, l_Height: Integer;
begin
 if State <> nsAutoHide then
  Exit;
 case Align of
  alBottom, alTop:
  begin
   Surface.Width := Width;
   if Align = alBottom then
    Surface.Top := Self.Parent.ClientHeight - f_Surface.Height
   else
    Surface.Top := Self.Top;
  end;//alBottom, alTop:
  alLeft, alRight:
  begin
   Surface.Top := Top; 
   Surface.Height := Height;
   if Align = alRight then
    Surface.Left := Self.Parent.ClientWidth - f_Surface.Width;
  end;//alLeft, alRight:
 end;//case Align of
end;//PlaceSurface

procedure TvtNavigator.Resize;
begin
 inherited Resize;
 if not f_Float then
  PlaceSurface
 else
  f_SizeNormal := f_FloatNavigator.Width;
end;//Resize

procedure TvtNavigator.DockOver(Source: TDragDockObject; X, Y: Integer;
  State: TDragState; var Accept: Boolean);

  procedure SetSizeNormal;
  var
    lParent: TWinControl;
    lNavigator: TvtNavigator;
  begin//SetSizeNormal
    lNavigator := nil;
    
    if f_PageControl.PageCount = 0 then
    begin
      lParent := Source.Control.Parent;
      while (lNavigator = nil) and (lParent <> nil) do
      begin
        if lParent is TvtNavigator then
          lNavigator := lParent as TvtNavigator
        else
          lParent := lParent.Parent;
      end;
    end;
    
    if lNavigator <> nil then
      f_SizeNormal := lNavigator.SizeNormal;
  end;//SetSizeNormal

begin
 inherited DockOver(Source, X, Y, State, Accept);
 Accept := f_Activate;
 if Accept then
 begin
  SetDockRect(Source);
  Accept := True;
 end;//Accept
end;

function TvtNavigator.GetSizeMini : Integer;
var
 lRect : TRect;
 lSize : Integer;
begin
 Result := 0;
 if (f_SizeMini > -1) and (f_PageControl.PageCount > 0) then
 begin
  Result := f_SizeMini;
  Exit;
 end;
 with TnpPageControl(f_PageControl) do
 begin
  if (PageCount > 0) then
  begin
   // иначе не посчитается область закладок в CalcTabAreaSize, потому что ни
   // одна закладка не видима
   if (PageCount = 1) and not Pages[0].TabVisible then
    Pages[0].TabVisible := True;
   lSize := f_PageControl.MaxTabHeight + 20;
   // клиентская область, формы
   lRect := Rect(0, 0, lSize, lSize);
   AdjustClientRect(lRect);
   // область закладок
   case TabPosition of
    etpTop:
     Result := lRect.Top;
    etpBottom:
     Result := lSize - lRect.Bottom;
    etpLeft:
     Result := lRect.Left;
    etpRight:
     Result := lSize - lRect.Right;
   end;//case TabPosition
   // добавим ширину сплиттера, у плавающего навигатора сплиттер отсутствует,
   // его не учитываем
   if not f_Navigator.Float then
    Inc(Result, cspSize);
   // кешируем результат
   f_SizeMini := Result;
  end;//PageCount > 0
 end;//with TnpPageControl(f_PageControl)
end;

function TvtNavigator.CheckControl(aControl: TControl): Boolean;
var
 l_Index: Integer;
begin
 l_Index := 0;
 Result := True;
 while Result and (l_Index <= Pred(f_PageControl.PageCount)) do
 begin
  if (f_PageControl.Pages[l_Index].ControlCount > 0) then
   Result := not (f_PageControl.Pages[l_Index].Controls[0] = aControl)
  else
   Result := true; 
  (* такой компонент уже есть, проверим его позицию *)
  if not Result then
   aControl.Align := alClient;
  Inc(l_Index);
 end;//while Result and (l_Index <= Pred(f_PageControl.PageCount))
end;

procedure TvtNavigator.MovePagesToNavigator(var Value   : TvtNavigator;
                                            DockControl : TControl);

  procedure DoDockControl;
  begin//DoDockControl
    if DockControl <> nil then
    begin
     if DockControl is TForm then
       TForm(DockControl).OnEndDock := nil;
     DockControl.ManualDock(f_PageControl);
     SetUndockSize;
    end;//DockControl <> nil
  end;//DoDockControl

var
  Index, l_ImageIndex: Integer;
  l_DockControl: TControl;
begin
  if (Value <> nil) then
  begin
    Value.f_PageControl.OnUnDock := nil;
    try
     { Установим TElCustomPageControl.Images }
     if f_PageControl.Images <> nil then
       Value.Images := f_PageControl.Images;
     { Переместим в "TElCustomPageControl приемник" DockControl который пользователь тащит.
       Это не делается в цикле потому что в этот момент закладки на которой он
       был расположен уже нет }
     DoDockControl;
     { Идем по закладкам из одного PageControl в другой }
     Index := Pred(Value.f_PageControl.PageCount);
     while (Index >= 0) do
     begin
      if (Value.f_PageControl.Pages[0].ControlCount > 0) then
       l_DockControl := Value.f_PageControl.Pages[0].Controls[0]
      else
       l_DockControl := nil;
      if (l_DockControl = nil) then
       Value.f_PageControl.RemovePage(Value.f_PageControl.Pages[0])
      else
      begin
       { Запомним ImageIndex }
       l_ImageIndex := Value.f_PageControl.Pages[0].ImageIndex;
       if l_DockControl is TForm then
         TForm(l_DockControl).OnEndDock := nil;
       l_DockControl.ManualDock(f_PageControl);
       { Установим ImageIndex }
       if l_DockControl.Parent is TElTabSheet then
        TElTabSheet(l_DockControl.Parent).ImageIndex := l_ImageIndex;
      end;//l_DockControl <> nil
      Dec(Index);
     end;//Index >= 0
     Value.SetUndockSize;
     { Установим активную закладку }
     if Value.f_ActiveControl <> nil then
      if Value.f_ActiveControl = DockControl then
       f_PageControl.ActivePage := TElTabSheet(DockControl.Parent)
      else
       for Index := 0 to Pred(f_PageControl.PageCount) do
        if f_PageControl.Pages[Index].Controls[0] = Value.f_ActiveControl then
        begin
         f_PageControl.ActivePage := f_PageControl.Pages[Index];
         Exit;
        end;
    finally
      Value.f_PageControl.OnUnDock := Value.OnPageControlUnDock;
      with Value do begin
        ModeStateUpdateAfter;
        Value.f_Header.Visible := False;
      end;
      f_Header.Visible := True;
      Value := nil;
    end;
  end//Value <> nil
  else
    DoDockControl;
end;

(*
procedure TvtNavigator.CheckSize(var aSize: Integer);
begin
 case Self.Align of
  alLeft, alRight:
   if aSize > Parent.Width then
    aSize := Parent.Width div 2;
  alBottom, alTop:
   if aSize > Parent.Height then
    aSize := Parent.Height div 2;
 end;//case Self.Align of
end;//CheckSize
*)

function TvtNavigator.GetNavigatorSizeNormal(aControl : TControl) : Integer;
var
 l_Parent     : TWinControl;
 l_Navigator  : TvtNavigator;
 l_SizeNormal : Integer;
begin
 if (f_PageControl.PageCount <> 0) then
  Result := f_SizeNormal
 else
 begin
  l_SizeNormal := DoLoadSize;
  if l_SizeNormal > 0 then
   Result := l_SizeNormal
  else
   Result := aControl.Width;
  l_Parent := aControl.Parent;
  while True do
  begin
   if not Assigned(l_Parent) then
    Break;
   if l_Parent is TElCustomPageControl then
   begin
    l_Navigator := TvtNavigator(l_Parent.Owner);
    Result := l_Navigator.SizeNormal;
    Break;
   end;
   l_Parent := l_Parent.Parent;
  end;
 end;
end;

procedure TvtNavigator.InitDockDrop;
begin
 if not f_IsInitDockDrop then
 begin
  f_Header.Visible := True;
  if not f_Float then
   ModeStateUpdate;
  f_IsInitDockDrop := True;
 end;
end;

function TvtNavigator.pm_GetCloseImage : TImageIndex;
begin
 Result := f_Header.CloseImage;
end;

procedure TvtNavigator.pm_SetCloseImage(const Value : TImageIndex);
begin
 f_Header.CloseImage := Value;
end;

function TvtNavigator.pm_GetAutoHideOnImage : TImageIndex;
begin
 Result := f_Header.AutoHideOnImage;
end;

procedure TvtNavigator.pm_SetAutoHideOnImage(const Value : TImageIndex);
begin
 f_Header.AutoHideOnImage := Value;
end;

function TvtNavigator.pm_GetAutoHideOffImage : TImageIndex;
begin
 Result := f_Header.AutoHideOffImage;
end;

procedure TvtNavigator.pm_SetAutoHideOffImage(const Value : TImageIndex);
begin
 f_Header.AutoHideOffImage := Value;
end;

function TvtNavigator.pm_GetHideLeftImage : TImageIndex;
begin
 Result := f_Header.HideLeftImage;
end;

procedure TvtNavigator.pm_SetHideLeftImage(const Value : TImageIndex);
begin
 f_Header.HideLeftImage := Value;
end;

function TvtNavigator.pm_GetHideRightImage : TImageIndex;
begin
 Result := f_Header.HideRightImage;
end;

procedure TvtNavigator.pm_SetHideRightImage(const Value : TImageIndex);
begin
 f_Header.HideRightImage := Value;
end;

function TvtNavigator.pm_GetHideUpImage : TImageIndex;
begin
 Result := f_Header.HideUpImage;
end;

procedure TvtNavigator.pm_SetHideUpImage(const Value : TImageIndex);
begin
 f_Header.HideUpImage := Value;
end;

function TvtNavigator.pm_GetHideDownImage : TImageIndex;
begin
 Result := f_Header.HideDownImage;
end;

procedure TvtNavigator.pm_SetHideDownImage(const Value : TImageIndex);
begin
 f_Header.HideDownImage := Value;
end;

procedure TvtNavigator.pm_SetActivate(const Value : Boolean);
begin
 if f_Activate <> Value then
 begin
  // Не показываем навигатор, если окно минизированно
  if Value and npIsWindowMinimazed(f_MainForm) then
   Exit;
  f_Activate := Value;
  if f_Float then
  begin
   case Value of
    True:
     SetWindowPos(f_FloatNavigator.Handle, HWND_TOPMOST, 0, 0, 0, 0,
      SWP_NOACTIVATE or SWP_NOMOVE or SWP_NOSIZE or SWP_SHOWWINDOW);
    False:
     SetWindowPos(f_FloatNavigator.Handle, 0, 0, 0, 0, 0,
      SWP_NOACTIVATE or SWP_NOMOVE or SWP_NOSIZE or SWP_HIDEWINDOW);
   end;
   f_FloatNavigator.Visible := Value;
   // - иначе огребаем рассинхронизацию
//   {$IfDef vtNavUseDebugLog}
//   l3System.Msg2Log(Format('NAV NavigatorActivate = %d', [Integer(Value)]));
//   {$EndIf vtNavUseDebugLog}
  end
  else
  if not f_Activate then
   f_Surface.f_Splitter.splHideHint;
 end;
end;

procedure TvtNavigator.hCBT(const Code   : Integer;
                            const WParam : WPARAM;
                            const LParam : LPARAM);
{* - сообщение получаемое от WH_CBT. }
begin
 case Code of
  HCBT_MINMAX:
   if (THandle(WParam) = f_MainForm.Handle) then
    // Чтобы у двух окон при минимизации не оставались плавающие навигаторы
    if ((LoWord(LParam) and SW_MINIMIZE) = SW_MINIMIZE) then
    begin
     Activate := False;
     f_FormWasMinimized := True;
    end
    else
     if ((LoWord(LParam) and SW_RESTORE) = SW_RESTORE) then
      f_ParentRestore := True;
 end;//case Code of
end;

procedure TvtNavigator.hGetMessage(const aMessage : PMsg);
{* - сообщение получаемое навигатором от WH_GETMESSAGE. }

 procedure lpDoActivate(aActivate : Boolean);
 begin
  (* Иначе при активизации приложения по заголовку окна окно навигатора могло
     находится под главным, кроме того наблюдались мерцания (показывали,
     скрывали, показывали) *)
  PostMessage(Handle, CM_npChangeActivate, Integer(aActivate), 0);
 end;

 function lpIsDropDown(aWnd : THandle) : Boolean;
 var
  lControl    : TWinControl;
  lDropWindow : IafwDropDownWindow;
 begin
  Result := False;
  lControl := FindControl(aWnd);
  if Assigned(lControl) then
   if Supports(lControl, IafwDropDownWindow, lDropWindow) then
   try
    Result := True;
   finally
    lDropWindow := nil;
   end
   else
    Result := not Assigned(lControl.Parent) and not Assigned(lControl.Owner);
 end;

 procedure lp_CorrectSize;
 begin
  // При восстановлении формы, откорректируем размер навигаторов
  with CorrectBounds(CalcBounds(SizeNormal)) do
   case Self.Align of
    alLeft, alRight:
     if Right - Left <> f_SizeNormal then
      SizeNormal := Right - Left;
    alBottom, alTop:
     if Bottom - Top <> f_SizeNormal then
      SizeNormal := Bottom - Top;
   end;//case Self.Align of
 end;//lp_CorrectSize

 function CheckWindowUnderCursor: Boolean;
 var
  l_CurPos: TPoint;
  l_Window: THandle;
  l_Class: string;
  l_ClassLen: Integer;
 begin // http://mdp.garant.ru/pages/viewpage.action?pageId=296095220
  if GetCursorPos(l_CurPos) then
  begin
   l_Window := WindowFromPoint(l_CurPos);
   SetLength(l_Class, 128);
   l_ClassLen := GetClassName(l_Window, PChar(l_Class), 128);
   if l_ClassLen > 0 then
    Result := l_Class[1] <> '#' // пункт выпадающего меню
   else    // не нравится мне это
    Result := False;
  end //GetCursorPos
  else
   Result := False;
 end; //CheckWindowUnderCursor

var
 lIsAct   : Boolean;
 lActWnd  : THandle;
begin
 if csDestroying in ComponentState then
  Exit;
 case aMessage.message of
  WM_MOUSEMOVE:
   if CheckWindowUnderCursor then
    AutoHideUpdate;
  WM_SIZE:
  begin
   (* Изменился размер родительского окна, изменим размер плавающего навигатора *)
   if Assigned(Parent) and Parent.HandleAllocated and
    (aMessage.hwnd = Parent.Handle) then
   begin
    if (f_State = nsAutoHide) then
     Resize;
    // Если форму минимизировали, то ничего не делаем
    if not f_Float and not f_FormWasMinimized then
    begin
     if f_ParentRestore then
      f_ParentRestore := False;
     lp_CorrectSize;
    end;
    // Форму разворачивают после минимизации
    if f_FormWasMinimized and f_ParentRestore then
    begin
     f_FormWasMinimized := False;
     f_ParentRestore := False;
    end;//if f_FormWasMinimized and f_ParentRestore then
   end;//if Assigned(Parent)
  end;//WM_SIZE
  WM_ACTIVATE:
  begin
   (* Минимизировать главное окно *)
   if (f_MainForm.Handle = THandle(aMessage.hwnd)) and
     Boolean(HiWord(aMessage.wParam)) then
    Activate := False
   (* Какое-то окно получило фокус, если окно, которое принадлежит главной
      форме, то активируем, в противном случае деактивируем *)
   else
   begin
    lIsAct := LoWord(aMessage.WParam) <> WA_INACTIVE;
    if lIsAct then
    begin
     lActWnd := aMessage.hwnd;
     if lpIsDropDown(lActWnd) then
      Exit;
     (* Показали модальную форму, прячем навигатор и выходим *)
     if npIsModalForm(lActWnd) then
     begin
      lpDoActivate(False);
      Exit;
     end;
     (* Активировали плавающую форму *)
     if not npIsInFloatNavigator(lActWnd) and npIsFloatingForm(lActWnd) then
     begin
      lpDoActivate(True);
      Exit;
     end;
    end
    else
    begin
    (* Окну aMessage.hwnd пришло сообщение о деактивации, handle активированного
       окна содержится в THandle(aMessage.lParam). Если окно принадлежит
       главному окну навигатора ничего не делаем или активируем, в противном
       случае спрячем *)
     lActWnd := THandle(aMessage.lParam);
     (* Информацию о деактивации нет смысла обрабатывать если фокус не ушел на
        рабочий стол, потому что когда придет, через HOOK сообщение об активации
        окна, то мы спрячем навигаторы если активировалось окно другой главной
        формы, или совсем чужое окно *)
     if  lActWnd <> HWND_DESKTOP then
      Exit;
    end;
    (* Изменим состояние *)
    lpDoActivate(npIsOwnerWindow(f_MainForm, lActWnd));
   end;
  end;
 end;
end;

procedure TvtNavigator.RecalcSize;
var
 lWinPosInfo : Cardinal;
begin
 lWinPosInfo := BeginDeferWindowPos(1);
 try
  with f_Surface do
   DeferWindowPos(lWinPosInfo, Handle, 0, 0, 0, Width, Height, SWP_FRAMECHANGED);
 finally
  EndDeferWindowPos(lWinPosInfo);
 end;//try..finally
end;

procedure TvtNavigator.UpdateState;
begin
 with f_PageControl do
 begin
  f_Header.Visible := PageCount > 0;
  Visible := PageCount > 0;
 end;
 case f_State of
  (* AutoHide *)
  nsAutoHide:
   DoAutoHide;
  (* Minimazed *)
  nsMinimazed:
  begin
   AttachSurface;
   Minimazed;
  end;//Minimazed
  nsNormal:
  begin
   AttachSurface;
   SetSizeNormal(f_SizeNormal);
  end;//nsNormal
 end;//case f_State
 (* Пересчитаем размер клиентской области *)
 if f_State <> nsAutoHide then
  RecalcSize;
end;

procedure TvtNavigator.DockDrop(Source: TDragDockObject; X, Y: Integer);
var
 lImageIndex : Integer;
 lIsEmpty    : Boolean;
begin
 lImageIndex := -1;
 lIsEmpty := f_PageControl.PageCount = 0;
 f_IsInitDockDrop := False;
 if ((f_ImportNavigator <> nil) and (f_ImportNavigator <> Self)) or
  (f_ImportNavigator = nil) and CheckControl(Source.Control) then
 begin
  if Source.Control.Parent is TElTabSheet then
   lImageIndex := TElTabSheet(Source.Control.Parent).ImageIndex;
  if (f_PageControl.PageCount = 0) then
   f_SizeNormal := GetNavigatorSizeNormal(Source.Control);
  //f_PageControl.DockDrop(Source, X, Y);
  inherited DockDrop(Source, X, Y);
  MovePagesToNavigator(f_ImportNavigator, Source.Control);
  if Source.Control.Parent is TElTabSheet then
   TElTabSheet(Source.Control.Parent).ImageIndex := lImageIndex;
  if Source.Control.Visible then
   InitDockDrop;
 end;//((f_ImportNavigator <> nil) and (f_ImportNavigator <> Self))
 (* сбрасываем значения f_SizeNormal, которые были установлены навигатору до
    появления закладок в SetBounds, чтобы при нормализации он не был
    равен свернутому состоянию *)
 if (f_PageControl.PageCount = 1) and (f_State = nsMinimazed) then
  f_SizeNormal := cDefaultNormalSize;
 UpdateState;
 {$IfDef Nemesis}
 if f_Float then
  f_FloatNavigator.UpdateFloatWindowsBounds;
 {$EndIf Nemesis}
 (* Обработчик отстыковки *)
 if lIsEmpty and not Assigned(f_PageControl.OnUnDock) then
  f_PageControl.OnUnDock := OnPageControlUnDock;
 (* не заслоняем компоненты, которые лежат в этом же месте *)
 if lIsEmpty and (f_PageControl.PageCount > 0) then
  PostMessage(Handle, CM_npDoActionWithFormControls, Ord(acUpInZOrder), 0);
end;

procedure TvtNavigator.ResetDragInfo;
begin
 f_Header.IsDragBegining := False;
 f_ClickOnTab := False;
end;

procedure TvtNavigator.OnPageControlUnDock(Sender: TObject; Client: TControl;
  NewTarget: TWinControl; var Allow: Boolean);

  procedure SetEndDockProcedure;
  begin//SetEndDockProcedure
   if (Client is TForm) then
   begin
    TForm(Client).OnEndDock := OnEndDockControl;
    f_EndDockClient := Client;
   end;//Client is TForm
  end;//SetEndDockProcedure

begin
 SetUndockSize;
 if (NewTarget <> Self) then
 begin
  { Импортируем в PageControl }
  if Allow and (NewTarget <> nil) and f_Header.IsDragBegining and
   (NewTarget is TnpPageControl) then
  begin
   f_ExportPageControl := NewTarget as TnpPageControl;
   SetEndDockProcedure;
   ResetDragInfo;
   Allow := False;
  end;//Allow and (NewTarget <> nil) and f_Header.IsDragBegining
  if Allow then
  begin
   if f_Float then
    Allow := (NewTarget <> nil) or ((f_PageControl.PageCount > 1) and
     f_UnDockFromFloat and
     not f_SingleFloatNavigator and not f_Header.IsDragBegining);
   if Allow then
   begin
    if not f_Float then
     ModeStateUpdateAfter;
    f_DockInSelf := False;
    if (f_PageControl.PageCount = 1) then
    begin
     if f_Float then
     begin
      if NewTarget <> nil then
       f_FloatNavigator.Close
      else
       if not f_UnDockFromFloat then
        f_DockInSelf := True;
     end;//f_Float
    end//f_PageControl.PageCount = 1
    { NewTarget - используя f_ImportNavigator  примет все закладки текущего навигатора }
    else
    if (NewTarget <> nil) and (NewTarget is TvtNavigator) and
      f_Header.IsDragBegining then
     TvtNavigator(NewTarget).f_ImportNavigator := Self;
    { Клиент ни к кому не пристыкован }
    if NewTarget = nil then
     if Client is TForm then
     begin
      Allow := False;
      PostMessage(Handle, CM_npDockToFloatWindow, Integer(Client), 0);
     end;//if Client is TForm then
   end;//if Allow then
  end;
  if not Allow then
   if f_Float then
    if Client is TForm then
     SetEndDockProcedure;
 end//NewTarget <> Self
 else
  Allow := False;
 if Allow then
  ResetDragInfo;
end;

function TvtNavigator.pm_GetButtonsImageList : TCustomImageList;
begin
 Result := f_Header.ButtonsImageList;
end;

function TvtNavigator.IsAutoHideOffHint : Boolean;
  {-}
begin
 Result := f_AutoHideOffHint <> cAutoHideOffHint;
end;

function TvtNavigator.IsAutoHideOnHint : Boolean;
  {-}
begin
 Result := f_AutoHideOnHint <> cAutoHideOnHint;
end;

function TvtNavigator.IsMinimazedOffHint : Boolean;
  {-}
begin
 Result := f_MinimazedOffHint <> cMinimazedOffHint;
end;

function TvtNavigator.IsMinimazedOnHint : Boolean;
  {-}
begin
 Result := f_MinimazedOnHint <> cMinimazedOnHint;
end;

function TvtNavigator.IsCloseHint : Boolean;
{-}
begin
 Result := f_CloseHint <> cCloseHint;
end;

procedure TvtNavigator.pm_SetButtonsImageList(const Value : TCustomImageList);
begin
 f_Header.ButtonsImageList := Value;
end;

function TvtNavigator.GetActivePageIndex: Integer;
begin
 Result := f_PageControl.ActivePageIndex;
end;

procedure TvtNavigator.SetActivePageIndex(const Value: Integer);
begin
 f_PageControl.ActivePageIndex := Value;
end;

function TvtNavigator.GetPageCount: Integer;
begin
 Result := f_PageControl.PageCount;
end;

function TvtNavigator.GetPage(Index: Integer): TElTabSheet;
begin
 Result := f_PageControl.Pages[Index];
end;

procedure TvtNavigator.ModeNormalUpdate;
begin
 if (f_PageControl.PageCount > 0) then
 begin
  if f_State = nsNormal then
  begin
   SetSelfSize(f_SizeNormal);
   f_PageControl.Visible := True;
   f_Header.Visible      := True;
  end;
 end//f_PageControl.PageCount > 0
 else
 begin
  f_PageControl.Visible := False;
  f_Header.Visible := False;
  case Self.Align of
   alTop, alBottom:
    Self.Height := f_SizeEmpty;
   alLeft, alRight:
    Self.Width := f_SizeEmpty;
  end;//case Self.Align
 end;//f_PageControl.PageCount > 0
end;

procedure TvtNavigator.SetSizeMini;
begin
 SetSize(SizeMini);
end;

procedure TvtNavigator.ModeAutoUpdate;
begin
 if (f_State = nsAutoHide) then
 begin
  if (f_PageControl.DockClientCount = 0) then
  begin
   SetSizeMini;
   f_PageControl.Visible := False;
   f_Header.Visible := False;
  end//f_PageControl.DockClientCount = 0
  else
  if f_HideDirect = hdShow then
   ModeShow
  else
   ModeHide;
 end;//f_State = nsAutoHide
end;

procedure TvtNavigator.AutoUpdateSize;
var
 lDelta  : Integer;
 lBounds : TRect;
begin
 // Размер
 if f_HideDirect = hdHide then
  lDelta := SizeMini
 else
  lDelta := SizeNormal;
 if Swim then
 begin
  // Текущий размер
  lBounds := f_Surface.BoundsRect;
  // Новый размер
  with lBounds do
   case Self.Align of
    alLeft:
     Right := Left + lDelta;
    alRight:
     Left := Right - lDelta;
    alTop:
     Bottom := Top + lDelta;
    alBottom:
     Top := Bottom - lDelta;
   end;//case Self.Align
  // Применим
  f_Surface.BoundsRect := lBounds;
 end//Swim
 else
  SetSelfSize(lDelta);
end;

procedure TvtNavigator.NormalUpdateSize;
begin
 case f_State of
  nsMinimazed:
   SetSelfSize(SizeMini);
  nsNormal:
   SetSelfSize(SizeNormal);
 end;//case f_State
end;

function TvtNavigator.CorrectSize(const aSizeNormal: Integer): Integer;
  {* - откорректировать размер. }
begin
 Result := aSizeNormal;
 with CorrectBounds(CalcBounds(aSizeNormal)) do
  case Self.Align of
   alLeft, alRight:
    Result := Right - Left;
   alTop, alBottom:
    Result := Bottom - Top;
  end;//case Self.Align
end;

function TvtNavigator.RelativeAlign: TAlign;
  {* - выравнивание навигатора - соседа. }
begin
 Result := alNone;
 case Self.Align of
  alLeft:
   Result := alRight;
  alRight:
   Result := alLeft;
  alTop:
   Result := alBottom;
  alBottom:
   Result := alTop;
 end;//case Self.Align of
end;//RelativeAlign

function TvtNavigator.pm_GetRelativeNavigator: TvtNavigator;
  {* - навигатор сосед. }
begin
 if not Assigned(f_RelativeNavigator) then
  f_RelativeNavigator := FindRelative(RelativeAlign);
 Result := f_RelativeNavigator;
end;

function TvtNavigator.pm_GetClientControl: TWinControl;
  {* - клиентский компонент с которым граничит навигатор. }
var
 l_Index: Integer;
begin
 Result := nil;
 if Assigned(Parent) then
  for l_Index := 0 to Pred(Parent.ControlCount) do
   if Parent.Controls[l_Index] is TWinControl then
    with TWinControl(Parent.Controls[l_Index]) do
     if (Align = alClient) then
     begin
      Result := TWinControl(Parent.Controls[l_Index]);
      Break;
     end;//if (Align = alClient) then
end;

function TvtNavigator.FindRelative(const aAlign: TAlign): TvtNavigator;
  {* - найти навигатор на той же форме с указанным выравниванием. Делаем
       допущение, что на форме может быть только один навигатор с указанным
       типом выравнивания. }
var
 l_Index: Integer;
begin
 Result := nil;
 if Assigned(Parent) then
  with Parent do
   for l_Index := 0 to Pred(ControlCount) do
    if (Controls[l_Index] is TvtNavigator) and
     (Controls[l_Index].Align = aAlign) then
    begin
     Result := TvtNavigator(Controls[l_Index]); 
     Break;
    end;//if (Controls[l_Index] is TvtNavigator) and
end;//FindRelative

function TvtNavigator.CalcSize(const aBounds: TRect): Integer;
  {* - вычисляет размер. }
begin
 Result := 0;
 with aBounds do
  case Align of
   alLeft, alRight:
    Result := Right - Left;
   alTop, alBottom:
    Result := Bottom - Top;
  end;//case Align of
end;//CalcSize

function TvtNavigator.CalcBounds(const aSizeNormal: Integer): TRect;
  {* - вычислить новые размеры. }
begin
 Result := BoundsRect;
 case Align of
  alLeft:
   Result.Right := Result.Left + aSizeNormal;
  alRight:
   Result.Left := Result.Right - aSizeNormal;
  alTop:
   Result.Bottom := Result.Top + aSizeNormal;
  alBottom:
   Result.Top := Result.Bottom - aSizeNormal;
 end;//case Align of
end;//CalcBounds

function TvtNavigator.CorrectBounds(const aBounds: TRect): TRect;
  {* - корректирует новые размеры навигатора. Необходимо при перетаскивании
       навигатора и при сплиттинге. }

 procedure lp_MinSize;
 {* - сожмем навигатор, занятой области он не оставил даже минимального
      пространства (cMinNormalSize + cMinClientControlSize).}
 var
  l_Rect   : TRect;
  l_Client : TRect;
  l_Size   : Integer;
 begin
  if Assigned(RelativeNavigator) then
  begin
   l_Size := cMinNormalSize + cMinClientControlSize;
   l_Rect := BoundsRect;
   l_Client := Parent.ClientRect;
   case Align of
    alLeft:
    begin
     if (l_Rect.Right > l_Client.Right - l_Size) and
      (Width > cMinNormalSize) then
     begin
      Width := l_Client.Right - l_Size - l_Rect.Left;
      Result.Right := l_Client.Right - l_Size;
     end;//if (l_Rect.Right > l_Client.Right - l_Size) and
    end;//alLeft
    alRight:
    begin
     if (l_Rect.Left < l_Client.Left + l_Size) and
      (Width > cMinNormalSize) then
     begin
      Width := l_Rect.Right - (l_Client.Left + l_Size);
      Result.Left := l_Client.Left + l_Size;
     end;//if (l_Rect.Left < l_Client.Left + l_Size) and
    end;//alRight
   end;//case Align of
  end;//if Assigned(RelativeNavigator) then
 end;//lp_CorrectAfterRestore

 procedure lp_ConflictWithBusyRect;
 {* - установим размер навигатора в зависимости от уже занятой области. }

  function BusyRectOnParent: TRect;
    {* - область занятая клиентским компонентом и навигатором. }
  var
   l_Control  : TWinControl;
   l_TempSize : Integer;
   l_Size     : Integer;
   l_Rect     : TRect;
  begin
   SetRectEmpty(Result);
   l_Control := ClientControl;
   if Assigned(l_Control) then
   begin
    Result := l_Control.BoundsRect;
    if Assigned(RelativeNavigator) then
    begin
     l_Size := cMinClientControlSize;
     l_Rect := RelativeNavigator.BoundsRect;
     l_TempSize := CalcSize(l_Rect);
     if l_TempSize < cMinNormalSize then
      l_TempSize := cMinNormalSize;
     Inc(l_Size, l_TempSize);
     case RelativeNavigator.Align of
      alLeft:
      begin
       Result.Left := l_Rect.Left;
       Result.Right := l_Rect.Left + l_Size;
      end;
      alRight:
      begin
       Result.Right := l_Rect.Right;
       Result.Left := l_Rect.Right - l_Size
      end;
      alTop:
      begin
       Result.Top := l_Rect.Top;
       Result.Bottom := l_Rect.Top - l_Size;
      end;
      alBottom:
      begin
       Result.Bottom := l_Rect.Bottom;
       Result.Top := l_Rect.Bottom - l_Size;
      end;
     end;//case RelativeNavigator of
    end//if Assigned(RelativeNavigator) then
    else
     Case Self.Align of
      alLeft:
       Result.Left := Result.Right;
      else
       Assert(false);
     end;//Case Self.Align
   end;//if Assigned(l_Control) then
  end;//BusyRectOnParent

 var
  l_Rect: TRect;
 begin
  l_Rect := BusyRectOnParent;
  case Self.Align of
   alLeft:
    if Result.Right > l_Rect.Left then
     if Result.Left + cMinNormalSize > l_Rect.Left then
      Result.Right := Result.Left + cMinNormalSize
     else
      Result.Right := l_Rect.Left;
   alRight:
    if Result.Left < l_Rect.Right then
     if Result.Right - cMinNormalSize < l_Rect.Right then
      Result.Left := Result.Right - cMinNormalSize
     else
     Result.Left := l_Rect.Right;
   alTop:
    if Result.Bottom > l_Rect.Top then
     if Result.Top + cMinNormalSize > l_Rect.Top then
      Result.Bottom := Result.Top + cMinNormalSize
     else
      Result.Bottom := l_Rect.Top;
   alBottom:
    if Result.Top > l_Rect.Bottom then
     if Result.Bottom - cMinNormalSize > l_Rect.Bottom then
      Result.Top := Result.Bottom - cMinNormalSize
     else
     Result.Top := l_Rect.Bottom;
  end;//case Self.Align of
 end;//lp_ConflictWithBusyRect

 procedure lp_CorrectBounds;
 {* - если навигатор выходит за пределы то откорректируем. }
 var
  l_Rect   : TRect;
  l_Client : TRect;
 begin//lp_CorrectBounds
  l_Rect := BoundsRect;
  l_Client := Parent.ClientRect;
  case Align of
   alLeft:
    if l_Rect.Left < l_Client.Left then
    begin
     Windows.OffsetRect(l_Rect, l_Client.Left - l_Rect.Left, 0);
     BoundsRect := l_Rect;
    end;//if l_Rect.Left < l_Client.Left then
   alRight:
    if l_Rect.Right > l_Client.Right then
    begin
     Windows.OffsetRect(l_Rect, l_Client.Right - l_Rect.Right, 0);
     BoundsRect := l_Rect;
    end;//if l_Rect.Right > l_Client.Right then
   alTop:
    if l_Rect.Top < l_Client.Top then
    begin
     Windows.OffsetRect(l_Rect, 0, l_Client.Top - l_Rect.Top);
     BoundsRect := l_Rect;
    end;//if l_Rect.Top < l_Client.Top then
   alBottom:
    if l_Rect.Bottom > l_Client.Bottom then
    begin
     Windows.OffsetRect(l_Rect, 0, l_Client.Bottom - l_Rect.Bottom);
     BoundsRect := l_Rect;
    end;//if l_Rect.Top < l_Client.Top then
  end;//case RelativeNavigator.Align of
 end;//lp_CorrectBounds

var
 l_CurrentSize : Integer;
 l_NewSize     : Integer;
begin
 Result := aBounds;
 if Assigned(ClientControl) then
 begin
  l_CurrentSize := CalcSize(BoundsRect);
  l_NewSize := CalcSize(aBounds);
  if l_NewSize >= l_CurrentSize then
  begin
   lp_CorrectBounds;
   // Если при изменении размеров формы мы достигли минимального размера
   // навигатора, более уже ничего сделать нельзя
   if not ((l_NewSize = l_CurrentSize) and (f_SizeNormal = cMinNormalSize)) then
   begin
    lp_MinSize;
    lp_ConflictWithBusyRect;
   end;//if not ((l_NewSize = l_CurrentSize)
  end;//if l_NewSize >= l_CurrentSize then
 end;//if Assigned(l_Control) then
end;//CorrectBounds

procedure TvtNavigator.UpdateSize;
begin
 if f_State = nsAutoHide then
  AutoUpdateSize
 else
  NormalUpdateSize;
end;

procedure TvtNavigator.ModeHide;
begin
 UpdateSize;
end;

procedure TvtNavigator.ModeShow;
begin
 UpdateSize;
end;

procedure TvtNavigator.SetSize(const aValue : Integer;
                                  aControl     : TControl = nil);
begin
 if not Assigned(aControl) then
  aControl := Self; 
 case Self.Align of
 alLeft, alRight:
  aControl.Width := aValue;
 alTop, alBottom:
  aControl.Height := aValue;
 end;//case Self.Align
end;

procedure TvtNavigator.SetSizeEmpty(Value : Integer);
begin
 f_SizeEmpty := Value;
 AttachSurface;
 SetSize(Value);
end;

procedure TvtNavigator.SetSizeNormal(Value: Integer);

 procedure lp_SetSize(aControl : TControl);
 begin
  case Self.Align of
   alTop, alBottom:
    aControl.Height := f_SizeNormal;
   alLeft, alRight:
    aControl.Width := f_SizeNormal;
  end;//case Self.Align of
 end;//lp_SetSize

begin
 f_SizeNormal := Value;
 (* Не закладок не нужно и размер устанавливать *)
 if not Assigned(f_PageControl) or (f_PageControl.PageCount = 0) then
  Exit;
 f_SizeNormal := CorrectSize(f_SizeNormal);
 //CheckSize(f_SizeNormal);
 (* AutoHide *)
 case f_State of
  nsAutoHide:
   lp_SetSize(f_Surface);
  nsNormal:
   lp_SetSize(Self);
 end;//case f_State of
 if (f_State = nsAutoHide) and (Align = alRight) then
  f_Surface.Left := Parent.ClientWidth - f_Surface.Width;
end;//SetSizeNormal

{ TnpHeader }

constructor TnpHeader.Create(aOwner : TComponent);

  procedure SetBtn(var aBtn : TnpButton;
                   aBtnType : TnpButtonType;
                   const aGlyphID : String);
  begin//SetBtn
   aBtn := TnpButton.Create(Self, TvtNavigator(aOwner), aBtnType);
   with aBtn do
   begin
    Name := aGlyphID;
    Parent := Self;
    Height := cButtonSize;
    Width  := cButtonSize;
    Left   := cIntervalButtonLine;
    Top    := cIntervalButtonLine;
    Flat   := True;
    Glyph.LoadFromResourceName(HInstance, aGlyphID);
   end;//with aBtn do
   if csDesigning in Self.ComponentState  then
     aBtn.Visible := False;
  end;//SetBtn

begin
 inherited Create(AOwner);
 ControlStyle := ControlStyle + [csNoDesignVisible];
 Cursor := crSizeAll;
 f_Canvas := Tl3CustomControlCanvas.Create(Self);
 f_AutoHideOnImage  := 0;
 f_AutoHideOffImage := 1;
 f_HideLeftImage    := 2;
 f_HideRightImage   := 3;
 f_CloseImage       := 6;
 f_HideUpImage      := 4;
 f_HideDownImage    := 5;
 Size := cHeaderSize;
 f_Link := TnpChangeLink.Create;
 f_Link.OnStateChanged := OnStateChanged;
 SetBtn(f_AutoHideButton, nbtAutoHide, cBmpAutoHideOff);
 with AutoHideButton do
 begin
  AllowAllUp := True;
  GroupIndex := 1;
  Down       := True;
 end;
 SetBtn(f_HideButton, nbtMinimazed, cBmpHideLeft);
 SetBtn(f_CloseButton, nbtClose,    cBmpClose);
 UpdatePositions;
end;

procedure TnpHeader.Cleanup;
begin
 if (f_Navigator <> nil) then
  f_Navigator.UnRegisterStateChanged(f_Link);
 f_Navigator := nil;

 FreeAndNil(f_Canvas);
 FreeAndNil(f_CloseButton);
 FreeAndNil(f_AutoHideButton);
 FreeAndNil(f_HideButton);
 FreeAndNil(f_Link);
 inherited;
end;

procedure TnpHeader.UpdateAutoHideImage;
begin
 if not f_Navigator.f_Float then
 begin
  case f_Navigator.State of
   nsAutoHide:
    {$IfDef NavigatorPanelNeedsTB97}
    AutoHideButton.ImageIndex := f_AutoHideOffImage;
    {$Else}
    AutoHideButton.Glyph.LoadFromResourceName(HInstance, cBmpAutoHideOn);
    {$EndIf NavigatorPanelNeedsTB97}
   else
    {$IfDef NavigatorPanelNeedsTB97}
    AutoHideButton.ImageIndex := f_AutoHideOnImage;
    {$Else}
    AutoHideButton.Glyph.LoadFromResourceName(HInstance, cBmpAutoHideOff);
    {$EndIf NavigatorPanelNeedsTB97}
  end;//case f_Navigator.Stat
 end//not f_Navigator.f_Float
 else
 begin
  if f_Navigator.f_FloatNavigator.State = fwsMinimized then
   {$IfDef NavigatorPanelNeedsTB97}
   AutoHideButton.ImageIndex := f_HideDownImage
   {$Else}
   AutoHideButton.Glyph.LoadFromResourceName(HInstance, cBmpHideBottom)
   {$EndIf NavigatorPanelNeedsTB97}
  else
   {$IfDef NavigatorPanelNeedsTB97}
   AutoHideButton.ImageIndex := f_HideUpImage;
   {$Else}
   AutoHideButton.Glyph.LoadFromResourceName(HInstance, cBmpHideTop);
   {$EndIf NavigatorPanelNeedsTB97}
 end;//not f_Navigator.f_Float
end;

procedure TnpHeader.UpdateCloseImage;
  {-}
begin
 {$IfDef NavigatorPanelNeedsTB97}
 CloseButton.ImageIndex := f_CloseImage;
 {$Else}
 CloseButton.Glyph.LoadFromResourceName(HInstance, cBmpClose);
 {$EndIf NavigatorPanelNeedsTB97}
end;//UpdateCloseImage

procedure TnpHeader.UpdateHideImage;
begin
 if not f_Navigator.f_Float then
 begin
  if f_Navigator.State <> nsMinimazed then
   case f_Navigator.Align of
    alRight:
    begin
     {$IfDef NavigatorPanelNeedsTb97}
     HideButton.ImageIndex := f_HideRightImage;
     {$Else}
     HideButton.Glyph.LoadFromResourceName(HInstance, cBmpHideRight);
     {$EndIf NavigatorPanelNeedsTb97}
    end;//alRight
    alLeft:
    begin
     {$IfDef NavigatorPanelNeedsTb97}
     HideButton.ImageIndex := f_HideLeftImage;
     {$Else}
     HideButton.Glyph.LoadFromResourceName(HInstance, cBmpHideLeft);
     {$EndIf NavigatorPanelNeedsTb97}
    end;//alLeft
   end//f_Navigator.Align
  else
   case f_Navigator.Align of
    alRight:
    begin
     {$IfDef NavigatorPanelNeedsTb97}
     HideButton.ImageIndex := f_HideLeftImage;
     {$Else}
     HideButton.Glyph.LoadFromResourceName(HInstance, cBmpHideLeft);
     {$EndIf NavigatorPanelNeedsTb97}
    end;//alRight
    alLeft:
    begin
     {$IfDef NavigatorPanelNeedsTb97}
     HideButton.ImageIndex := f_HideRightImage;
     {$Else}
     HideButton.Glyph.LoadFromResourceName(HInstance, cBmpHideRight);
     {$EndIf NavigatorPanelNeedsTb97}
    end;//alLeft
   end;//case f_Navigator.Align
 end//not f_Navigator.f_Float
 else
  {$IfDef NavigatorPanelNeedsTb97}
  HideButton.ImageIndex := f_AutoHideOnImage;
  {$EndIf NavigatorPanelNeedsTb97}
end;

procedure TnpHeader.UpdatePositions;

  procedure lp_Left;
  begin//lp_Left
   AutoHideButton.Align := alLeft;
   HideButton.Align     := alRight;
   CloseButton.Align    := alRight;
   // Поставим кнопку закрыть перед кнопкой скрыть:
   if HideButton.Visible and CloseButton.Visible then
    CloseButton.Left := HideButton.Left - 1;
  end;//lp_Left

  procedure lp_Right;
  begin//lp_Right
   AutoHideButton.Align := alRight;
   HideButton.Align     := alLeft;
   CloseButton.Align    := alLeft;
   // Поставим кнопку закрыть перед кнопкой скрыть:
   if HideButton.Visible and CloseButton.Visible then
    CloseButton.Left := HideButton.BoundsRect.Right + 1;
  end;//lp_Right

  procedure lp_Top;
  begin//lp_Top
   AutoHideButton.Align := alTop;
   HideButton.Align     := alBottom;
   CloseButton.Align    := alBottom;
   // Поставим кнопку закрыть перед кнопкой скрыть:
   if HideButton.Visible and CloseButton.Visible then
    CloseButton.Top := HideButton.Top - 1;
  end;//lp_Top

  procedure lp_Bottom;
  begin//lp_Bottom
   AutoHideButton.Align := alBottom;
   HideButton.Align     := alTop;
   CloseButton.Align    := alTop;
   // Поставим кнопку закрыть перед кнопкой скрыть:
   if HideButton.Visible and CloseButton.Visible then
    CloseButton.Top := HideButton.BoundsRect.Bottom + 1;
  end;//lp_Bottom

begin
 AutoHideButton.Align := alNone;
 CloseButton.Align    := alNone;
 HideButton.Align     := alNone;
 if Navigator = nil then
  Exit;
 if Navigator.Float then
  lp_Left
 else
  case Navigator.Align of
   alLeft:
    lp_Left;
   alRight:
    lp_Right;
   alTop:
    lp_Top;
   alBottom:
    lp_Bottom;
  end;//case Align of
end;//UpdatePositions

procedure TnpHeader.pm_SetHideUpImage(const Value : TImageIndex);
begin
 if (f_HideUpImage <> Value) then
 begin
  f_HideUpImage := Value;
  UpdateHideImage;
 end;//f_HideUpImage <> Value
end;

procedure TnpHeader.pm_SetHideDownImage(const Value : TImageIndex);
begin
 if (f_HideDownImage <> Value) then
 begin
  f_HideDownImage := Value;
  UpdateHideImage;
 end;//f_HideDownImage <> Value
end;

procedure TnpHeader.pm_SetButtonsImageList(const Value : TCustomImageList);
begin
 if f_ButtonsImageList <> Value then
 begin
  {$IfDef NavigatorPanelNeedsTb97}
  AutoHideButton.Images := Value;
  HideButton.Images := Value;
  CloseButton.Images := Value;
  {$EndIf NavigatorPanelNeedsTb97}
  f_ButtonsImageList := Value;
 end;
end;

function TnpHeader.pm_GetSize: Integer;
begin
 Result := f_Size;
end;

function TnpHeader.GetRectLines : TRect;

 function lp_FreeRect: TRect;
 var
  l_Index: Integer;
 begin
  Result := BoundsRect;
  for l_Index := 0 to Pred(ControlCount) do
   if Controls[l_Index].Visible then
    case Align of
     alLeft, alRight:
      case Controls[l_Index].Align of
       alTop:
        Result.Top := Max(Result.Top, Controls[l_Index].BoundsRect.Bottom);
       alBottom:
        Result.Bottom := Min(Result.Bottom, Controls[l_Index].BoundsRect.Top);
       else
        Assert(False);
      end;//case Controls[l_Index] of
     alTop, alBottom:
      case Controls[l_Index].Align of
       alLeft:
        Result.Left := Max(Result.Left, Controls[l_Index].BoundsRect.Right);
       alRight:
        Result.Right := Min(Result.Right, Controls[l_Index].BoundsRect.Left);
       else
        Assert(False);
      end;//case Controls[l_Index] of
    end;//case Navigator.Align of
 end;//lp_FreeRect

begin
 Result := lp_FreeRect;
  // - свободная область для вывода линий;
 with Result do
  case Align of
   alLeft, alRight:
    Windows.InflateRect(Result, - ((Width - cLinesHeight) div 2), 0);
     // - расположим линии по середине навигатора;
   alTop, alBottom:
    Windows.InflateRect(Result, 0, - ((Height - cLinesHeight) div 2));
     // - расположим линии по середине навигатора;
  end;//case Navigator.Align of
end;//GetRectLines

procedure TnpHeader.AdjustClientRect(var Rect: TRect);
  // override;
  {-}
begin
 inherited;
 InflateRect(Rect, - cIntervalHeaderButton, - cIntervalHeaderButton);
end;//AdjustClientRect

procedure TnpHeader.Paint;

  procedure lp_DrawFrame(aRect : TRect);
  begin//lp_DrawFrame
   Frame3D(Canvas, aRect, clBtnHighlight, clBtnShadow, 1);
   //Frame3D(Canvas, aRect, clBtnShadow, clBtnShadow, 1);
  end;//lp_DrawFrame

  procedure lp_PaintLine(ABelow: Integer);
  var
   lRect: TRect;
  begin//lp_PaintLine
   lRect := GetRectLines;
   { горизонталь }
   if (Self.Width > Self.Height) then
   begin
    lRect.Top    := lRect.Top + ABelow;
    lRect.Bottom := lRect.Top + cBorderWidth;
   { вертикаль }
   end//Self.Width > Self.Height
   else
   begin
    lRect.Left := lRect.Left + ABelow;
    lRect.Right := lRect.Left + cBorderWidth;
   end;//Self.Width > Self.Height

   if Self.Width > Self.Height then
    Inc(lRect.Bottom)
   else
    Inc(lRect.Right);

   Frame3D(Self.Canvas, lRect, clBtnHighlight, clBtnShadow, 1);
  end;//lp_PaintLine

  procedure lp_DrawActivePage;
  var
   lRect    : TRect;
   lCaption : String;
  begin//lp_DrawActivePage
   if Assigned(f_Navigator.PageControl.ActivePage) then
   begin
    with Canvas do
    begin
     if f_Navigator.State = nsMinimazed then
      Exit;
     (* рамка *)
     lp_DrawFrame(ClientRect);
     (* выводимая область *)
     lRect := GetRectLines;
     lRect.Top := 0;
     lRect.Bottom := ClientHeight;
     (* иконка *)
     with f_Navigator.f_PageControl do
      if Assigned(Images) and (ActivePage.ImageIndex <> -1) and
       (ActivePage.ImageIndex < Images.Count) then
      begin
       with Images do
        Draw(Self.Canvas, lRect.Left, (Self.Height - Height) div 2,
         ActivePage.ImageIndex, True);
       lRect.Left := lRect.Left + Images.Width + 2;
      end;//Assigned(Images) and (ActivePage.ImageIndex <> -1)..
     (* текст *)
     InflateRect(lRect, -1, -1);
     lCaption := f_Navigator.PageControl.ActivePage.Caption;
     f_Canvas.Font.AssignFont(Font);
     f_Canvas.BeginPaint;
     try
      f_Canvas.DrawText(l3PCharLen(lCaption),
                       lRect,
                       DT_VCENTER      or
                       DT_END_ELLIPSIS or
                       DT_SINGLELINE);
     finally
      f_Canvas.EndPaint;
     end;//try..finally
    end;//with Canvas
   end;//Assigned(f_Navigator.PageControl.ActivePage)
  end;//lp_DrawActivePage

var
  lRect: TRect;
begin
 inherited;
 lRect := ClientRect;
 with Canvas do
 begin
  Brush.Color := cGarant2011ToolbarsColor{clBtnFace};
  FillRect(lRect);
  if f_Navigator.State = nsMinimazed then
   Exit;
  (* навигатор находится в режиме автоскрытия и сейчас должна быть видна только
     кнопка AutoHideButton *)
  HideButton.Visible := not ((f_Navigator.State = nsAutoHide) and
   (f_Navigator.f_Surface.Size <= f_Navigator.SizeMini));
  CloseButtonVisible(HideButton.Visible);
  (* выводим иконку и название закладки *)
  if f_Navigator.ShowActivePageInHeader then
  begin
   if HideButton.Visible then
    lp_DrawActivePage;
  end//f_Navigator.ShowActivePageInHeader
  (* рисуем полосы *)
  else
  begin
   (* видна только кнопка AutoHideButton *)
   if not HideButton.Visible then
    Exit;
   if (f_Navigator.State <> nsMinimazed) and
    (f_Navigator.f_HideDirect <> hdHide) then
   begin
    if f_Navigator.f_Float then
     InflateRect(lRect, -1, -1);
    lp_DrawFrame(lRect);
    { Первая линия }
    lp_PaintLine(0);
    { Подадим смещения для второй линии }
    lp_PaintLine(cOffsetSecondLine);
   end;//f_Navigator.State <> nsMinimazed..
  end;//f_Navigator.ShowActivePageInHeader
 end;//with Canvas
end;

procedure TnpHeader.MouseDown(Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
 l_Control : TControl;
begin
 if Button = mbLeft then
 begin
  if not Assigned(f_Navigator.f_PageControl.ActivePage) then
   Exit
  else
  if f_Navigator.f_PageControl.ActivePage.ControlCount = 0 then
   Exit;
  l_Control := f_Navigator.f_PageControl.ActivePage.Controls[0];
  f_Navigator.InitDrag(l_Control);
  IsDragBegining := True;
  f_Navigator.f_ActiveControl := l_Control;
  l_Control.BeginDrag(False);
 end;
 inherited MouseDown(Button, Shift, X, Y);
end;

procedure TvtNavigator.OnAutoHide(Sender: TObject);
begin
 if State = nsAutoHide then
  State := nsNormal
 else
  State := nsAutoHide;
end;

procedure TvtNavigator.Minimazed;
begin
 if not f_Float then
 begin
  f_HideDirect := hdNone;
  case f_State = nsMinimazed of
   False:
    ModeNormalUpdate;
   True:
    ModeHide;
  end;//case f_State
 end;//not f_Float
end;

procedure TvtNavigator.OnHide(Sender: TObject);
begin
 if State = nsMinimazed then
  State := nsNormal
 else
  State := nsMinimazed;
end;

procedure TvtNavigator.OnTabSheetClick(Sender: TObject;
  Page: TElTabSheet);
begin
 f_ClickOnTab := True;
 f_Header.IsDragBegining := False;
 if f_State = nsMinimazed then
  State := nsNormal;
 if (Page.ControlCount > 0) then
 begin
  InitDrag(Page.Controls[0]);
  if not Mouse.IsDragging then
   Page.Controls[0].BeginDrag(False);
 end;//Page.ControlCount > 0
end;

procedure TvtNavigator.OpenDelay;
begin
 f_IsDelay := True;
 if f_HideDirect = hdHide then
  f_TimerDelay.Interval := f_DelayIntervalOnShow
 else
  f_TimerDelay.Interval := f_DelayIntervalOnHide;
 f_TimerDelay.Enabled := True;
end;

procedure TvtNavigator.CloseDelay;
begin
  f_TimerDelay.Enabled := False;
  f_IsDelay := False;
  f_DoDelay := False;
  AutoHideUpdate;
  f_DoDelay := True;
end;

procedure TvtNavigator.AutoHideUpdate;

const
  SizeSensitive = 6;

var
 lSaveDirect  : TnpHideDirect;
 lIsNavigator : Boolean;
 lRect        : TRect;
begin
 if f_State <> nsAutoHide then
  Exit;
 if (not Surface.Splitter.IsHideButtonDown or f_TimerFloat.Enabled) and
    (Self.Parent.Handle <> GetCapture) and
    (f_State <> nsMinimazed) and
    not f_MouseDown and
    (f_PageControl.PageCount > 0) then
 begin
  if not f_IsDelay then
  begin
   if f_DoDelay and not ((f_HideDirect = hdHide) and (f_DelayIntervalOnShow = 0)) then
    OpenDelay
   else
   begin
    lSaveDirect := f_HideDirect;
    Windows.GetWindowRect(f_Surface.Handle, lRect);
    lIsNavigator := PtInRect(lRect, Mouse.CursorPos);
    if (f_HideDirect = hdShow) and not lIsNavigator then
     f_HideDirect := hdHide
    else
    if (f_HideDirect = hdHide) and lIsNavigator then
     f_HideDirect := hdShow;

    if lSaveDirect <> f_HideDirect then
     if f_AutoHideFloat then
     begin
      if f_HideDirect = hdShow then
       f_IsFloatingOnShow := True;
      f_TimerFloat.Enabled := True;
     end//f_AutoHideFloat
     else
      ModeAutoUpdate;
   end;//f_DoDelay and not ((f_HideDirect = hdHide) and (f_DelayIntervalOnShow = 0))
  end;//not f_IsDelay
 end//(not Surface.Splitter.IsHideButtonDown or f_TimerFloat.Enabled)
 else
 if f_AutoHideFloat then
  if not f_IsFloatingOnShow then
   f_TimerFloat.Enabled := False;
end;

procedure TvtNavigator.SetSelfSize(ASize: Integer);
begin
 case Self.Align of
  alTop, alBottom:
   Self.Height := ASize;
  alLeft, alRight:
   Self.Width := ASize;
 end;
end;

procedure TvtNavigator.SetSwim(const Value: Boolean);
begin
 f_Swim := Value;
 DoStateChanged;
end;

function TvtNavigator.GetNewBoundsFromPoint(X, Y: Integer): TRect;
begin
 Result := BoundsRect;
 case Align of
  alLeft:
   Result.Right := X;
  alRight:
  begin
   Result.Left := X;
   (* После перетаскивания оставляем курсор в области сплиттера *)
   Dec(Result.Left, cspSize);
  end;
  alTop:
   Result.Bottom := Y;
  alBottom:
   Result.Top := Y;
 end;//case Align of
end;//GetNewBoundsFromPoint

procedure TvtNavigator.DoSplit;

 function lp_CalcPoint: TPoint;

  procedure lp_OffsetPoint(var aPoint: TPoint);
  var
   l_AddSize: Integer;
  begin
   // Размер сплиттера:
   case Align of
    alLeft, alRight:
     l_AddSize := Surface.Splitter.Width;
    alTop, alBottom:
     l_AddSize := Surface.Splitter.Height;
    else
     l_AddSize := 0;
   end;//case Align of
   // Увеличим размер:
   if l_AddSize > 0 then
   begin
    l_AddSize := l_AddSize div 2;
    case Align of
     alLeft, alRight:
      Inc(aPoint.X, l_AddSize);
     alTop, alBottom:
      Inc(aPoint.Y, l_AddSize);
    end;//case Align of
   end;//if l_AddSize > 0 then
  end;//lp_OffsetPoint

  procedure lp_CorrentPoint(var aPoint: TPoint);
  var
   l_SizeMini   : Integer;
   l_ParentRect : TRect;
  begin
   l_SizeMini := GetSizeMini + 4;
   l_ParentRect := Parent.ClientRect;
   // Право
   if aPoint.X > (l_ParentRect.Right - l_SizeMini) then
    aPoint.X := l_ParentRect.Right - l_SizeMini
   else
    // Лево
    if aPoint.X < l_ParentRect.Left + l_SizeMini then
     aPoint.X := l_ParentRect.Left + l_SizeMini;
   // Верх
   if aPoint.Y < l_ParentRect.Top + l_SizeMini then
    aPoint.Y := l_ParentRect.Top + l_SizeMini
   else
    // Низ
    if aPoint.Y > (l_ParentRect.Bottom - l_SizeMini) then
     aPoint.Y := l_ParentRect.Bottom - l_SizeMini;
  end;//lp_CorrentPoint

 begin
  // Получим точку отпускания:
  Result := Parent.ScreenToClient(Mouse.CursorPos);
  // Откорретируем, чтобы она не была меньше минимальных размеров:
  lp_CorrentPoint(Result);
  // Определим размер навигатора таким образом, чтобы после применения новых
  // размеров курсор мыши располагался по середине сплиттера:
  lp_OffsetPoint(Result);
 end;//lp_CalcPoint

 function lp_CalcSize(const aPoint: TPoint): Integer;
 var
  l_NewBounds: TRect;
 begin
  Result := 0;
  l_NewBounds := CorrectBounds(GetNewBoundsFromPoint(aPoint.X, aPoint.Y));
  with l_NewBounds do
   case Align of
    alLeft, alRight:
     Result := Right - Left;
    alTop, alBottom:
     Result := Bottom - Top;
   end;//case Self.Align of
 end;//lp_CalcSize

 procedure lp_ApplyNewSize(const aSize: Integer);
 begin
  // Минимизируем навигатор, если ширину установили меньше допустимой:
  if aSize < cMinNormalSize then
   State := nsMinimazed
  else
  // Установим новый размер:
  begin
   f_SizeNormal := aSize;
   if IsMinimazed then
    State := nsNormal
   else
    if f_State <> nsMinimazed then
     SetSizeNormal(f_SizeNormal);
  end;//if l_NewSize < cMinNormalSize then
 end;//lp_ApplyNewSize

begin//DoSplit
  // 1 - определим точку отпускания;
  // 2 - расчитаем новый размер;
  // 3 - применим новые размеры;
 lp_ApplyNewSize(lp_CalcSize(lp_CalcPoint));
end;//DoSplit

procedure TvtNavigator.DrawSplit(const aRect: TRect);
var
 l_DC            : HDC;
 l_OldBrush      : HBrush;
 l_DesktopHandle : HWND;
 l_Brush         : TBrush;
begin//DrawSplit
 l_DesktopHandle := GetDesktopWindow;
 l_DC := GetDCEx(l_DesktopHandle, 0, DCX_CACHE or DCX_LOCKWINDOWUPDATE);
 try
  l_Brush := TBrush.Create;
  try
   l_Brush.Bitmap := AllocPatternBitmap(clBlack, clWhite);
   l_OldBrush := SelectObject(l_DC, l_Brush.Handle);
   try
    with f_SplitterRect do
     PatBlt(l_DC, Left, Top, Right - Left, Bottom - Top, PATINVERT);
   finally
    SelectObject(l_DC, l_OldBrush);
   end;{try..finally}
  finally
   FreeAndNil(l_Brush);
  end;{try..finally}
 finally
  ReleaseDC(l_DesktopHandle, l_DC);
 end;{try..finally}
end;//DrawSplit

procedure TvtNavigator.PaintSpliter(X, Y              : Integer;
                                    aDrawSplitterType : TnpDrawSplitterTypes);
var
 l_Rect  : TRect;
 l_Point : TPoint;

  function lp_CalcSplitRect: TRect;
  var
   lPoint : TPoint;
  begin
   lPoint := ScreenToClient(Point(X, Y));
   if dstPaint in aDrawSplitterType then
   begin
    case Self.Align of
     alTop, alBottom:
     begin
       Result.Left := 0;
       Result.Right := Self.Width;
       Result.Top := lPoint.Y + cspSize div 2;
       Result.Bottom := Result.Top + cspSize;
     end;
     alLeft, alRight:
     begin
       Result.Left := lPoint.X + cspSize div 2;
       Result.Right := Result.Left + cspSize;
       Result.Top := 0;
       Result.Bottom := Self.Height;
     end;
    end;
   end;
  end;

 procedure lp_MinusPageSize;
 var
  l_Limit: Integer;
 begin
  { Установим ограничения }
  l_Limit := GetSizeMini - cspSize;
  case Self.Align of
   alLeft:
    l_Rect.Left := l_Rect.Left + l_Limit;
   alRight:
    l_Rect.Right := l_Rect.Right - l_Limit;
   alTop:
    l_Rect.Top := l_Rect.Top + l_Limit;
   alBottom:
    l_Rect.Bottom := l_Rect.Bottom - l_Limit;
  end;//case Self.Align of
 end;//lp_CheckPageSize

begin
 { Пересчитаем координаты навигатора в координаты родительского окна }
 l_Point := Parent.ScreenToClient(Point(X, Y));
 l_Rect := Parent.ClientRect;
 { Ограничения на изменение размера }
 if not (aDrawSplitterType = [dstErase]) then
  l_Rect := CorrectBounds(l_Rect);
 lp_MinusPageSize;
 if PtInRect(l_Rect, l_Point) then
 begin
  { Старый сплиттер }
  if dstErase in aDrawSplitterType then
   DrawSplit(f_SplitterRect);
  { Новый сплиттер }
  if dstPaint in aDrawSplitterType then
  begin
   l_Rect := lp_CalcSplitRect;
   l_Point.X := l_Rect.Left;
   l_Point.Y := l_Rect.Top;
   l_Point := Self.ClientToScreen(l_Point);
   f_SplitterRect := l_Rect;
   with f_SplitterRect do
   begin
    Right := l_Point.X + (Left - Right);
    Bottom := l_Point.Y + (Bottom - Top);
    Left := l_Point.X;
    Top := l_Point.Y;
   end;//with f_SplitterRect do
   DrawSplit(f_SplitterRect);
  end;//if dstPaint in aDrawSplitterType then
 end;//if PtInRect(l_Rect, l_Point) then
end;//PaintSpliter

procedure TnpHeader.UpdateSize;
begin
 case Align of
  alLeft, alRight:
   Width := f_Size;
  alTop, alBottom:
   Height := f_Size;
  else
   Height := f_Size;
 end;//case Align
end;

procedure TnpHeader.pm_SetSize(const Value: Integer);
begin
 if (f_Size <> Value) then
 begin
  f_Size := Value;
  UpdateSize;
 end;//f_Size <> Value
end;

procedure TvtNavigator.Cleanup;
//destructor TvtNavigator.Destroy;
begin
 TnpNavigatorList.Instance.UnReg(Self);
 DoSaveSize;

 if f_Float then
 begin
  f_FloatNavigator.f_Navigator := nil;
  PostMessage(f_ParentNavigatorHandle, CM_npDeleteFromList,
   Integer(Pointer(f_FloatNavigator)), 0);
 end;//f_Float
 l3Free(f_NavigatorList);
 FreeAndNil(f_TimerDelay);
 FreeAndNil(f_TimerFloat);

 if (f_Header <> nil) then
 begin
  if (f_Header.Navigator <> nil) then
  begin
   Assert(f_Header.Navigator = Self);
   Self.UnRegisterStateChanged(f_Header.f_Link);
   f_Header.Navigator := nil;
  end;//f_Header.Navigator <> nil
 end;//f_Header <> nil
 FreeAndNil(f_Header);

 inherited;
end;

procedure TvtNavigator.AfterDestroyCalled;
  {-}
begin
 (* f_ChangeLinks удаляем после всех, потому, что в Inherited-е компоненты
    описывается от нотификации *)
 l3Free(f_ChangeLinks);
 inherited;
end;

procedure TvtNavigator.Paint;
begin
 inherited;
end;

function TvtNavigator.FindFloatNavigator: TnpFloatingWindow;
var
  Index: Integer;
begin
  Result := nil;
  Index := 0;
  while (Index <= Application.ComponentCount - 1) and (Result = nil) do
  begin
    if Application.Components[Index] is TnpFloatingWindow then
      Result := Application.Components[Index] as TnpFloatingWindow;
    Inc(Index);
  end;
end;

function TvtNavigator.DockToFloatNavigator(aControl : TControl) : TnpFloatingWindow;
var
  lIsCreate: Boolean;

  procedure SetFloatingSize(aNavigator : TnpFloatingWindow;
                            aControl   : TControl);
  var
   l_Parent : TControl;
  begin//SetFloatingSize
   aNavigator.Width := aControl.Width;
   aNavigator.Height := aControl.Height;
   l_Parent := aControl.Parent;
   while True do
   begin
    if not Assigned(l_Parent) then
     Break;
    if (l_Parent is TnpFloatingWindow) then
    begin
     aNavigator.Width := l_Parent.Width;
     aNavigator.Height := l_Parent.Height;
     Break;
    end;//l_Parent is TnpFloatingWindow
    l_Parent := l_Parent.Parent;
   end;//while True
  end;//SetFloatingSize

  function CreateNavigator : TnpFloatingWindow;
  var
   l_Owner : TComponent;
   l_Rect  : TRect;
  begin//CreateNavigator
   SetRectEmpty(l_Rect);
   if f_Float then
    l_Owner := f_FloatNavigator.Owner
   else
    l_Owner := Self;
   Result := GetFloatingWindowClass.CreateNew(l_Owner);
   Result.Navigator.AssignNav(Self);
   SetFloatingSize(Result, aControl);
   with Result.f_Navigator do
   begin
    f_SingleFloatNavigator := Self.f_SingleFloatNavigator;
    f_UnDockFromFloat      := Self.f_UnDockFromFloat;
    f_Header.Size          := Self.f_Header.Size;
   end;//with Result.f_Navigator
   { Зарегистрируем плаващий навигатор }
   if f_Float then
   begin
    f_NavigatorOnForm.AddNavigator(Result);
    Result.f_Navigator.NavigatorOnForm := f_NavigatorOnForm;
   end//f_Float
   else
   begin
    AddNavigator(Result);
    Result.f_Navigator.NavigatorOnForm := Self;
   end;//f_Float
   {$IfDef Nemesis}
   if (aControl is TvcmForm) then
   begin
    { Определим идентификатор навигатора }
    if (TvcmForm(aControl).FloatID > 0) and not f_Float then
     Result.FloatID := TvcmForm(aControl).FloatID
    else
     Result.FloatID := RandomRange(1, 1000);
    // если закладку отстыковали не перетаскиванием, а по DblClick-у или
    // программно, то восстанавливаем размер плавающей формы
    if not IsUndockByUser then
     l_Rect := TvcmForm(aControl).FloatWindowBounds;
   end;
   {$EndIf Nemesis}
   { Положение нового навигатора }
   if IsRectEmpty(l_Rect) then
    l_Rect := CalcNewFloatBounds;

   // Проверяем не вылазием ли мы за границы видимой рабочей области экрана
   // http://mdp.garant.ru/pages/viewpage.action?pageId=331187752
   l_Rect := vcmUtils.vcmCheckWindowBounds(l_Rect);

   Result.BoundsRect := l_Rect;
   { Не показываем если пристыковали невидимый объект (см. CMDockNotification) }
   {$IfDef Nemesis}
   if (aControl Is TvcmEntityForm) then
    Result.Visible := aControl.Visible AND TvcmEntityForm(aControl).FloatingVisible
   else
   {$EndIf Nemesis}
    Result.Visible := aControl.Visible;
   (* устанавливаем здесь, потому, что vcl умничает и в процедуре SetVisible
    устанавливает окно там, где находится главное окно приложения, а мы хотим
    там где отпустил пользователь *)
   Result.BoundsRect := l_Rect;
   {$IfDef Nemesis}
    { Состояние навигатора }
    if not IsUndockByUser and ((TvcmForm(aControl).FloatWindowState and
      cFloatMinimized) = cFloatMinimized) then
     Result.State := fwsMinimized;
   {$EndIf Nemesis}
  end;//CreateNavigator

  function DockToExistsFloat(var aFindingWindow : TnpFloatingWindow) : Boolean;
  {$IfDef Nemesis}
  var
   l_Index : Integer;
   lFloat : TnpFloatingWindow;
  {$EndIf Nemesis}
  begin//DockToExistsFloat
   Result := False;
   {$IfDef Nemesis}
   if (aControl is TvcmForm) and (TvcmForm(aControl).FloatID > 0) then
   begin
    for l_Index := 0 to Pred(TnpNavigatorList.Instance.Count) do
    begin
     if TvtNavigator(TnpNavigatorList.Instance[l_Index]).Float then
     begin
      lFloat := TvtNavigator(TnpNavigatorList.Instance[l_Index]).f_FloatNavigator;
      if (lFloat.FloatID  = TvcmForm(aControl).FloatID) and
       // Т.к. регистрируются навигаторы для всех главных окон выбираем только
       // те, которые принадлежат форме, от которой отстыковываем 
       (lFloat.Navigator.f_MainForm = f_MainForm) then
      begin
       Result := True;
       aFindingWindow := lFloat;
       aControl.ManualDock(lFloat.Navigator.PageControl);
       Break;
      end;//lFloat.FloatID  = TvcmForm(aControl).FloatID..
     end;//TvtNavigator(TnpNavigatorList.Instance[l_Index]).Float
    end;//for l_Index
   end;//(aControl is TvcmForm) and (TvcmForm(aControl).FloatID > 0)
   {$EndIf Nemesis}
  end;//DockToExistsFloat

begin
 Result := nil;
 lIsCreate := False;
 if (aControl <> nil) then
 begin
  { Компонент был вытащен из плавающего навигатора и ни к кому не пристыкован }
  if f_DockInSelf then
    aControl.ManualDock(f_PageControl)
  { Новый плавающий }
  else
  begin
   { Один плавающий на всех }
   if f_SingleFloatNavigator then
     Result := FindFloatNavigator
   else
   { Пристыковываем к навигатору по идентификатору }
// !! временно задействовал
// !! проблема: при переключении конфигураций, если в обеих есть плавающие навигаторы
// !! в DockToExistsFloat форма дочится к _старому_(!) плавающему навигатору, который умрёт,
// !! когда до него долетит CM_RELEASE (он и не умер-то до сих пор потому, что сообщение
// !! в очереди
//
// !! выключил - зацикливание в каком-то специфическом случае. Видимо, проблему пристыковки
// !! надо как-то по-другому решать.
//   afw.ProcessMessages;
   if not IsUndockByUser and DockToExistsFloat(Result) then
    Exit;
   if (Result = nil) then
   begin
    Result := CreateNavigator;
    lIsCreate := True;
   end;//Result = nil
   f_ClickOnTab := False;
   if f_Header.IsDragBegining then
   begin
    f_Header.IsDragBegining := False;
    Result.f_Navigator.MovePagesToNavigator(Self, aControl);
   end//f_Header.IsDragBegining
   else
   begin
    aControl.ManualDock(Result.Navigator.PageControl);
    {$IfDef Nemesis}
    if (aControl Is TvcmEntityForm) then
     TvcmEntityForm(aControl).CheckFloatingVisibility;
    {$EndIf Nemesis}
   end;//f_Header.IsDragBegining
   { Новый навигатор }
   if lIsCreate then
   begin
    with Result do
    begin
     Constraints.MinHeight := f_Navigator.GetSizeMini + f_Navigator.f_Header.Height;
     Constraints.MinWidth := Constraints.MinHeight * 2;
     with f_Navigator.f_PageControl.Pages[0].Controls[0] do
     begin
      UndockWidth := Result.Width;
      UndockHeight := Result.Height;
     end;//with f_Navigator.f_PageControl.Pages[0].Controls[0]
    end;//with Result
   end;//lIsCreate
  end;//f_DockInSelf
 end;//aControl <> nil
end;

procedure TvtNavigator.SetFloat(const Value: Boolean);
begin
 f_Float := Value;
 DoStateChanged;
end;

procedure TnpHeader.WMEraseBkgnd(var Message: TWMEraseBkgnd);
//message WM_ERASEBKGND;
begin
 Message.Result := 1;
end;

procedure TnpHeader.pm_SetCloseImage(const Value : TImageIndex);
begin
 if (f_CloseImage <> Value) then
 begin
  f_CloseImage := Value;
  UpdateCloseImage;
  UpdateHideImage;
 end;//f_CloseImage <> Value
end;

procedure TnpHeader.pm_SetAutoHideOnImage(const Value : TImageIndex);
begin
 if (f_AutoHideOnImage <> Value) then
 begin
  f_AutoHideOnImage := Value;
  UpdateAutoHideImage;
 end;//f_AutoHideOnImage <> Value
end;

procedure TnpHeader.pm_SetAutoHideOffImage(const Value : TImageIndex);
begin
 if (f_AutoHideOffImage <> Value) then
 begin
  f_AutoHideOffImage := Value;
  UpdateAutoHideImage;
 end;//f_AutoHideOffImage <> Value
end;

function TnpHeader.GetAlign: TAlign;
begin
 Result := inherited Align;
end;

procedure TnpHeader.SetAlign(Value : TAlign);
  {-}
begin
 inherited Align := Value;
 UpdatePositions;
end;

procedure TnpHeader.pm_SetHideRightImage(const Value : TImageIndex);
begin
 if (f_HideRightImage <> Value) then
 begin
  f_HideRightImage := Value;
  DoStateChanged;
 end;//f_HideRightImage <> Value
end;

procedure TnpHeader.pm_SetHideLeftImage(const Value : TImageIndex);
begin
 if (f_HideLeftImage <> Value) then
 begin
  f_HideLeftImage := Value;
  DoStateChanged;
 end;//f_HideLeftImage <> Value
end;

function TnpHeader.pm_GetOnAutoHide: TNotifyEvent;
begin
 Result := AutoHideButton.OnClick;
end;

function TnpHeader.pm_GetOnHide : TNotifyEvent;
begin
 Result := HideButton.OnClick;
end;

procedure TnpHeader.pm_SetOnAutoHide(const Value: TNotifyEvent);
begin
 AutoHideButton.OnClick := Value;
end;

procedure TnpHeader.pm_SetOnHide(const Value: TNotifyEvent);
begin
 HideButton.OnClick := Value;
end;

procedure TnpHeader.pm_SetNavigator(const Value: TvtNavigator);
begin
 if (f_Navigator <> Value) then
 begin
  if f_Navigator <> nil then
   f_Navigator.UnRegisterStateChanged(f_Link);

  f_Navigator := Value;

  if f_Navigator <> nil then
   f_Navigator.RegisterStateChanged(f_Link);
 end;//f_Navigator <> Value
end;

procedure TnpHeader.DoStateChanged;
begin
 with f_Navigator do
 begin
  UpdateHideImage;
  UpdateAutoHideImage;
  if f_Navigator.Float then
  begin
   with AutoHideButton do
   begin
    GroupIndex := 0;
    Down := False;
   end;//with AutoHideButton
  end//f_Navigator.Float
  else
  begin  
   case State of
    nsMinimazed:
    begin
     HideButton.Visible := True;
     AutoHideButton.Visible := False;
     CloseButtonVisible(False);
    end;//nsMinimazed
    nsNormal:
    begin
     HideButton.Visible := True;
     AutoHideButton.Down := True;
     AutoHideButton.Visible := True;
     CloseButtonVisible(True);
    end;//nsNormal
    nsAutoHide:
    begin
     with AutoHideButton do
     begin
      Down := False;
      Visible := True;
     end;//AutoHideButton
     HideButton.Visible := f_Navigator.f_HideDirect = hdShow;
     CloseButtonVisible(HideButton.Visible);
    end;//nsAutoHide
   end;//case State
  end;//f_Navigator.Float
 end;//with f_Navigator
end;

procedure TnpHeader.OnStateChanged(Sender: TObject);
begin
 DoStateChanged;
end;

procedure TnpHeader.CloseButtonVisible(aValue: Boolean);
  {* - изменить видимость кнопки закрыть, установить кнопку видимой без
       установленного обработчика OnClick нельзя. }
begin
 if Assigned(CloseButton.OnClick) then
  CloseButton.Visible := aValue
 else
 if not aValue then
  CloseButton.Hide;
end;

procedure TnpHeader.ShowCloseButton(const aHandler: IvcmFormHandler);
  {-}
begin
 if Assigned(aHandler.Handler) AND
    aHandler.CanHaveCloseButtonInNavigator then
 begin
  if (f_CloseButton <> nil) then
   with CloseButton do
   begin
    OnClick := aHandler.Handler;
    Hint := l3Str(aHandler.Hint);
    CloseButtonVisible(True);
   end//with CloseButton do
 end//Assigned(aHandler.Handler)
 else
  HideCloseButton
end;//ShowCloseButton

procedure TnpHeader.HideCloseButton;
  {-}
begin
 if (CloseButton <> nil) then
  with CloseButton do
  begin
   OnClick := nil;
   CloseButtonVisible(False);
  end;//with CloseButton
end;

procedure TnpHeader.UpdateImages;
begin
 UpdateAutoHideImage;
 UpdateHideImage;
 UpdateCloseImage;
end;

{ TnpFloatingWindow }

procedure TnpFloatingWindow.OnChangeState(Sender: TObject);
begin
 if f_State = High(TnpFloatWindowState) then
  State := Low(TnpFloatWindowState)
 else
  State := Succ(f_State);
end;

procedure TnpFloatingWindow.OnCloseWindow(Sender: TObject);
begin
 (* Пристыкуем компоненты к навигаторам на форме *)
 with f_Navigator.PageControl do
  while PageCount > 0 do
   if Pages[0].ControlCount > 0 then
    TnpControlsList.Instance.DockOnForm(Pages[0].Controls[0]);
end;

procedure TnpFloatingWindow.OnTabSheetClick(Sender: TObject;
  Page: TElTabSheet);
begin
 // развернём окно, если свернуто
 State := fwsNormal;
 // начнем перетаскивание
 f_Navigator.OnTabSheetClick(Sender, Page);
end;//TnpFloatingWindow.OnTabSheetClick

function TnpFloatingWindow.CloseQuery: Boolean;
var
 l_Index : Integer;
 lPC    : TnpPageControl;
begin
 Result := inherited CloseQuery;
 if Result then
  f_FloatID := 0;
 l_Index := 0;
 lPC    := f_Navigator.PageControl;
 while Result and (l_Index <= Pred(lPC.PageCount)) do
 begin
  if (lPC.Pages[l_Index].ControlCount > 0) and
   (lPC.Pages[l_Index].Controls[0] is TCustomForm) then
   Result := TCustomForm(lPC.Pages[l_Index].Controls[0]).CloseQuery;
  Inc(l_Index);
 end;//while Result and (l_Index <= Pred(lPC.PageCount))
end;

constructor TnpFloatingWindow.CreateNew(AOwner: TComponent; Dummy: Integer = 0);
begin
 inherited CreateNew(AOwner);
 Caption := 'Плавающий навигатор';
 BorderIcons := [];
 FormStyle := fsStayOnTop;
 OnClose := FormClose;
 OnResize := FormOnResize;
 f_FloatID := 0;
 f_State := fwsNormal;
 f_Navigator := GetNavigatorClass.Create(Self);
 f_Navigator.Parent := Self;
 f_Navigator.f_FloatNavigator := Self;
 f_Navigator.Float := True;
 f_Navigator.Align := alClient;
 with f_Navigator.PageControl do
 begin
  Visible := True;
  //Assert(not Assigned(OnTabSheetClick));
  // - закомментировал, т.к. падало при отдочивании оглавления
  OnTabSheetClick := Self.OnTabSheetClick;
  // http://mdp.garant.ru/pages/viewpage.action?pageId=344754050&focusedCommentId=346751217&#comment-346751217
  Assert(not Assigned(OnDockDrop));
  OnDockDrop := Self.OnDockDrop;
  // http://mdp.garant.ru/pages/viewpage.action?pageId=344754050&focusedCommentId=346750985#comment-346750985
  Align := alClient;
 end;//with f_Navigator.PageControl
 with f_Navigator.Header do
 begin
  Visible := True;
  OnHide := OnCloseWindow;
  OnAutoHide := OnChangeState;
 end;//with f_Navigator.Header
 f_Navigator.DockSite := False;
end;

procedure TvtNavigator.SetSingleFloatNavigator(const Value: Boolean);
begin
 f_SingleFloatNavigator := Value;
end;

procedure TnpFloatingWindow.SetBounds(ALeft, ATop, AWidth, AHeight: Integer);
// override;
begin
 inherited;
end;

function TnpFloatingWindow.GetNavigatorClass: RvtNavigator;
  // virtual;
  {* - ссылка на класс навигатора. }
begin
 Result := TvtNavigator;
end;

procedure TnpFloatingWindow.Cleanup;
  //override;
  {-}
begin
 f_CloseDisabled := false;
 f_ReactivateDisabled := false;
 inherited;
end;

procedure TnpFloatingWindow.CreateParams(var Params: TCreateParams);
begin
 inherited CreateParams(Params);
 with Params do
 begin
  if (Parent = nil) and (ParentWindow = 0) then
  begin
   Style := Style or WS_POPUP;
   ExStyle := ExStyle and not WS_EX_APPWINDOW or WS_EX_TOOLWINDOW;
  end;
  Style := Style and not WS_CAPTION;
  case f_State of
   fwsNormal:
    Style := Style or WS_THICKFRAME;
   fwsMinimized:
    Style := Style and not WS_THICKFRAME;
  end;//case f_State
 end;//with Params
end;

procedure TnpFloatingWindow.DisableClose;
  {-}
begin
 Assert(FormStyle = fsStayOnTop);
 f_CloseDisabled := true;
end;

procedure TnpFloatingWindow.DisableReactivate;
  {-}
begin
 Assert(FormStyle = fsStayOnTop);
 f_ReactivateDisabled := true;
end;

procedure TnpFloatingWindow.FormClose(Sender: TObject;
  var Action: TCloseAction);
begin
 if f_CloseDisabled then
  Action := caHide
 else
  Action := caFree;
end;

procedure TvtNavigator.OnEndDockControl(Sender, Target: TObject; X,
  Y: Integer);
var
 Index: Integer;
 l_Control : TControl;
begin
 if (f_ExportPageControl <> nil) then
 begin
  f_PageControl.OnUnDock := nil;
  for Index := Pred(f_PageControl.PageCount) downto 0 do
  begin
   l_Control := f_PageControl.Pages[Index].Controls[0];
   if l_Control is TForm then
    TForm(l_Control).OnEndDock := nil;
   l_Control.ManualDock(f_ExportPageControl);
  end;//for Index
  f_ExportPageControl := nil;
 end//f_ExportPageControl <> nil
 else
 if (f_Header.IsDragBegining) or
    (f_Float and (f_PageControl.PageCount = 1)) then
 begin
  with f_FloatNavigator do
  begin
   // Установим новую позицию окна
   BoundsRect := CalcNewFloatBounds;
   {$IfDef Nemesis}
   // Обновим информацию о положении окна у TvcmForm`s
   UpdateFloatWindowsBounds;
   {$EndIf Nemesis}
  end;//with f_FloatNavigator
  f_Header.IsDragBegining := False;
 end;//(f_Header.IsDragBegining) or (f_Float and (f_PageControl.PageCount = 1))
 TForm(f_EndDockClient).OnEndDock := nil;
end;

procedure TvtNavigator.DoSaveSize;
begin
 if Assigned(f_OnSaveSize) then
  f_OnSaveSize(Self, f_SizeNormal);
end;

procedure TvtNavigator.UpdateCloseButton;
var
 l_Index : Integer;
begin
 if (Header <> nil) then
  with PageControl do
   if (ActivePage <> nil) and (ActivePage.ControlCount > 0) then
   begin
    if TvtNavigatorFormList.Instance.FindData(TvtFormHandlerID_C(ActivePage.Controls[0]), l_Index) then
     Header.ShowCloseButton(TvtNavigatorFormList.Instance.Items[l_Index].CloseHandler)
    else
     Header.HideCloseButton;
   end//if PageControl.ActivePage <> nil then
   else
    Header.HideCloseButton;
end;//UpdateCloseButton

procedure TvtNavigator.OnPageControlChange(Sender: TObject);
var
 l_Size : Integer;
begin
 if (f_PageControl.PageCount = 0) then
 begin
  f_PageControl.Visible := False; // костыль для http://mdp.garant.ru/pages/viewpage.action?pageId=324009991
                                  // http://mdp.garant.ru/pages/viewpage.action?pageId=324009991&focusedCommentId=330141913
  if f_Float then
   f_FloatNavigator.Close
  else
  begin
   (* запомним текущий нормальный размер *)
   l_Size := f_Surface.Size;
   // Устанавливаем только для нормального размера
   if f_State = nsNormal then
    f_SizeNormal := l_Size;
   (* сохраним размер *)
   DoSaveSize;
   SetSizeEmpty(f_SizeEmpty);
  end;//f_Float
 end//f_PageControl.PageCount = 0
 else
  f_Header.Invalidate;
 UpdateCloseButton;
 DoStateChanged;
end;

procedure TvtNavigator.AddNavigator(P: TnpFloatingWindow);
var
  Index: Integer;
begin
 Index := f_NavigatorList.IndexOf(P);
 if (Index = -1) then
  f_NavigatorList.Add(P);
end;

procedure TvtNavigator.DelNavigator(P: TnpFloatingWindow);
var
  Index: Integer;
begin
 Index := f_NavigatorList.IndexOf(P);
 if (Index <> -1) then
  f_NavigatorList.Delete(Index);
end;

{$IfDef Nemesis}
procedure TnpFloatingWindow.UpdateFloatWindowsBounds;
var
 l_Index : Integer;
 l_R : TRect;
begin
 if Assigned(f_Navigator) and Assigned(f_Navigator.PageControl) then
  with f_Navigator.PageControl do
   for l_Index := 0 to Pred(PageCount) do
    if (Pages[l_Index].ControlCount > 0) and
       (Pages[l_Index].Controls[0] is TvcmForm) then
     with TvcmForm(Pages[l_Index].Controls[0]) do
     begin
      l_R := Self.BoundsRect;
      with l_R do
       Bottom := Top + Self.f_SizeNormal;
      FloatWindowBounds := l_R;
     end;//TvcmForm(Pages[l_Index].Controls[0])
end;
{$EndIf Nemesis}

procedure TnpFloatingWindow.FormOnResize(Sender: TObject);
begin
 if (f_State = fwsNormal) then
  f_SizeNormal := Self.Height;
 {$IfDef Nemesis}
 UpdateFloatWindowsBounds;
 {$EndIf Nemesis}
end;

procedure TnpFloatingWindow.OnDockDrop(Sender: TObject;
  Source: TDragDockObject; X, Y: Integer);
begin
 {$IfDef Nemesis}
 if Source.Control is TvcmForm then
  TvcmForm(Source.Control).FloatID := f_FloatID;
 {$EndIf Nemesis}
end;

procedure TnpFloatingWindow.WMNCCalcSize(var Message: TWMNCCalcSize);
 //message WM_NCCALCSIZE;
begin
 inherited;
 case f_State of
  fwsNormal:
   with Message.CalcSize_Params.rgrc[0] do
    Dec(Bottom, GetSystemMetrics(SM_CYHSCROLL));
  fwsMinimized:
   InflateRect(Message.CalcSize_Params.rgrc[0], -GetSystemMetrics(SM_CXBORDER),
    -GetSystemMetrics(SM_CYBORDER));
 end;//case f_State
end;

procedure TnpFloatingWindow.WMNCPaint(var Message: TMessage);
var
 l_DC : HDC;
 l_R  : TRect;
begin
 l_DC := GetWindowDC(Handle);
 try
  case f_State of
   fwsNormal:
   begin
    // Рисуем рамку
    inherited;
    // Нарисуем скроллер
    with Canvas.Brush do
    begin
     Color := clBtnFace;
     Style := bsSolid;
    end;//with Canvas.Brush
    l_R := GetGripperRect;
    // мы вычислили всё честно, DrawFrameControl почему то отрисовывает рамку
    // на один пиксел меньше, поэтому увеличим
    InflateRect(l_R, 1, 1);
    // рисуем
    DrawFrameControl(l_DC, l_R, DFC_SCROLL, DFCS_SCROLLSIZEGRIP);
   end;//fwsNormal
   fwsMinimized:
   begin
    Windows.GetWindowRect(Handle, l_R);
    OffsetRect(l_R, -l_R.Left, -l_R.Top);
    DrawEdge(l_DC, l_R, EDGE_RAISED, BF_RECT or BF_FLAT);
   end;//fwsMinimized
  end;//case f_State
 finally
  ReleaseDC(Handle, l_DC);
 end;//try..finally
end;

function TnpFloatingWindow.CheckGripperCursor : Boolean;
var
 l_Rect : TRect;
begin
 Result := False;
 // навигатор в свернутом состоянии, гриппер у него отсутствием
 if (f_State = fwsMinimized) then
  Exit;
 // получим позицию окна
 GetWindowRect(Handle, l_Rect);
 // вычислим положение gripper-а на экране
 l_Rect.Left := l_Rect.Right - GetGripperHeight;
 l_Rect.Top := l_Rect.Bottom - GetGripperHeight;
 // 
 if PtInRect(l_Rect, Mouse.CursorPos) then
  Result := True;
end;

function TnpFloatingWindow.GetGripperHeight : Integer;
begin
 Result := GetSystemMetrics(SM_CYHSCROLL);
end;

procedure TnpFloatingWindow.pm_SetState(const aValue : TnpFloatWindowState);
var
 lFlag : Integer;
{$IfDef Nemesis}
 l_Index : Integer;
{$EndIf Nemesis}

 function lfnMinimizedSize : Integer;
 begin//lfnMinimizedSize
  with f_Navigator do
   Result := Header.Height + PageControl.MaxTabHeight;
 end;//lfnMinimizedSize

begin
 if aValue = f_State then
  Exit;
 f_State := aValue;
 // текущий стиль окна
 lFlag := GetWindowLong(Handle, GWL_STYLE);
 case f_State of
  // свернём навигатор
  fwsMinimized:
  begin
   Self.Height := lfnMinimizedSize;
   lFlag := lFlag xor WS_THICKFRAME;
  end;//fwsMinimized
  // развернём навигатор
  fwsNormal:
  begin
   // если плавающий был создан минимизированным, то используем высоту навигатора
   // на форме для его разворачивания
   if f_SizeNormal <= lfnMinimizedSize then
    f_SizeNormal := f_Navigator.NavigatorOnForm.Height;
   Height := f_SizeNormal;
   lFlag := lFlag  or WS_THICKFRAME;
  end;//fwsNormal
 end;//case f_State
 // изменим стиль окна
 SetWindowLong(Handle, GWL_STYLE, lFlag);
 // перерисуем
 Perform(CM_BORDERCHANGED, 0, 0);
 f_Navigator.Header.UpdateAutoHideImage;
 {$IfDef Nemesis}
 // нужно обновить информацию о состоянии плавающей формы
 with Navigator.PageControl do
  for l_Index := 0 to Pred(PageCount) do
   if (Pages[l_Index].ControlCount > 0) and
    (Pages[l_Index].Controls[0] is TvcmForm) then
    TvcmForm(Pages[l_Index].Controls[0]).FloatWindowState :=
     IfThen((f_State = fwsMinimized), cFloatMinimized);
 {$EndIf Nemesis}
end;

function TnpFloatingWindow.GetGripperRect : TRect;
begin
 // положение в пределах Desctop
 GetWindowRect(Handle, Result);
 // размеры навигатора
 OffsetRect(Result, -Result.Left, -Result.Top);
 // уменьшим чтобы не заслонять рамку
 InflateRect(Result, -GetSystemMetrics(SM_CXSIZEFRAME),
  -GetSystemMetrics(SM_CYSIZEFRAME));
 // область отрисовки gripper
 Result.Top := Result.Bottom - GetGripperHeight;
end;

procedure TnpFloatingWindow.WMNCHitTest(var Message: TWMNCHitTest);
begin
 // унаследованный
 inherited;
 // проверим
 if CheckGripperCursor then
  Message.Result := HTBOTTOMRIGHT;
end;

procedure TnpFloatingWindow.WMEraseBkgnd(var Message : TWMEraseBkgnd);
// message WM_ERASEBKGND;
begin
 Message.Result := 1;
end;

{ TvtNavigator }

procedure TvtNavigator.SetUndockSize;
var
  l_Index: Integer;
begin
 for l_Index := 0 to f_PageControl.PageCount - 1 do
 begin
  with f_PageControl.Pages[l_Index] do
  begin
   if (ControlCount > 0) then
    if f_Float then
    begin
     Controls[0].UndockHeight := Self.Height;
     Controls[0].UndockWidth := Self.Width;
    end//f_Float
    else
    begin
     Controls[0].UndockHeight := f_PageControl.Height;
     Controls[0].UndockWidth := f_PageControl.Width;
    end;//f_Float
  end;//with f_PageControl.Pages[l_Index]
 end;//for l_Index
end;

procedure TvtNavigator.OnPageControlResize(Sender: TObject);
begin
 SetUndockSize;
end;

procedure TvtNavigator.OnTimerDelay(Sender: TObject);
begin
 CloseDelay;
end;

procedure TvtNavigator.SetDelayOnAutoHide(const Value: Boolean);
begin
 if not Value then
  f_TimerDelay.Enabled := False;
 f_DelayOnAutoHide := Value;
 f_DoDelay := Value;
end;

procedure TvtNavigator.OnTimerFloat(Sender: TObject);
const
 clDelta = 30;
var
 lDelta  : Integer;
 lDist   : Integer;
 lLimit  : Integer;
 lIsExit : Boolean;
 lBounds : TRect;
begin
 lIsExit := False;
 // Определим приращение
 if (f_HideDirect = hdHide) then
 begin
  lDelta := -clDelta;
  lDist  := -clDelta;
  lLimit := SizeMini;
 end//f_HideDirect = hdHide
 else
 begin
  lDelta := clDelta;
  lDist  := clDelta;
  lLimit := f_SizeNormal;
 end;//f_HideDirect = hdHide
 // Текущие размеры
 lBounds := f_Surface.BoundsRect;
 // Опредим не достигли ли мы пределного сворачивания/разворачивания
 case Align of
  alLeft, alRight:
   if f_HideDirect = hdHide then
    lIsExit := (f_Surface.Width + lDist <= lLimit) or
     (f_Surface.Width + lDelta < lLimit)
   else
    lIsExit := (f_Surface.Width + lDist >= lLimit) or
     (f_Surface.Width + lDelta > lLimit);
  alTop, alBottom:
   if f_HideDirect = hdHide then
    lIsExit := (f_Surface.Height + lDist <= lLimit)  or
     (f_Surface.Height + lDelta < lLimit)
   else
    lIsExit := (f_Surface.Height + lDist >= lLimit)  or
     (f_Surface.Height + lDelta > lLimit);
 end;//case Align
 // Устновим новый размер
 case Align of
  alLeft:
   with lBounds do
   begin
    if lIsExit then
     Right := Left + lLimit
    else
     Inc(Right, lDelta);
   end;
  alRight:
   with lBounds do
    if lIsExit then
     Left := Right - lLimit
    else
     Dec(Left, lDelta);
  alTop:
   with lBounds do
    if lIsExit then
     Bottom := Top + lLimit
    else
     Inc(Bottom, lDelta);
  alBottom:
   with lBounds do
    if lIsExit then
     Top := Bottom - lLimit
    else
     Inc(Top, lDelta);
 end;//case Align
 // Устновим новые размеры
 Windows.SetWindowPos(f_Surface.Handle, 0, lBounds.Left, lBounds.Top,
  lBounds.Right - lBounds.Left, lBounds.Bottom - lBounds.Top, SWP_NOACTIVATE or
   SWP_NOZORDER);
end;

function TvtNavigator.GetFloatingWindowClass: RnpFloatingWindow;
  // virtual;
  {* - получить класс плавающего окна. }
begin
 Result := TnpFloatingWindow;
end;

function TvtNavigator.GetPageControlClass: RnpPageControl;
  //virtual;
  {-}
begin
 Result := TnpPageControl;
end;//GetPageControlClass

procedure TvtNavigator.SetParent(AParent: TWinControl);
begin
 inherited;
 DoNotifyControls(Self, CM_npTabPositionChanged, 0, 0);
end;

{ TnpPageControl }

procedure TnpPageControl.PMIsActiveControl(var Message : TMessage);
  //message PM_ISACTIVECONTROL;
begin
 inherited;
 // установим что сообщение обработано
 Message.ResultLo := 1;
 // если закладка свернута, то она не активна
 Message.ResultHi := Integer((ActivePage = TElTabSheet(Message.WParam)) and
  (f_Navigator.State = nsNormal));
end;

procedure TnpPageControl.PMSetActivePageWithControl(var Message : TMessage);
  //message PM_SETACTIVEPAGEWITHCONTROL;
begin
 inherited;
 if f_Navigator.State <> nsNormal then
  f_Navigator.State := nsNormal;
end;

procedure TnpPageControl.WMEraseBkgnd(var Message : TMessage);
//message WM_ERASEBKGND;
begin
 Message.Result := 1;
end;

procedure TnpPageControl.CMDockNotification(
 var Message: TCMDockNotification);
 //message CM_DOCKNOTIFICATION;
begin
 inherited;
 case Message.NotifyRec.ClientMsg of
  CM_VISIBLECHANGED:
  begin
   if Boolean(Message.NotifyRec.MsgWParam) then
   begin
    if f_Navigator.Float then
    begin
    { Если при создании плавающего навигатора в OnPageControlUnDock подают
      Client.Visible, то FMgrState(True) не вызывается, навигатор не отображается.
      Когда клиента показывают, то показываем и навигатор. }
     with f_Navigator.f_FloatNavigator do
      Visible := True;
    end//f_Navigator.Float
    else
     f_Navigator.InitDockDrop;
   end;//Boolean(Message.NotifyRec.MsgWParam)
  end;//CM_VISIBLECHANGED
 end;//case Message.NotifyRec.ClientMsg
end;

procedure TnpPageControl.Notification(AComponent : TComponent;
                                      Operation  : TOperation);
//override;
{* - удаляем из списка компонентов навигатора на форме. }
begin
 inherited;
 if (Operation = opRemove) and (AComponent is TControl) then
  TnpControlsList.Instance.DeleteControl(TControl(AComponent));
end;

procedure TnpPageControl.GetSiteInfo(Client: TControl;
  var InfluenceRect: TRect; MousePos: TPoint; var CanDock: Boolean);
begin
 inherited GetSiteInfo(Client, InfluenceRect, MousePos, CanDock);
 if CanDock then
  if Assigned(f_Navigator.OnGetSiteInfo) then
   f_Navigator.OnGetSiteInfo(Self, Client, InfluenceRect, MousePos, CanDock);
end;

procedure TvtNavigator.OnStartDragControl(Sender: TObject;
  aDragControl: TControl);
begin
 if (aDragControl is TForm) then
 begin
  TForm(aDragControl).OnEndDock := OnEndDockControl;
  f_EndDockClient := aDragControl;
 end;//aDragControl is TForm
end;

procedure TvtNavigator.CMDelNavFromList(var Message: TMessage);
begin
 DelNavigator(Pointer(Message.wParam));
end;

function TvtNavigator.GetImages: TCustomImageList;
begin
 Result := f_PageControl.Images;
end;

{$IfDef Nemesis}
function TvtNavigator.SaveState(out theState: IUnknown;
 aStateType: TvcmStateType): Boolean;
begin
 Result := f_PageControl.SaveState(theState, aStateType);
end;

function TvtNavigator.LoadState(const aState: IUnknown;
 aStateType: TvcmStateType): Boolean;
begin
 Result := f_PageControl.LoadState(aState, aStateType);
end;
{$EndIf Nemesis}

procedure TvtNavigator.SetImages(const Value: TCustomImageList);
begin
 f_PageControl.Images := Value;
end;

procedure TvtNavigator.pm_SetNavigatorOnForm(const Value: TvtNavigator);
begin
 f_NavigatorOnForm := Value;
 if (Value <> nil) then
  f_ParentNavigatorHandle := Value.Handle
 else
  f_ParentNavigatorHandle := 0;
end;

function TvtNavigator.GetState : TNavigatorState;
begin
 Result := f_State;
end;

procedure TvtNavigator.AttachSurface;
begin
 with f_Surface do
 begin
  Parent := Self;
  Align := alClient;
 end;//with f_Surface do
end;//AttachSurface

procedure TvtNavigator.DetachSurface;
begin
 with Surface do
 begin
  Align  := alNone;
  Parent := Self.Parent;
  PlaceSurface;
 end;//with f_Surface do
 Perform(CM_npDoActionWithFormControls, Ord(acUpInZOrder), 0);
end;

procedure TvtNavigator.SetState(const Value: TNavigatorState);
begin
 if (Value <> f_State) then
 begin
  if (f_State = nsAutoHide) then
  begin
   f_TimerFloat.Enabled := False;
   f_TimerDelay.Enabled := False;
  end;//f_State = nsAutoHide
  f_State := Value;
  // При открытии приложения изначально панели должны быть скрыты в авторежиме:
  if f_State = nsAutoHide then
   f_TimerFloat.Enabled := True;
  UpdateState;
  DoStateChanged(True);
 end;//Value <> f_State
end;

function TvtNavigator.GetDockRect(aDockSize : Integer = -1) : TRect;
const
 cDockSize = 50;
begin
 if aDockSize = -1 then
  aDockSize := cDockSize;
 GetWindowRect(Self.Handle, Result);
 { Область докинга }
 case Self.Align of
  alBottom:
   with Result do
    Top := Bottom - aDockSize;
  alTop:
   with Result do
    Bottom := Top + aDockSize;
  alLeft:
   with Result do
    Right := Left + aDockSize;
  alRight:
   with Result do
    Left := Right - aDockSize;
 end;//case Self.Align
end;

procedure TvtNavigator.SetDockRect(DragDockObject: TDragDockObject);
begin
 if (State = nsAutoHide) and (f_PageControl.PageCount > 0) then
  DragDockObject.DockRect := GetDockRect(f_SizeNormal)
 else
 if f_PageControl.PageCount = 0 then
  DragDockObject.DockRect := GetDockRect(GetNavigatorSizeNormal(DragDockObject.Control));
end;

procedure TvtNavigator.PositionDockRect(
  DragDockObject: TDragDockObject);
 //override;
var
 l_Rect : TRect;
begin
 if (f_PageControl.PageCount = 0) or (State = nsAutoHide) then
 begin
  l_Rect := GetDockRect;
  if PtInRect(l_Rect, DragDockObject.DragPos) then
  begin
   SetDockRect(DragDockObject);
   Exit;
  end;//PtInRect(l_Rect, DragDockObject.DragPos)
 end;//(f_PageControl.PageCount = 0) or (State = nsAutoHide)
 inherited PositionDockRect(DragDockObject);
end;

procedure TvtNavigator.SetName(const Value: TComponentName);
begin
 inherited SetName(Value);
 if Assigned(f_PageControl) then
  f_PageControl.Name := Value;
end;

function TvtNavigator.IsActiveControl(aControl: TControl): Boolean;
begin
 Result := False;
 if Assigned(f_PageControl) then
  Result := f_PageControl.IsActiveControl(aControl);
end;

function TvtNavigator.DoLoadSize: Integer;
begin
 Result := -1;
 if Assigned(f_OnLoadSize) then
  f_OnLoadSize(Self, Result);
end;

function TvtNavigator.CalcNewFloatBounds : TRect;
const
 cMultiplier = 20;
var
 l_Left    : Integer;
 l_Top     : Integer;
 l_Height  : Integer;
 l_Width   : Integer;
 l_Monitor : TRect;
 l_Cursor  : TPoint;
 l_Dist    : Integer;
 l_Rect    : TRect;
begin
 l_Height := 0;
 l_Width  := 0;
 l_Cursor := Mouse.CursorPos;
 if IsUndockByUser then
 begin
  l_Left := l_Cursor.X - f_ClickPoint.X;
  l_Top  := l_Cursor.Y - f_ClickPoint.Y;
 end//IsUndockByUser
 else
 begin
  Windows.GetWindowRect(Handle, l_Rect);
  l_Left := l_Rect.Left;
  l_Top := l_Rect.Top;
 end;//IsUndockByUser
 (* Сместим плавающий навигатор относительно навигатора на форме *)
 if f_DblClickUnDock or not IsUndockByUser then
 begin
  Inc(f_CountUndock);
  if f_CountUndock > 10 then
   f_CountUndock := 1;
  l_Dist := f_CountUndock * cMultiplier;
  l_Monitor := Screen.MonitorFromPoint(l_Cursor).BoundsRect;
  (* Сместим вверх или вниз *)
  if l_Top + l_Dist < l_Monitor.Bottom then
   Inc(l_Top, l_Dist)
  else
   Dec(l_Top, l_Dist);
  (* Для навигаторов справа, внизу сдвигаем рамку плавающего навигатора вверх,
     влево *)
  if Align in [alRight, alBottom] then
   l_Dist := -l_Dist;
  (* Сместим вправо или влево *)
  if l_Left + l_Dist < l_Monitor.Right then
   Inc(l_Left, l_Dist)
  else
   Dec(l_Left, l_Dist);
  f_DblClickUnDock := False;
 end;
 (* Размеры нового навигатора *)
 if f_Float then
  with f_FloatNavigator do
  begin
   l_Height := Height;
   l_Width := Width;
  end//with f_FloatNavigator
 else
 begin
  // Так нужно делать потому, что в режиме автоскрытия размеры меняются, а
  // размер рамки должен быть как у прикрепленного навигатора
  case Align of
   alLeft, alRight:
   begin
    l_Height := Height;
    l_Width := f_SizeNormal;
   end;//alLeft, alRight
   alTop, alBottom:
   begin
    l_Width := Width;
    l_Height := f_SizeNormal;
   end;//alTop, alBottom
  end;//case Align
 end;//f_Float
 (* Положение плавающего навигатора *)
 Result := Rect(l_Left,
                l_Top,
                l_Left + l_Width,
                l_Top  + l_Height);
end;

{$IfDef Nemesis}
procedure TvtNavigator.OnFormPositionDockRect(Sender: TObject;
  DragDockObject: TDragDockObject);
begin
 if (DragDockObject.DragTarget = nil) then
  DragDockObject.DockRect := CalcNewFloatBounds;
end;
{$EndIf Nemesis}

procedure TvtNavigator.InitDrag(aControl : TControl);
begin

 { Получим размеры будущей формы }
 if f_Float then
  f_DockRect := f_FloatNavigator.BoundsRect
 else
  f_DockRect := GetDockRect(f_SizeNormal);

 { Навигатор может быть плавающим и его видимые размеры (размеры PageControl-а)
   больше чем сам TvtNavigator в связи с этим рассчитаем положение мышы,
   чтобы не зависеть от размеров TvtNavigator }
 f_ClickPoint.X := f_DockRect.Left - Mouse.CursorPos.X;
 f_ClickPoint.X := Abs(f_ClickPoint.X);
 f_ClickPoint.Y := f_DockRect.Top - Mouse.CursorPos.Y;
 f_ClickPoint.Y := Abs(f_ClickPoint.Y);
 { Размеры навигатора были получены в экранных координатах, пересчитаем }
 OffsetRect(f_DockRect, -f_DockRect.Left, -f_DockRect.Top);

 { Для отрисовки тени }
 {$IfDef Nemesis}
 if aControl is TvcmForm then
  TvcmForm(aControl).OnPositionDockRect := OnFormPositionDockRect;
 {$EndIf Nemesis}

end;

procedure TnpPageControl.DoActivePrevPage;
begin
 if (f_Navigator.State = nsNormal) and (PageCount = 1) then
  f_Navigator.State := nsMinimazed
 else 
  inherited;
end;

constructor TnpPageControl.Create(AOwner: TComponent);
begin
 inherited;
 ControlStyle := ControlStyle + [csNoDesignVisible];
 TabStop := True;
 DrawFocusRect := True;
 ShowBorder := False;
 Font.Charset := RUSSIAN_CHARSET;
end;

procedure TnpPageControl.RequestTabPosition;
begin
 inherited;
 if Assigned(f_Navigator) then
  if Assigned(f_Navigator.Parent) then
    (* Проверяем parent, потому что иначе при отстыковке закладки при попытке
       получить Handle получим исключение что parent не определен. *)
   DoNotifyControls(f_Navigator, CM_npTabPositionChanged, 0, 0);
end;

procedure TnpPageControl.DockDrop(Source: TDragDockObject; X, Y: Integer);
//override;
begin
 if not f_Navigator.Float then
  TnpControlsList.Instance.AddControl(f_Navigator, Source.Control);
 inherited;
end;

procedure TnpPageControl.WMKeyDown(Var Msg: TWMKeyDown);
begin
 if not IsHandledShortcut(Msg) then
  inherited;
end;

procedure TnpPageControl.WMSysKeyDown(var Msg: TWMSysKeyDown);
begin
 if not IsHandledShortcut(Msg) then
  inherited;
end;

function TnpPageControl.IsHandledShortcut(var Msg: TWMKeyDown): Boolean;
var
 l_Controller : TOvcController;
begin
 Result := false;
 l_Controller := GetDefController;
 if Assigned(l_Controller) then
  with l_Controller.EntryCommands do
   if TranslateUsing([], TMessage(Msg), GetTickCount) = ccShortCut then
   begin
    Msg.Result := 0;  {indicate that this message was processed}
    Result := true;
   end;//TranslateUsing([], TMessage(Msg), GetTickCount) = ccShortCut
end;
{ TnpButton }

procedure TnpButton.WMMouseMove(var Message : TWMMouseMove);
//message WM_MOUSEMOVE;
begin
 inherited;
 Windows.SetCursor(Screen.Cursors[crDefault]);
end;

function TnpButton.MakeHint: String;
begin
 Result := '';
 case f_BtnType of
  nbtAutoHide:
   // навигатор на форме
   if not f_Navigator.Float then
   begin
    if (f_Navigator.State = nsAutoHide) then
      Result := f_Navigator.AutoHideOffHint
    else
      Result := f_Navigator.AutoHideOnHint
   end//not f_Navigator.Float
   // плавающий навигатор
   else
   if (f_Navigator.f_FloatNavigator.State = fwsMinimized) then
    Result := f_Navigator.MinimazedOffHint
   else
    Result := f_Navigator.MinimazedOnHint;
  nbtMinimazed:
   // навигатор на форме
   if not f_Navigator.Float then
   begin
    // навигатор скрыт
    if f_Navigator.State = nsMinimazed then
     Result := f_Navigator.MinimazedOffHint
    // навигатор нормальный
    else
     Result := f_Navigator.MinimazedOnHint;
   end//not f_Navigator.Float
   // плавающий навигатор
   else
    Result := f_Navigator.CloseHint;
  else
   Result := Hint;
 end;//case f_BtnType of
end;//MakeHint

procedure TnpButton.CMHintShow(var Message: TCMHintShow);
begin
 Message.HintInfo.HintStr := MakeHint;
 inherited;
end;

constructor TnpButton.Create(aOwner          : TComponent;
                             aNavigator      : TvtNavigator;
                             aBtnType        : TnpButtonType);
begin
 inherited Create(AOwner);
 // inherited
 ShowHint := True;
 ControlStyle := ControlStyle + [csNoDesignVisible];
 // internal
 f_Navigator := aNavigator;
 f_BtnType := aBtnType;
end;

procedure TvtNavigator.CMnpDockToFloatWindow(var Message : TMessage);
// message CM_npDockToFloatWindow;
var
 l_Control : TControl;
 l_Float   : TnpFloatingWindow;
begin
 if (Message.WParam > 0) and (not (csDestroying in ComponentState)) then
 begin
  l_Control := TControl(Message.WParam);
  l_Float := DockToFloatNavigator(l_Control);
  // ни к кому не пристыковали, такого не может быть
  Assert(Assigned(l_Float));
  {$IfDef Nemesis}
  // если форму пристыковали к уже существующему навигатору, то нужно обновить
  // FloatWindowBounds
  if (l_Control is TvcmForm) then
   TvcmForm(l_Control).FloatWindowBounds := l_Float.BoundsRect;
  {$EndIf Nemesis}
 end;//(Message.WParam > 0) and (not (csDestroying in ComponentState))
end;

procedure TvtNavigator.CMNPDoActionWithFormControls(var Message: TMessage);
// message CM_npDoActionWithFormControls;
var
 l_Index   : Integer;
 l_Control : TControl;
begin//CMNPDoActionWithFormControls
 for l_Index := Pred(Parent.ControlCount) downto 0 do
 begin
  l_Control := Parent.Controls[l_Index];
  if not (l_Control is TvtNavigator)and not (l_Control is TnpSurface) and
   (l_Control.Align = alNone) then
   case TnpDoActionWithFormControl(Message.WParam) of
    acRedraw:
     if l_Control is TWinControl then
      Windows.RedrawWindow(TWinControl(l_Control).Handle, nil, 0,
       RDW_FRAME or RDW_INVALIDATE or RDW_INTERNALPAINT);
    acUpInZOrder:
     l_Control.BringToFront;
   end;//case TnpDoActionWithFormControl(Message.WParam) of
 end;//for l_Index := Pred(Parent.ControlCount) downto 0 do
end;//CMNPDoActionWithFormControls

procedure TvtNavigator.pm_SetShowActivePageInHeader(const aValue: Boolean);
begin
 f_ShowActivePageInHeader := aValue;
 f_Header.Invalidate;
end;

{ TnpSurface }

procedure TnpSurface.Cleanup;
// override;
begin
 {$IfDef NavigatorPanelNeedsTb97}
 l3Free(f_Link);
 {$Else}
 FreeAndNil(f_Link);
 {$EndIf NavigatorPanelNeedsTb97}
 inherited;
end;

constructor TnpSurface.Create(AOwner: TComponent);
begin
 inherited;
 f_Container := TnpContainerSurface.Make(Self);
 //f_Panel := TvtPanel.Create(Self);
 //f_Panel.Parent := Self;
 //f_Panel.Align := alClient;
 f_Splitter := TnpSplitter.Make(Self{, f_Panel});
 f_Link := TnpChangeLink.Create;
 f_Link.OnStateChanged := OnStateChanged;
end;

procedure TnpSurface.pm_SetHeader(const Value: TnpHeader);
begin
 if (f_Header <> Value) then
 begin
  f_Header := Value;
  if (f_Header <> nil) then
  begin
   f_Header.Parent := f_Container.Parent;
   f_Header.Align  := alTop;
  end;//f_Header <> nil
 end;//f_Header <> Value
end;

procedure TnpSurface.DefineSplitterAlign;
begin
 case f_Navigator.Align of
  alTop:
   f_Splitter.Align := alBottom;
  alLeft:
   f_Splitter.Align := alRight;
  alRight:
   f_Splitter.Align := alLeft;
  alBottom:
   f_Splitter.Align := alTop;
 end;//case f_Navigator.Align
end;

procedure TnpSurface.pm_SetNavigator(const Value: TvtNavigator);
begin
 if f_Navigator <> nil then
  f_Navigator.UnRegisterStateChanged(f_Link);

 f_Navigator := Value;

 if f_Navigator <> nil then
  f_Navigator.RegisterStateChanged(f_Link);
end;

procedure TnpSurface.WMEraseBkgnd(var Message : TMessage);
//message WM_ERASEBKGND;
begin
 Message.Result := 1;
end;

procedure TnpSurface.pm_SetPageControl(const Value: TnpPageControl);
begin
 if (f_PageControl <> Value) then
 begin
  f_PageControl := Value;
  if (f_PageControl <> nil) then
  begin
   f_PageControl.Parent := f_Container;
   f_PageControl.Align  := alClient;
  end;//f_PageControl <> nil
 end;//f_PageControl <> Value
end;

procedure TvtNavigator.DoAutoHide;
begin
 if (f_PageControl.PageCount = 0) then
  Exit;
 f_TimerDelay.Enabled := True;
 f_HideDirect := hdHide;
 DetachSurface;
 with f_Surface do
 begin
  SetSizeMini;
  InitAutoHidePosition;
 end;//with f_Surface
 SetSizeMini;
end;

procedure TnpSurface.SetSizeMini;
begin
 case f_Navigator.Align of
  alBottom, alTop:
   Height := f_Navigator.SizeMini;
  alLeft, alRight:
   Width := f_Navigator.SizeMini;
 end;//case f_Navigator.Align
end;

procedure TvtNavigator.Assign(aDest : TPersistent);
  //override;
  {-}
begin
 if (aDest Is TvtNavigator) then
  AssignNav(TvtNavigator(aDest))
 else
  inherited;
end;

procedure TvtNavigator.AssignNav(aDest : TvtNavigator);
// override;
{-}
begin
 ButtonsImageList := aDest.ButtonsImageList;
 AutoHideOffImage := aDest.AutoHideOffImage;
 AutoHideOnImage  := aDest.AutoHideOnImage;
 CloseImage       := aDest.CloseImage;
 HideDownImage    := aDest.HideDownImage;
 HideLeftImage    := aDest.HideLeftImage;
 HideRightImage   := aDest.HideRightImage;
 HideUpImage      := aDest.HideUpImage;
 CloseHint        := aDest.CloseHint;
 AutoHideOffHint  := aDest.AutoHideOffHint;
 AutoHideOnHint   := aDest.AutoHideOnHint;
 MinimazedOffHint := aDest.MinimazedOffHint;
 MinimazedOnHint  := aDest.MinimazedOnHint;
end;

function TvtNavigator.MinBtnHint : String;
begin
 Result := f_Header.HideButton.MakeHint;
end;

procedure TvtNavigator.SetBounds(ALeft, ATop, AWidth, AHeight: Integer);
begin
 {$IfDef DesignTimeLibrary}
 if Align = alNone then
  inherited
 else
 begin
  case Align of
   alLeft, alRight :
    AWidth := 20;
   alTop, alBottom :
    AHeight := 20;
  end;
  inherited;
 end;//case Align
 {$Else DesignTimeLibrary}
 (* Нельзя устанавливать навигатору без закладок ширину (высоту) больше
    f_SizeEmpty. Это может происходить в результате чтения размеров компонента из
    настроек *)
 if not Assigned(f_PageControl) or (f_PageControl.PageCount = 0) then
 begin
  case Align of
   alBottom, alTop:
   begin
    if (AHeight <= f_SizeEmpty) or (AHeight = SizeMini) then
     inherited
    else
     inherited SetBounds(ALeft, ATop, AWidth, Height);
   end;//alBottom, alTop
   alLeft, alRight:
   begin
    if (AWidth <= f_SizeEmpty) or (AWidth = SizeMini) then
     inherited
    else
     inherited SetBounds(ALeft, ATop, Width, AHeight);
   end;//alLeft, alRight
   else
    inherited;
  end;//case Align
  Exit;
 end;//not Assigned(f_PageControl) or (f_PageControl.PageCount = 0)
 inherited;
 {$EndIf DesignTimeLibrary}
end;

procedure TvtNavigator.RegisterStateChanged(aLink : TnpChangeLink);
begin
 if (f_ChangeLinks = nil) then Exit;

 if f_ChangeLinks.IndexOf(aLink) = -1 then
  f_ChangeLinks.Add(aLink);
end;

procedure TvtNavigator.UnRegisterStateChanged(aLink : TnpChangeLink);
var
 l_Index : Integer;
begin
 if (f_ChangeLinks = nil) then Exit;

 l_Index := f_ChangeLinks.IndexOf(aLink);
 if l_Index <> -1 then
  f_ChangeLinks.Delete(l_Index);
end;

function TnpSurface.pm_GetSize: Integer;
begin
 case f_Navigator.Align of
  alBottom, alTop:
   Result := Height;
  alLeft, alRight:
   Result := Width;
  else
   Result := Width;
 end;//case f_Navigator.Align
end;

procedure TnpSurface.AdjustClientRect(var Rect : TRect);
begin
 inherited;
end;

procedure TvtNavigator.PublishFormHanders(const aCloseHandler: IvcmFormHandler);
var
 l_Class: TvtNavigatorForm;
begin
 l_Class := TvtNavigatorForm.Create(aCloseHandler);
 try
  TvtNavigatorFormList.Instance.Add(l_Class);
  aCloseHandler.Form.FreeNotification(Self);
 finally
  FreeAndNil(l_Class);
 end;//try..finally
 UpdateCloseButton;
end;//PublishFormHanders

{$IfDef Nemesis}
procedure TvtNavigator.SmallToolbarSize(aValue: Integer);
begin
 if Assigned(f_Header) then
  f_Header.Size := aValue;
end;
{$EndIf Nemesis}

procedure TvtNavigator.WMEraseBkgnd(var Message: TWMEraseBkgnd);
//message WM_ERASEBKGND;
begin
 Message.Result := 1;
end;

function TvtNavigator.pm_GetIsMinimazed: Boolean;
begin
 Result := f_State =  nsMinimazed;
end;

procedure TnpSurface.InitAutoHidePosition;
begin
 if (f_Navigator.State = nsAutoHide) then
 begin
  case f_Navigator.Align of
   alRight:
    Left := f_Navigator.Parent.ClientWidth - Self.Width;
   alBottom:
    Top := f_Navigator.Parent.ClientHeight - Self.Height;
  end;//case f_Navigator.Align
 end;//f_Navigator.State = nsAutoHide
end;

procedure TnpSurface.OnStateChanged(Sender : TObject);
begin
 f_Splitter.Visible := (*(f_Navigator.State <> nsMinimazed) and*)
                      not f_Navigator.Float and
                      (f_Navigator.PageControl.PageCount > 0);
end;

procedure TnpSurface.Paint;

 procedure npDrawGradient(aRect       : TRect;
                          aBeginColor : TColor = clBtnHighlight;
                          aEndColor   : TColor = clBtnShadow);
 var
  lI         : Integer;
  lStartRGB  : Array[0..2] of Byte;
  lEndRGB    : Array[0..2] of Byte;
  lStartC    : TColor;
  lEndC      : TColor;
  lColors    : Word;
  lRDist, lGDist, lBDist : Integer;
  lRTmp, lGTmp, lBTmp : Integer;
 begin//npDrawGradient
  // цвета
  lStartC := ColorToRGB(aBeginColor);
  lEndC := ColorToRGB(aEndColor);
  // массив с исходными цветами (lStartC)
  lStartRGB[0] := GetRValue(lStartC);
  lStartRGB[1] := GetGValue(lStartC);
  lStartRGB[2] := GetBValue(lStartC);
  // массив с конечными цветами (lEndC)
  lEndRGB[0] := GetRValue(lEndC);
  lEndRGB[1] := GetGValue(lEndC);
  lEndRGB[2] := GetBValue(lEndC);
  // расстояние между каждым цветом
  lRDist := Abs(lEndRGB[0] - lStartRGB[0]);
  lGDist := Abs(lEndRGB[1] - lStartRGB[1]);
  lBDist := Abs(lEndRGB[2] - lStartRGB[2]);
  // количество цветов которые будут нарисованы
  lColors := aRect.Right - aRect.Left;
  for lI := 0 to Pred(lColors) do
    with Canvas do
    begin
     // красный
     lRTmp := MulDiv(lI, lRDist, Pred(lColors));
     if lStartRGB[0] > lEndRGB[0] then
      lRTmp := - lRTmp;
     // зеленый
     lGTmp := MulDiv(lI, lGDist, Pred(lColors));
     if lStartRGB[1] > lEndRGB[1] then
      lGTmp := - lGTmp;
     // синий
     lBTmp := MulDiv(lI, lBDist, Pred(lColors));
     if lStartRGB[2] > lEndRGB[2] then
      lBTmp := - lBTmp;
     // установим цвет и нарисуем
     Pen.Color :=  RGB(
      (lStartRGB[0] + lRTmp),
      (lStartRGB[1] + lGTmp),
      (lStartRGB[2] + lBTmp));
     MoveTo(aRect.Left + lI, aRect.Top);
     LineTo(aRect.Left + lI, aRect.Bottom);
    end;//with Canvas
 end;//npDrawGradient

var
 l_R : TRect;
begin
 if (csDesigning in ComponentState) then
 begin
  l_R := ClientRect;
  with Canvas do
  begin
   with Pen do
   begin
    Color := clBlack;
    Width := 1;
   end;//with Pen
   Rectangle(l_R);
  end;//with Canvas
  InflateRect(l_R, -1, -1);
  npDrawGradient(l_R, clRed, clMaroon);
 end//csDesigning in ComponentState
 else
 begin
  (* Заливаем только когда на подложке никого нет, иначе у компонентов слетает
     то, что нарисовали в WMNCPaint *)
  if Assigned(f_Navigator) and Assigned(f_Navigator.PageControl) and
   (f_Navigator.PageControl.PageCount = 0) then
  with Canvas do
  begin
   Brush.Color := clWhite{clBtnFace};
   FillRect(ClientRect);
  end;//with Canvas
 end;//csDesigning in ComponentState
end;

{ TnpContainerSurface }

class function TnpContainerSurface.Make(aSurface : TnpSurface) : TnpContainerSurface;
begin
 Result := Create(aSurface);
 with Result do
 begin
  Parent := aSurface;
  Align := alClient;
  Surface := aSurface;
 end;//with Result
end;

procedure TnpContainerSurface.pm_SetSurface(const Value : TnpSurface);
begin
 f_Surface := Value;
end;

procedure TnpContainerSurface.WMEraseBkgnd(var Message: TWMEraseBkgnd);
begin
 Message.Result := 1;
end;

{ TnpSplitter }

function TnpSplitter.GetButtonRect : TRect;

 function lDefineSize(const aSize : Integer) : Integer;
 begin//lDefineSize
  if (cspButtonSize > aSize) then
   Result := aSize div 3
  else
   Result := cspButtonSize;
 end;//lDefineSize

var
 l_Size : Integer;
begin
 SetRectEmpty(Result);
 // горизонтальный сплиттер
 if (Width > Height) then
 begin
  l_Size := lDefineSize(ClientWidth);
  Result.Left := (ClientWidth - l_Size) div 2;
  Result.Right := Result.Left + l_Size;
  Result.Top := 0;
  Result.Bottom := ClientHeight;
 end//Width > Height
 // вертикальный сплиттер
 else
 begin
  l_Size := lDefineSize(ClientHeight);
  Result.Top := (ClientHeight - l_Size) div 2;
  Result.Bottom := Result.Top + l_Size;
  Result.Left := 0;
  Result.Right := ClientWidth;
 end;//Width > Height
 Inc(Result.Left);
end;

procedure TnpSplitter.DrawButton(aCanvas : TCanvas = nil);
const
 cButtonState : array [Boolean] of Integer = (0, DFCS_PUSHED);
var
 l_Rect    : TRect;
 l_Center  : Integer;

 procedure DrawArrow(aY     : Integer;
                     aColor : TColor);
 var
  l_Delta   : Integer;
  l_Left    : Boolean;
    {* - стрелка указывает влево. }
  l_Index   : Integer;
 begin//DrawArrow
  // куда указывает стрелка
  l_Left := (Align = alRight);
  if f_Surface.Navigator.IsMinimazed then
   l_Left := not l_Left;
  // инициализируем дельту
  if l_Left then
   l_Delta := 0
  else
   l_Delta := Pred(l_Rect.Right) - l_Rect.Left;
  // первая точка
  for l_Index := l_Rect.Left to Pred(l_Rect.Right) do
  begin
   with aCanvas do
   begin
    Pixels[l_Index, aY - l_Delta] := aColor;
    Pixels[l_Index, aY + l_Delta] := aColor;
   end;//with aCanvas
   if l_Left then
    Inc(l_Delta)
   else
    Dec(l_Delta);
  end;//for l_Index
 end;//DrawArrow

begin
 if not Assigned(aCanvas) then
  aCanvas := Canvas;
 // область расположения
 l_Rect := GetButtonRect;
 // кнопка
 DrawFrameControl(aCanvas.Handle,
                  l_Rect,
                  DFC_BUTTON, DFCS_BUTTONPUSH or cButtonState[IsHideButtonDown]);
 // нужно доделать если появится такое выравнивание
 //Assert((Align <> alTop) and (Align <> alBottom));
 // точка стрелочки
 l_Center := (l_Rect.Top + l_Rect.Bottom) div 2;
 // рисуем
 InflateRect(l_Rect, -1, -1);
 DrawArrow(l_Center, clBlue);
 // следующая строка делает толщину стрелки шире
 // DrawArrow(Succ(l_Center), clBlue);
end;

procedure TnpSplitter.splShowHint(X, Y : Integer);
var
 l_HintRect : TRect;
 l_Hint     : String;
 l_Temp     : TRect;
 l_Window   : THintWindow;
 l_Monitor  : TMonitor;
begin
 // Опустим будущее окно под курсор
 Inc(X, 16);
 // Окно
 l_Window := CreateButtonHint;
 // Hint
 l_Hint := f_Surface.Navigator.MinBtnHint;
 // Размещение окна
 l_Monitor := Screen.MonitorFromPoint(Mouse.CursorPos);
 if not Assigned(l_Monitor) then
  Exit;
 l_Temp.TopLeft := ClientToScreen(Point(X, Y));
 // Посчитаем размер прямоугольника учитывая ограничения текущим монитором
 l_HintRect := l_Window.CalcHintRect(l_Monitor.WorkareaRect.Right - l_Temp.Left,
  l_Hint, nil);
 l_Temp.Right := l_Temp.Left + l_HintRect.Right;
 l_Temp.Bottom := l_Temp.Top + l_HintRect.Bottom;
 // Покажем
 l_Window.ActivateHint(l_Temp, l_Hint);
end;

function TnpSplitter.CreateButtonHint: THintWindow;
begin
 if (HideButtonHint = nil) then
 begin
  HideButtonHint := THintWindow.Create(Self);
  with HideButtonHint do
  begin
   Color:= GetSysColor(COLOR_INFOBK);
   Canvas.Brush.Color:= GetSysColor(COLOR_INFOBK);
   Canvas.Font:= Self.Font;
   Canvas.Font.Color:= GetSysColor(COLOR_INFOTEXT);
   Canvas.Pen.Color:= clBlack;
  end;//with HideButtonHint
 end;//HideButtonHint = nil
 Result := HideButtonHint;
end;//CreateButtonHint

procedure TnpSplitter.splHideHint;
begin
 if HideButtonHint <> nil then
  HideButtonHint.ReleaseHandle;
end;//splHideHint

procedure TnpSplitter.UpdateCursor(aButton : Boolean = True);
begin
 if aButton then
  Cursor := crHandPoint
 else
  SetSizeCursor;
 // это нужно, чтобы при смене курсора компонента поменялся курсор на экране
 Windows.SetCursor(Screen.Cursors[Cursor]);
end;

procedure TnpSplitter.MouseMove(Shift : TShiftState;
                                X, Y  : Integer);
//override;
var
 l_Types  : TnpDrawSplitterTypes;
 l_Button : Boolean;
begin
 // Курсор вышел за пределы сплиттера, освободим захват курсора:
 if not PtInRect(ClientRect, Point(X, Y)) then
 begin
  // Если перетаскивают, то ничего делать не нужно:
  if not IsMouseDown and (GetCapture = Handle) then
    ReleaseCapture;
  // Мы перетаскиваем поэтому подсказку надо спрятать:
  splHideHint;
 end//if not PtInRect(ClientRect, Point(X, Y)) then
 // Захватим курсор, нам это необходимо иначе не всегда приходит событие
 // CMMouseLeave и мы не освобождаем подсказку к кнопке + это необходимо при
 // перетаскивании:
 else
  if GetCapture <> Handle then
   SetCapture(Handle);
 if not (ssLeft in Shift) then
 begin
  if not GetParentForm(Self).Active then
   Exit;
  l_Button := PtInRect(GetButtonRect, Point(X, Y));
  // Установим курсор:
  UpdateCursor(l_Button);
  // Покажем подсказку:
  if l_Button then
   splShowHint(X, Y)
  else
   splHideHint;
 end//not (ssLeft in Shift) 
 else
 // Сплиттер перетаскивают:
 if IsMouseDown then
 begin
  l_Types := [dstErase, dstPaint];
  if IsHideButtonDown then
  begin
   // Отожмем кнопку:
   IsHideButtonDown := False;
   // изменим курсор
   UpdateCursor(False);
   // Первая отрисовка, очищать не надо:
   l_Types := [dstPaint];
  end;//IsHideButtonDown
  // Нарисуем сплиттер:
  with Mouse.CursorPos do
   f_Surface.Navigator.PaintSpliter(X, Y, l_Types);
 end;//if IsMouseDown then
end;//MouseMove

procedure TnpSplitter.MouseDown(Button : TMouseButton;
                                Shift  : TShiftState;
                                X, Y   : Integer);
//override;
begin
 if (Button = mbLeft) then
 begin
  IsMouseDown := True;
  // запомним, чтобы определить в MouseUp, что пользователь двигал мыш
  f_MouseDownPoint := Mouse.CursorPos;
  // кнопка нажата
  if PtInRect(GetButtonRect, Point(X, Y)) then
   IsHideButtonDown := True
  else
  begin
   // нарисуем сплиттер
   with Mouse.CursorPos do
    f_Surface.Navigator.PaintSpliter(X, Y, [dstPaint]);
  end;//PtInRect(GetButtonRect, Point(X, Y))
 end;//Button = mbLeft
end;

procedure TnpSplitter.MouseUp(Button : TMouseButton;
                              Shift  : TShiftState;
                              X, Y   : Integer);
//override;
begin
 splHideHint;
 IsMouseDown := False;
 if not (Button = mbLeft) then
  Exit;
 with f_Surface.Navigator do
 begin
  // Изменение размеров навигатора:
  if not IsHideButtonDown then
  begin
   // Удалим нарисованный сплиттер:
   PaintSpliter(Mouse.CursorPos.X, Mouse.CursorPos.Y, [dstErase]);
   Perform(CM_npDoActionWithFormControls, Ord(acRedraw), 0);
   // Изменим размеры навигатора:
   if not PointsEqual(f_MouseDownPoint, Mouse.CursorPos) then
   begin
    DoSplit;
    AutoHideUpdate;
   end;//if not PointsEqual(f_MouseDownPoint, Mouse.CursorPos) then
  end//if not IsHideButtonDown then
  // развернём/свернём навигатор
  else
  begin
   IsHideButtonDown := False;
   State := TNavigatorState(IfThen(State = nsMinimazed, Ord(nsNormal),
    Ord(nsMinimazed)));
  end;//if not PointsEqual(f_MouseDownPoint, Mouse.CursorPos) then
 end;//with f_Surface.Navigator do
end;//MouseUp

constructor TnpSplitter.Create(aOwner : TComponent);
//override;
begin
 inherited;
 // Видимость изменится при добавлении первой закладки
 ControlStyle := ControlStyle + [csNoDesignVisible];
 Visible := False;
 Cursor := crHSplit;
 f_IsHideButtonDown := False;
 IsMouseDown := False;
end;

procedure TnpSplitter.Cleanup;
// override;
begin
 splHideHint;
 FreeAndNil(f_HideButtonHint);
 inherited;
end;//Cleanup

class function TnpSplitter.Make(aSurface : TnpSurface) : TnpSplitter;
begin
 Result := TnpSplitter.Create(aSurface);
 with Result do
 begin
  //Parent := aParent;
  Parent := aSurface;
  Align := alRight;
  Width := cspSize;
  Surface := aSurface;
 end;//with Result do
end;//Make

procedure TnpSplitter.Paint;
var
 l_R : TRect;
begin
 l_R := ClientRect;
 with Canvas do
 begin
  // заливаем
  Brush.Color := cGarant2011BackColor{clBtnFace};
  FillRect(l_R);
  // рисуем справа, слева линии clShadow
  Pen.Color := clBtnShadow;
  if (Surface.Navigator.Align <> alLeft) then
  begin
   MoveTo(l_R.Left, l_R.Top);
   LineTo(l_R.Left, l_R.Bottom);
  end;//Surface.Navigator.Align <> alLeft
  if (Surface.Navigator.Align <> alRight) then
  begin
   MoveTo(Pred(l_R.Right), l_R.Top);
   LineTo(Pred(l_R.Right), l_R.Bottom);
  end;//Surface.Navigator.Align <> alRight
 end;//with Canvas
 // рисуем кнопку сплиттера
 DrawButton;
end;//Paint

procedure TnpSplitter.SetSizeCursor;
begin
 case f_Surface.Navigator.Align of
  alLeft, alRight:
   Cursor := crHSplit;
  alTop, alBottom:
   Cursor := crVSplit;
 end;//case f_Surface.Navigator.Align of
end;//SetSizeCursor

procedure TnpSplitter.pm_SetButtonDown(const Value : Boolean);
begin
 if (f_IsHideButtonDown <> Value) then
 begin
  f_IsHideButtonDown := Value;
  DrawButton;
 end;//f_IsHideButtonDown <> Value
end;

function TnpSplitter.IsHandledShortcut(
  var Msg: TWMKeyDown): Boolean;
var
 l_Controller : TOvcController;
begin
 Result := false;
 l_Controller := GetDefController;
 if Assigned(l_Controller) then
  with l_Controller.EntryCommands do
   if TranslateUsing([], TMessage(Msg), GetTickCount) = ccShortCut then
   begin
    Msg.Result := 0;  {indicate that this message was processed}
    Result := true;
   end;//TranslateUsing([], TMessage(Msg), GetTickCount) = ccShortCut
end;

procedure TnpSplitter.WMKeyDown(var Msg: TWMKeyDown);
begin
 if not IsHandledShortcut(Msg) then
  inherited;
end;

procedure TnpSplitter.WMSysKeyDown(var Msg: TWMSysKeyDown);
begin
 if not IsHandledShortcut(Msg) then
  inherited;
end;

procedure TnpSplitter.CNKeyDown(var Msg: TWMKeyDown);
begin
 if not IsHandledShortcut(Msg) then
  inherited;
end;

procedure TnpSplitter.CNSysKeyDown(var Msg: TWMSysKeyDown);
begin
 if not IsHandledShortcut(Msg) then
  inherited;
end;

procedure TnpSplitter.pm_SetSurface(const Value: TnpSurface);
begin
 f_Surface := Value;
end;

end.
