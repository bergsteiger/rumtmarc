unit TreeAttributeSelect_Form;

// $Id: TreeAttributeSelect_Form.pas,v 1.39 2013/04/24 09:35:57 lulin Exp $

// $Log: TreeAttributeSelect_Form.pas,v $
// Revision 1.39  2013/04/24 09:35:57  lulin
// - портируем.
//
// Revision 1.38  2013/04/09 16:56:26  kostitsin
// [$120723452]
//
// Revision 1.37  2013/01/22 15:59:05  kostitsin
// [$424399029]
//
// Revision 1.36  2012/09/29 10:31:25  lulin
// {RequestLink:397279284}
//
// Revision 1.35  2012/04/13 19:01:01  lulin
// {RequestLink:237994598}
//
// Revision 1.34  2012/04/13 18:23:59  lulin
// {RequestLink:237994598}
//
// Revision 1.33  2011/11/16 17:35:53  lulin
// {RequestLink:232098711}
//
// Revision 1.32  2011/09/16 18:15:05  lulin
// {RequestLink:278824896}.
//
// Revision 1.31  2011/05/13 11:57:33  lulin
// - чистка комментариев.
//
// Revision 1.30  2010/11/01 17:20:13  lulin
// {RequestLink:237994238}.
// - передаём ссылку на "модель".
// - делаем, чтобы собирались другие проекты.
//
// Revision 1.29  2010/11/01 16:16:03  lulin
// {RequestLink:237994238}.
// - настраиваем вычитанные атрибуты.
//
// Revision 1.28  2010/08/31 19:39:31  lulin
// {RequestLink:197496539}.
//
// Revision 1.27  2010/07/19 12:57:33  lulin
// {RequestLink:197496539}.
//
// Revision 1.26  2010/07/19 12:22:17  lulin
// {RequestLink:197496539}.
//
// Revision 1.25  2010/07/19 11:59:20  lulin
// {RequestLink:197496539}.
//
// Revision 1.24  2010/06/30 10:58:12  lulin
// {RequestLink:207389954}.
// - переводим на модель форму "Выбор атрибута".
//
// Revision 1.23  2010/04/27 15:24:47  lulin
// {RequestLink:159352361}.
// - перестаём генерировать пользовательские типы из StdRes.
//
// Revision 1.22  2010/03/18 10:20:33  oman
// - fix: {RequestLink:197496009}
//
// Revision 1.21  2010/01/21 14:30:24  lulin
// {RequestLink:179078019}. Отдельно выделяем документ для возврата.
//
// Revision 1.20  2009/12/03 14:33:31  lulin
// {RequestLink:172986031}.
//
// Revision 1.19  2009/12/02 17:22:01  lulin
// {RequestLink:172984885}.
//
// Revision 1.18  2009/11/18 14:46:57  lulin
// - чистка кода.
//
// Revision 1.17  2009/11/18 13:06:29  lulin
// - используем базовые параметры операции.
//
// Revision 1.16  2009/11/16 18:41:04  lulin
// {ReqestLink:159360578}. №58.
//
// Revision 1.15  2009/11/16 16:34:29  lulin
// {ReqestLink:159360578}. №58.
//
// Revision 1.14  2009/11/16 11:44:22  lulin
// {RequestLink:159360578}. №58.
//
// Revision 1.13  2009/11/12 14:33:01  lulin
// - убираем возможность менять список параметров.
//
// Revision 1.12  2009/11/11 18:53:06  lulin
// - убираем генерацию идентификаторов операций.
//
// Revision 1.11  2009/11/10 12:29:43  lulin
// - перестаём выливать идентификаторы внутренних операций.
//
// Revision 1.10  2009/11/06 13:06:50  lulin
// - избавился от ручной передачи параметров через поле Data.
//
// Revision 1.9  2009/11/05 18:30:44  lulin
// - избавился от переменных списков параметров.
//
// Revision 1.8  2009/11/05 15:00:15  lulin
// - закончены разборки с параметрами внутренних операций.
//
// Revision 1.7  2009/10/30 17:11:28  lulin
// - третья волна компании по борьбе со старыми внутренними операциями.
//
// Revision 1.6  2009/10/29 14:35:59  lulin
// - вторая волна компании по борьбе со старыми внутренними операциями.
//
// Revision 1.5  2009/10/28 14:10:46  lulin
// - начинаем компанию по борьбе со старыми внутренними операциями.
//
// Revision 1.4  2009/10/26 14:12:02  oman
// - fix: {RequestLink:124944765}
//
// Revision 1.3  2009/10/23 12:00:22  oman
// - fix: {RequestLink:121160631}
//
// Revision 1.2  2009/10/12 11:27:47  lulin
// - коммитим после падения CVS.
//
// Revision 1.3  2009/10/08 15:25:52  lulin
// {RequestLink:164599032}.
//
// Revision 1.2  2009/10/08 14:31:21  lulin
// - подготавливаемся к фильтрации источников опубликования.
//
// Revision 1.327  2009/10/01 19:12:01  lulin
// - параметризуем фабрики конечных форм приложения.
//
// Revision 1.326  2009/09/30 15:23:12  lulin
// - убираем ненужное приведение ко вполне понятным интерфейсам.
//
// Revision 1.325  2009/09/30 13:43:27  lulin
// - избавляемся от лишнего запроса интерфейса.
//
// Revision 1.324  2009/09/15 10:09:09  lulin
// - избавляемся от операций модуля и ссылок на класс форм.
//
// Revision 1.323  2009/09/03 18:49:13  lulin
// - реструктуризируем поиски и удаляем ненужное.
//
// Revision 1.322  2009/09/02 11:49:20  lulin
// {RequestLink:159360578}. №20.
//
// Revision 1.321  2009/08/26 08:15:25  lulin
// - декорируем имена операций, чтобы можно было искать.
// - bug fix: не собирались мониторинги.
//
// Revision 1.320  2009/08/14 11:14:38  oman
// - fix:  {RequestLink:159356254}
//
// Revision 1.319  2009/07/31 17:30:07  lulin
// - убираем мусор.
//
// Revision 1.318  2009/06/01 08:17:34  oman
// - fix: При убиении не дергаемся - [$148573715]
//
// Revision 1.317  2009/05/13 11:25:06  oman
// - fix: Залечиваем - [$146906200]
//
// Revision 1.316  2009/02/10 19:04:03  lulin
// - <K>: 133891247. Вычищаем морально устаревший модуль.
//
// Revision 1.315  2009/02/10 15:43:43  lulin
// - <K>: 133891247. Выделяем интерфейсы локализации.
//
// Revision 1.314  2009/02/09 19:17:30  lulin
// - <K>: 133891247. Выделяем интерфейсы поиска.
//
// Revision 1.313  2009/02/09 11:57:18  lulin
// - <K>: 133891247.
//
// Revision 1.312  2009/01/30 07:59:26  lulin
// - <K>: 122674504.
//
// Revision 1.311  2009/01/27 09:20:28  lulin
// - <K>: 135607658.
//
// Revision 1.310  2009/01/22 11:48:05  lulin
// - <K>: 128288557. Чистим код.
//
// Revision 1.309  2009/01/21 19:18:27  lulin
// - <K>: 135602528.
//
// Revision 1.308  2009/01/19 13:12:48  lulin
// - <K>: 134316707.
//
// Revision 1.307  2008/12/25 12:20:19  lulin
// - <K>: 121153186.
//
// Revision 1.306  2008/12/24 19:49:52  lulin
// - <K>: 121153186.
//
// Revision 1.305  2008/12/19 12:41:52  lulin
// - <K>: 128288713. Подкладываем под форму контроллер области ввода.
//
// Revision 1.304  2008/12/16 08:07:37  oman
// - fix: Рассинхронизация _DS и данных на форме (К-131137626)
//
// Revision 1.303  2008/12/08 09:33:27  lulin
// - <K>: 128292941.
//
// Revision 1.302  2008/11/26 16:00:47  lulin
// - <K>: 123961927.
//
// Revision 1.301  2008/11/19 16:54:58  lulin
// - <K>: 124453996.
//
// Revision 1.300  2008/10/30 16:56:49  lulin
// - <K>: 121167304.
//
// Revision 1.299  2008/10/30 16:50:26  lulin
// - <K>: 121167304.
//
// Revision 1.298  2008/10/29 12:04:30  lulin
// - <K>: 121166314.
//
// Revision 1.297  2008/10/24 14:56:39  lulin
// - чистка кода.
//
// Revision 1.296  2008/09/09 09:16:17  oman
// - fix: Забыли обратную нотификацию (К-112722961)
//
// Revision 1.295  2008/09/08 11:00:01  oman
// - fix: При загрузке запросов всегда приводим дерево ППС в нулевое положение (К-112722961)
//
// Revision 1.294  2008/07/22 10:42:32  oman
// - new: Отключение пищалки - везде кроме КЗ (К-103940886)
//
// Revision 1.293  2008/07/01 12:47:57  oman
// - new: При вставке из клипборда перефильтровываем дерево посимвольно (К-96474339)
//
// Revision 1.292  2008/06/26 11:18:57  oman
// - fix: Боремся с перетрансляцией ввода (cq11768)
//
// Revision 1.291  2008/06/26 10:50:07  oman
// - fix: Боремся с перетрансляцией ввода (cq11768)
//
// Revision 1.290  2008/04/14 07:32:37  oman
// - fix: Запрещаем операцию (cq28851)
//
// Revision 1.289  2008/01/30 08:24:56  mmorozov
// - new: отложенное обновление представлений при перемещении по деревьям ППС 6.х (CQ: OIT5-28303);
//
// Revision 1.288  2008/01/24 12:38:17  oman
// - fix: Лишний пункт в меню (cq28237)
//
// Revision 1.287  2008/01/16 08:00:36  mmorozov
// - new behaviour: при щелчке на узле мышью переключаем только первую доступную операцию, а не все достпуные (CQ: OIT5-6160);
//
// Revision 1.286  2008/01/10 07:23:08  oman
// Переход на новый адаптер
//
// Revision 1.285  2007/12/26 07:57:50  mmorozov
// - new: данные дерева уведомляют слушателей о своём обновлении + подписываем тех, кому это интересно (в рамках CQ: OIT5-27823);
//
// Revision 1.284  2007/12/25 11:32:05  mmorozov
// - new: подписка на обновление данных приложения (CQ: OIT5-27823);
//
// Revision 1.283  2007/12/21 07:12:12  mmorozov
// - new: подписка на уведомление об обновлении данных (CQ: OIT5-27823);
//
// Revision 1.282  2007/11/15 12:05:52  mmorozov
// - в рамках работы над "Не смещались к выбранному в дереве" (CQ: OIT5-19586);
//
// Revision 1.281  2007/11/12 12:28:30  mmorozov
// - method was renamed;
//
// Revision 1.280  2007/10/17 11:12:54  oman
// - fix: Более правильно публикуем операции (cq27106)
//
// Revision 1.279  2007/10/09 11:21:50  mmorozov
// - new: в заголовке форме выбора реквизита показываем название реквизита (CQ: OIT5-26918) + сопутствующий рефакторинг;
//
// Revision 1.278  2007/09/10 09:44:13  oman
// - fix: Привызал операцию к контролу (cq26589)
//
// Revision 1.277  2007/08/14 14:29:57  lulin
// - оптимизируем перемещение блоков памяти.
//
// Revision 1.276  2007/07/13 13:55:00  oman
// - fix: Убираем операцию "Свернуть все"/"Развернуть все" (cq25605)
//
// Revision 1.275  2007/07/13 12:32:52  oman
// - fix: Убираем операцию "Свернуть все"/"Развернуть все" (cq25605)
//
// Revision 1.274  2007/05/17 12:40:12  lulin
// - удаляем контекст из комментариев.
//
// Revision 1.273  2007/04/05 12:10:11  lulin
// - убран метод добавления стандартной строки - дабы не было соблазна для преобразований туда-сюда.
//
// Revision 1.272  2007/04/05 10:36:05  lulin
// - cleanup.
//
// Revision 1.271  2007/04/05 10:22:41  lulin
// - избавляемся от лишних преобразований строк.
//
// Revision 1.270  2007/04/02 07:41:19  oman
// - fix: Вернул обратно ResetData
// - fix: Нотифицируем контейнер о выключении контекстного фильтра
//
// Revision 1.269  2007/03/30 08:26:37  oman
// - fix: Пытаемся бороться с переключением баз/историей и
//  выключением контекстного фильтра (cq24456)
//
// Revision 1.268  2007/03/29 13:18:58  oman
// Вычитываем таки параметры контекстного фильтра для атрибутов
//
// Revision 1.267  2007/03/29 09:31:46  oman
// - new: Контекстная фильтрация атрибутов - первое приближение
//  (cq24456)
//
// Revision 1.266  2007/03/28 14:51:20  oman
// - new: Избавляемся от ContextParams в КЗ (cq24456)
//
// Revision 1.265  2007/03/28 11:16:33  oman
// Избавляемся от нетипизированных параметров операции
//
// Revision 1.264  2007/03/28 10:13:38  oman
// Избавляемся от нетипизированных параметров операции
//
// Revision 1.263  2007/03/27 11:59:11  oman
// Избавляемся от нетипизированных параметров операции
// Переводим тэг атрибутов на константную строку
//
// Revision 1.262  2007/03/20 08:19:37  lulin
// - не теряем кодировку при присваивании заголовков форм.
//
// Revision 1.261  2007/03/16 07:48:23  oman
// - new: Положили новый контекстный фильтр (cq24456)
//
// Revision 1.260  2007/02/21 13:36:23  oman
// cleanup
//
// Revision 1.259  2007/02/21 13:28:53  oman
// cleanup (дублирующий код)
//
// Revision 1.258  2007/02/12 18:45:01  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.257  2007/02/12 16:39:14  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.256  2007/02/10 13:26:02  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.255  2007/02/07 17:48:54  lulin
// - избавляемся от копирования строк при чтении из настроек.
//
// Revision 1.254  2007/02/06 11:18:53  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.253  2007/02/02 13:23:58  lulin
// - упрощаем преобразование строк.
//
// Revision 1.252  2007/02/02 12:25:44  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.251  2007/02/02 08:39:24  lulin
// - переводим на строки с кодировкой.
//
// Revision 1.250  2007/01/24 13:43:54  mmorozov
// - MERGE WITH B_NEMESIS_6_4;
//
// Revision 1.238.4.2  2007/01/24 13:32:16  mmorozov
// - bugfix: не делаем лишнего при загрузке из истории (CQ: OIT5-24079);
//
// Revision 1.238.4.1  2007/01/24 10:15:00  mmorozov
// - bugfix: при последовательном открытии формы и возврате по истории не писали данные формы в историю (CQ: OIT5-24079);
//
// Revision 1.249  2007/01/20 15:30:33  lulin
// - разделяем параметры операции для выполнения и для тестирования.
//
// Revision 1.248  2007/01/17 18:47:47  lulin
// - сужаем список параметров для тестирования операции.
//
// Revision 1.247  2007/01/17 14:03:08  lulin
// - вычищены последние нефиксированные параметры в тестах операций.
//
// Revision 1.246  2007/01/12 14:30:27  oman
// - fix: Убил операции "Свернуть" и "Развернуть" для деревьев (cq24116)
//
// Revision 1.245  2007/01/11 14:07:00  lulin
// - интерфейс шрифта переехал в базовый модуль.
//
// Revision 1.244  2006/12/22 15:06:39  lulin
// - текст ноды - теперь структура с длиной и кодовой страницей.
//
// Revision 1.243  2006/12/20 13:34:22  lulin
// - удален ненужный модуль.
//
// Revision 1.242  2006/12/15 15:28:57  mmorozov
// - new: иконки выбора реквизитов (CQ: OIT5-23317);
//
// Revision 1.241  2006/12/07 08:32:16  lulin
// - cleanup.
//
// Revision 1.240  2006/12/05 14:16:03  lulin
// - контрол переехал в визуальную библиотеку.
//
// Revision 1.239  2006/12/05 13:50:03  lulin
// - контрол переехал в визуальную библиотеку.
//
// Revision 1.238  2006/10/05 15:18:05  mmorozov
// - new behaviour: для eeTreeViewExport и его наследников вызываем OnCurrentChanged в случае если NewCurrent = -1 (CQ: OIT500017819);
//
// Revision 1.237  2006/09/13 14:20:11  oman
// - fix: При начале поиска в ППС и ППП, если ничего не выбрано -
//  выбираем текущий узел (cq22566)
//
// Revision 1.236  2006/09/13 09:46:21  oman
// - new beh: Поддержка свернуть/развернуть для новых деревьях -
//  убираение устаревших операций/интерфейсов(InsExpandedState)
//  /классов (cq22540)
//
// Revision 1.235  2006/08/03 06:35:06  mmorozov
// - change: _Caption -> _DisplayName (_IvcmFormDataSource);
//
// Revision 1.234  2006/04/21 10:16:31  mmorozov
// - new: идентификаторы тегов запроса;
//
// Revision 1.233  2006/04/19 13:59:34  oman
// - new beh: перекладываем StdStr в _StdRes
//
// Revision 1.232  2006/04/12 13:15:06  oman
// - change: перевод механизма локализации строк на использование фабрик
// - new beh: Локализация nsc
//
// Revision 1.231  2006/04/11 12:07:01  mmorozov
// - получение первого выбранного перенесено в nsUtils;
//
// Revision 1.230  2006/04/06 11:24:14  oman
// - new beh: Перевод на механизм мап "строка для отображения в UI"-<нечто>.
//
// Revision 1.229  2006/03/31 07:42:33  lulin
// - изменен тип параметров, подаваемый в Execte операции.
//
// Revision 1.228  2006/03/30 15:31:43  lulin
// - изменен тип параметров в _OnTest.
//
// Revision 1.227  2006/03/30 14:01:57  lulin
// - операция инициализации разделена на две - с параметрами и без - для того, чтобы в итоге избавится от первой.
//
// Revision 1.226  2006/03/22 07:29:36  oman
// - new beh: переход с _OnTest на _OnGetState для операций
//
// Revision 1.225  2006/03/21 15:03:56  oman
// - new beh: Перекладываем все текстовые константы в три места (StdStr, DebugStr и SystemStr)
//
// Revision 1.224  2006/03/16 15:07:44  mmorozov
// - new: редактироавние фильтров родственными карточками (cq: 18871);
//
// Revision 1.223  2006/02/26 11:22:28  mmorozov
// - new behaviour: принудительно перирисовываем дерево, для случая когда пользователь бежит по дереву удерживая стрелку вниз\вверх (CQ: 16651);
//
// Revision 1.222  2006/02/16 12:52:00  mmorozov
// - bugfix: после обновления при сбросе дерева не выключался контекстный фильтр (CQ: 17586) + интерфейс InscContextParams переехал в правильное место;
//
// Revision 1.221  2006/02/10 14:51:18  mmorozov
// - change: vcm_opVisible -> vcm_opEnabled;
//
// Revision 1.220  2006/01/25 07:53:49  mmorozov
// - warning, hint fix;
//
// Revision 1.219  2005/12/02 15:24:22  oman
// - fix: При смене конфигурации не обновлялись параметры контекстного поиска
//
// Revision 1.218  2005/11/30 12:20:57  oman
// - fix: при хождении по истории ChangeDataSource сбрасывал фильтры
//
// Revision 1.217  2005/11/21 17:32:06  lulin
// - cleanup.
//
// Revision 1.216  2005/11/18 13:54:55  mmorozov
// bugfix: текущий сбивался при наложении, сбрасывании контекстной фильтрации в 5.х для первого уровня (cq: 00018086);
//
// Revision 1.215  2005/11/17 10:22:40  mmorozov
// cleanup: удален паразитный код, который приводил при применении контекстного фильтра к установке текущего первым, хотя узел до и после фильтрации в дереве был;
//
// Revision 1.214  2005/11/14 12:07:24  mmorozov
// bugfix: не правильное позиционирование по выбранным реквизитам, по причине разворачивание узлов дерева FirstLevel, в следствии позиционирования в дереве OneLevel;
//
// Revision 1.213  2005/11/04 10:49:32  mmorozov
// bugfix: при открытии запроса в ППС 6.х не показывались выбранные атрибуты;
//
// Revision 1.212  2005/11/01 13:42:19  mmorozov
// bugfix: AV при освобождении всплыващего меню;
//
// Revision 1.211  2005/10/24 10:53:48  mmorozov
// - change comment;
//
// Revision 1.210  2005/10/24 10:44:44  mmorozov
// bugfix: не открывались сохраненные запросы;
//
// Revision 1.209  2005/10/21 12:35:40  mmorozov
// new: в ППС 5.х появились логические операции в контекстном меню;
//
// Revision 1.208  2005/10/17 13:47:15  mmorozov
// new behaviour: адаптация формы для случаев. когда она не входит в сборку;
//
// Revision 1.207  2005/10/14 18:09:02  demon
// - fix: AV при попытке выделить вложенный элемент
//
// Revision 1.206  2005/10/14 10:56:48  mmorozov
// - добавлен модуль;
//
// Revision 1.205  2005/09/28 18:15:17  mmorozov
// new: в событии ChangedDataSource появился параметр aFromHistory;
//
// Revision 1.204  2005/08/30 08:05:40  demon
// - fix: неверное позиционирование в ППС 5.х при фильтрации
//
// Revision 1.203  2005/08/05 07:17:30  mmorozov
// change: сигнатура TvcmChangedDataSourceEvent;
//
// Revision 1.202  2005/08/04 13:47:42  mmorozov
// new behaviour: после получения SimpleTree из источника данных разворачиваем первый узел;
// new: источиник данных содержит доступные операции;
//
// Revision 1.201  2005/08/04 09:08:44  mmorozov
// change: переименовано поле источника данных (_CoDataSource от английского "concrete");
//
// Revision 1.200  2005/08/03 14:39:44  mmorozov
// new: использование _caption-на источника данных;
//
// Revision 1.199  2005/08/03 13:52:56  mmorozov
// change:  использование SimpleTree источника данных;
//
// Revision 1.198  2005/08/02 12:35:11  mmorozov
// - _format code;
// new: данные инициализации форма получает из _DataSource (_IvcmFormDataSource);
//
// Revision 1.197  2005/07/22 08:43:40  mmorozov
// - переезд на новый запрос;
//
// Revision 1.196  2005/06/30 07:48:26  cyberz
// READY FOR TIE-TEMPLATE GENERATION
//
// Revision 1.195  2005/05/27 14:46:45  lulin
// - базовый контрол переехал в быблиотеку L3.
//
// Revision 1.194  2005/04/07 10:51:51  mmorozov
// bugfix: при изменении контекстных параметров фильтр в дереве не синхронизировался;
//
// Revision 1.193  2005/04/06 13:10:37  mmorozov
// bugfix: параметры контексной фильтрации не синхронизировались ППС 6.х;
//
// Revision 1.192  2005/04/05 07:24:42  mmorozov
// bugfix: в ППС 5.х при фильтрации в одном дереве не происходила синхронизации строки поиска с другим деревом (InsTreeFilterInfo);
//
// Revision 1.191  2005/03/31 09:45:03  am
// change: вернули для выбора реквизита в ППР старое поведение, т.е.: по Enter'у в пустом дереве выбираем текущий элемент, по нажатию мышью OK - ничего не делаем (CQ: 13092)
//
// Revision 1.190  2005/03/31 09:21:18  demon
// - new behavior: Double-click по папке не выделяет ее логической операцией, а сворачивает/разворачивает
//
// Revision 1.189  2005/03/24 16:00:09  mmorozov
// new: при открытии формы не показывалось усеченное дерево, если оно должно было быть таковым;
//
// Revision 1.188  2005/03/23 14:40:39  am
// change: выделил код в CurrentChangedPrim
// change: при попытке спозиционироваться на ту же самую ноду, где стоим, скроллимся к этой ноде
//
// Revision 1.187  2005/03/22 17:11:00  mmorozov
// bugfix: при открытии/закрытии формы с параметрами копировалась строчка фильтрации;
//
// Revision 1.186  2005/03/10 08:51:09  mmorozov
// new behaviour: при подаче параметров контекстной фильтрации для синхронизации копируем их;
//
// Revision 1.185  2005/03/05 11:31:46  am
// change: поменял TeeTreeView на TnscTreeView
//
// Revision 1.184  2005/02/28 09:33:58  demon
// - new behavior: При создании пустого _IQuery на адаптере нужно указывать его тип
// - new behavior: поле _IQuery.Type стало readonly
//
// Revision 1.183  2005/02/18 14:30:13  am
// change: при поиске в ППР\ППО и пустых деревьях выбираем текущий. Раньше только по Enter (а-ля 5.x), теперь всегда.
//
// Revision 1.182  2005/02/11 10:44:33  am
// change: если введён контекстный фильтр, при нажатии Enter в пустом дереве, стоя на узле, у которого есть фильтрованые дети, начинаем поиск по всем неотфильтрованым детям (и только по ним).
//
// Revision 1.181  2005/02/07 18:02:41  demon
// - fix: не правильно работали кнопки логических операций в ППС 5.х
//
// Revision 1.180  2005/01/21 12:27:19  lulin
// - к пользовательским операция приписываем префикс user.
//
// Revision 1.179  2005/01/14 14:39:54  am
// bugfix: поправил несколько багов, появившихся при переходе на новую идеологию фильтрации
//
// Revision 1.178  2005/01/08 12:07:57  mmorozov
// new: синхронизация параметров контекстной фильтрации с настройками;
//
// Revision 1.177  2004/12/23 11:15:19  lulin
// - rename prop: TvtCustomOutliner.TreeSource -> TreeStruct.
//
// Revision 1.176  2004/12/22 10:36:29  mmorozov
// new: op_ContextParams_SyncContextParams для синхронизации параметров контекстной фильтрации в ППР;
//
// Revision 1.175  2004/12/21 15:48:48  mmorozov
// remove: лишние операции;
//
// Revision 1.174  2004/12/21 11:48:35  mmorozov
// new: использование компонента TnscContextParams;
// new: для обмена информацией с cfSaveLoad используем Il3ContextParams;
// remove: вычещены лишние операции;
//
// Revision 1.173  2004/12/17 14:37:22  mmorozov
// new: на форме размещен компонент nscContextParams;
//
// Revision 1.172  2004/12/16 08:21:37  mmorozov
// new: операции для задания параметров контекстной фильтрации и контекстная фильтрация по новому;
//
// Revision 1.171  2004/11/29 16:38:04  lulin
// - переходим от TFont к Il3Font - для более корректной обработки цветов.
//
// Revision 1.170  2004/11/18 16:30:48  lulin
// - отвязываем библиотеки от VCM без использования inc'ов.
//
// Revision 1.169  2004/11/15 12:29:22  mmorozov
// change: вместо проверок в коде используем _ExcludeUserTypes;
//
// Revision 1.168  2004/10/21 17:19:00  am
// change: перетащил IsExists_PublishSourceTag, IsExists_KeyWordTag из moSearch на DataAdapter, чтобы иметь возможность сбрасывать их во время обновления.
//
// Revision 1.167  2004/10/21 15:42:02  am
// change: включил возможность фильтрации в форме ситуаций второго уровня
//
// Revision 1.166  2004/10/14 06:21:11  am
// change: возможность фильтровать в дереве ситуаций первого уровня
//
// Revision 1.165  2004/10/11 15:22:37  demon
// - new behavior: Отработка shortcut'ов Del и Ins при множественном выделении.
//
// Revision 1.164  2004/10/11 08:38:05  mmorozov
// change: rename const;
//
// Revision 1.163  2004/10/08 17:33:13  demon
// - fix: все логические операции недоступны для папок с фильтрованными элементами.
//
// Revision 1.162  2004/10/04 12:05:21  am
// new op: AttributeTree_IsQueryEmpty
//
// Revision 1.161  2004/10/01 16:50:33  cyberz
// 1) рисуем филтрованные ноды по другому
// 2) запрещаем выбор ЛОГ условия на филтрованной ноде
// 3) делаем доступной операцию "очистить" всегда
//
// Revision 1.160  2004/09/23 11:15:45  demon
// - refactoring: выделена общая операция IsSameContextFilter
//
// Revision 1.159  2004/09/22 14:14:08  demon
// - new behavior: nsTreeFilterHandler из процедуры стал функцией
//
// Revision 1.158  2004/09/19 11:22:13  am
// change: при изменении шрифта сохраняем его цвет
//
// Revision 1.157  2004/09/19 09:56:04  am
// change: восстановил старую логику показа выбранных реквизитов
//
// Revision 1.156  2004/09/16 14:31:21  demon
// - new behavior: изменил хинты к операциям с вкладками.
//
// Revision 1.155  2004/09/13 12:42:00  am
// change: вычистил vcmComponent
//
// Revision 1.154  2004/09/13 11:30:18  am
// change: независимо от включенности контекстной фильтрации начинаем фильтровать при вводе символа в поле и снимаем фильтрацию при вводе пустой строки
//
// Revision 1.153  2004/09/13 10:33:38  demon
// - new _uses
//
// Revision 1.152  2004/09/10 15:41:35  am
// new: nsAdjustSettings - изменение строки фильтра на основе настроек
//
// Revision 1.151  2004/09/10 11:30:42  am
// bugfix: _AttributeTreeNewCharPressed
//
// Revision 1.150  2004/09/06 12:46:57  am
// change: вынес функциональность в nsTreeFilterHandler
//
// Revision 1.149  2004/09/06 09:34:29  am
// change: избавляемся от CreateViewEx
//
// Revision 1.148  2004/09/04 13:37:52  am
// change: перевод на одноуровненвые деревья
//
// Revision 1.147  2004/09/02 13:35:36  am
// bugfix: AV при пустом фильтре
//
// Revision 1.146  2004/08/31 12:03:41  am
// bugfix: enAttributeTreeopExpandCollapseAllExecute
//
// Revision 1.145  2004/08/27 11:21:53  mmorozov
// change: li_Search_ContextFilterType0 -> li_Search_cftAtBegining;
// change: li_Search_ContextFilterType1 -> li_Search_cftAnyPosition;
//
// Revision 1.144  2004/08/26 13:21:32  demon
// - new behavior: Ins убрана с операции ИЛИ и создана новая операция, которая - выделяет элемент по ИЛИ, если он до этого не был отмечен другой логической операцией и смещается к следующему.
//
// Revision 1.143  2004/08/19 12:28:57  demon
// - cleanup: удалены неиспользуемые иконки выбора словарных атрибутов
//
// Revision 1.142  2004/08/13 11:55:47  am
// change: при поиске в номерах ищем всегда с начала, независимо от настроек
//
// Revision 1.141  2004/08/09 12:46:34  mmorozov
// bugfix: дереву нельзя обрабатывать только ccActionItem (IsCommandProcessed);
//
// Revision 1.140  2004/08/09 06:50:41  mmorozov
// bugfix: в методе _SaveToQuery получаемый у TreeSource интерфейс InsTaggedTreeInfo мог быть пустым;
//
// Revision 1.139  2004/08/06 13:53:50  mmorozov
// new: по нажатию на Enter включается/отключается контекстный фильтр;
// new: обработчик IsCommandProcessed для того чтобы операции Ok приходил Enter;
//
// Revision 1.138  2004/08/06 11:04:38  demon
// - cleanup: remove warnings and hints
//
// Revision 1.137  2004/07/30 10:25:32  am
// change: GetFirstLevelParent - переделал логику. В качестве FirstLevelParent используется нода с GetLevel = 1
//
// Revision 1.136  2004/07/29 12:51:01  demon
// - new behavior: вызываем фильтрацию, только если контектсная строчка действительно изменилась
//
// Revision 1.135  2004/07/28 10:02:06  am
// change: Выставление EditOptions\ViewOptions в ППС5.x
//
// Revision 1.134  2004/07/28 08:16:51  am
// change: пользуем флаги из GBLAdapter
// change: при фильтрации не раскрываем ноды в ситуациях первого уровня
//
// Revision 1.133  2004/07/23 16:26:56  mmorozov
// new: операция enResultopOk (выбираем текущий, если ни один не выбран);
//
// Revision 1.132  2004/07/21 07:31:44  nikitin75
// fix: в условии потеряли not
//
// Revision 1.131  2004/07/19 12:34:26  am
// new: в ППР\ППС: если ни один элемент не выбран, автоматом подставляем текущий
//
// Revision 1.130  2004/07/19 08:47:17  demon
// - new behavior: операция Delete из меню "Правка" стала снимать выделение с текущего элемента (пока доступна только через Shortcut).
//
// Revision 1.129  2004/07/16 14:29:09  demon
// - new behavior: при вводе контекста не находящегося в дереве - остается последнее фильтрованное состояние, а контекст красится красным цветом.
//
// Revision 1.128  2004/07/15 13:22:35  demon
// - new behavior: вместо быстрого поиска в деревьях атрибутов автоматически включается контекстный фильтр.
//
// Revision 1.127  2004/07/15 12:19:27  am
// change: поменялась логика работы лог. операций
//
// Revision 1.126  2004/07/14 12:44:35  am
// bugfix: в _OnTest'е для лог. операций в случае пустого дерева кнопки лог. операций прятались. Отвертел, теперь дизейблятся
//
// Revision 1.125  2004/07/07 07:50:16  am
// change: Cleanup
//
// Revision 1.124  2004/07/05 12:37:29  demon
// - new behavior: Отключена операция Свернуть/Развернуть все для деревьев атрибутов (временно).
//
// Revision 1.123  2004/07/05 08:04:35  am
// bugfix: opDefaultAction
//
// Revision 1.122  2004/07/01 15:56:44  demon
// - new behavior: изменен формат вызова операции ResetData(const aTreeSource : Il3SimpleTree)
//
// Revision 1.121  2004/07/01 07:52:50  demon
// - fix: не раскрывалась верхняя нода в поиске по ситуации
//
// Revision 1.120  2004/07/01 07:16:10  demon
// - fix: позиционирование в дереве при установке Current извне
//
// Revision 1.119  2004/06/28 12:59:56  am
// change: мелкие правки
//
// Revision 1.118  2004/06/28 06:28:39  am
// change: мелкие правки
//
// Revision 1.117  2004/06/25 12:54:32  am
// bugfixes
//
// Revision 1.116  2004/06/25 09:19:03  am
// change: новые деревья
//
// Revision 1.115  2004/06/23 14:12:11  am
// bugfix:
//
// Revision 1.114  2004/06/23 13:43:14  am
// change: мелкие правки
//
// Revision 1.113  2004/06/23 11:53:35  am
// bugfix: SetQuery
//
// Revision 1.112  2004/06/23 09:20:35  mmorozov
// change: _GetTwinNode перенесена в модуль nsTreeUtils;
//
// Revision 1.111  2004/06/23 09:04:59  am
// change: мелкие правки
//
// Revision 1.110  2004/06/23 07:20:49  am
// багфиксы
//
// Revision 1.109  2004/06/23 06:29:04  am
// bugfix: убрал доп. параметр в _CreateView
//
// Revision 1.108  2004/06/22 17:46:28  am
// changes
//
// Revision 1.107  2004/06/22 15:49:31  mmorozov
// new: opSaveDictItems;
//
// Revision 1.106  2004/06/22 11:20:52  am
// change: LoadFromQuery\_SaveToQuery
//
// Revision 1.105  2004/06/21 15:24:48  am
// change: перевод на TeeTreeView
//
// Revision 1.104  2004/06/21 06:25:03  am
// change: обновлении выбранных при открытии
//
// Revision 1.103  2004/06/17 14:46:59  am
// no message
//
// Revision 1.102  2004/06/17 11:31:34  am
// change: следующая итерация
//
// Revision 1.101  2004/06/17 10:04:55  am
// change: следующая итерация
//
// Revision 1.100  2004/06/16 10:36:00  am
// change: перевод на новые деревья (формы разломаны по части функционала)
//
// Revision 1.99  2004/06/15 14:57:57  mmorozov
// - замена TLogicSelection на TLogicOperation;
//
// Revision 1.98  2004/06/01 08:25:55  demon
// - new behavior: изменена иерархия наследования деревьев и часть модулей переехали в VT
//
// Revision 1.97  2004/05/26 16:59:53  law
// - new behavior: TvtCustomOutliner теперь знает только про интерфейсы Il3SimpleTree и Il3Tree, а не про объект _Tl3Tree.
//
// Revision 1.96  2004/05/26 14:24:06  law
// - change: скрестил "ежа с ужом" (старые деревья с новыми).
//
// Revision 1.95  2004/05/24 12:42:17  demon
// - fix: можно было поставить ссылку при множественном выделении нескольких параграфов текста.
//
// Revision 1.94  2004/05/13 12:01:26  demon
// - new behavior: при загрузке значений из КЗ итерируем только по проргруженной части дерева
//
// Revision 1.93  2004/04/08 18:32:35  law
// - refactoring: используем CurrentNode.
//
// Revision 1.92  2004/04/08 17:56:55  law
// - bug fix: AV когда aNode = nil.
//
// Revision 1.91  2004/04/06 09:43:06  nikitin75
// - переходим на IStringOld;
//
// Revision 1.90  2004/04/05 13:54:13  nikitin75
// - переходим на IStringOld;
//
// Revision 1.89  2004/03/22 14:27:13  demon
// - _move: FindQueryTagNode перемещены в nsQueryUtils
//
// Revision 1.88  2004/03/16 14:13:13  demon
// - cleanup: убрано лишнее кэширование Root на форме (было нужно для правильной работы _SaveState)
//
// Revision 1.87  2004/03/12 13:36:44  demon
// - fix: new _caption & hint to SetContextFilter _operation
//
// Revision 1.86  2004/03/09 14:01:51  demon
// - fix: Invalidate вместо InvalidateItem
// - fix: сохранение параметров в историю (для кэшированных атрибутов)
//
// Revision 1.85  2004/03/09 10:58:13  demon
// - optimization: вызовы Changing-Changed заменены на Invalidate (это позволило не пересчитывать CountView когда не требуется).
//
// Revision 1.84  2004/03/09 09:07:50  mmorozov
// - константы из модуля nsTypes перенесены в модуль nsConst;
//
// Revision 1.83  2004/03/04 16:37:42  law
// - rename unit: VLister -> vtLister.
//
// Revision 1.82  2004/03/04 16:21:59  demon
// - new _operation: op_AttributeTree_RefreshCurrent
//
// Revision 1.81  2004/03/04 15:39:55  law
// - rename unit: VOtliner -> vtOutliner.
//
// Revision 1.80  2004/03/03 18:05:13  law
// - rename unit: l3Tree2 -> l3Tree.
//
// Revision 1.79  2004/03/03 10:19:46  nikitin75
// + выбор атрибута "по пробелу";
//
// Revision 1.78  2004/03/03 08:55:29  demon
// - new behavior: при сохранеии в историю и загрузке из нее - мы сохраняем и восстанавливаем состояние дерева через Query
//
// Revision 1.77  2004/02/27 14:12:45  demon
// - new: используем ResetData(aTreeSource : _Tl3Tree);
//
// Revision 1.76  2004/02/27 12:15:07  demon
// - new: обработка операции op_System_UpdateComplete
//
// Revision 1.75  2004/02/27 09:29:10  demon
// - new behavior: поддержка операции Reset для сброса состояния деревьев атрибутов в истории
//
// Revision 1.74  2004/02/20 13:24:34  am
// change: убраны группы из настроек.
//
// Revision 1.73  2004/01/30 17:35:50  migel
// - change: грузим таблицу стилей из настроек.
// - change: изменили таблицу настроек по умолчанию.
//
// Revision 1.72  2004/01/22 16:42:35  law
// - change: подстраиваемся под изменения Вована:
// "new behavior: заменил события onChanging, onChanged на регистрацию рассылки соообщений Il3ChangeRecipient".
//
// Revision 1.71  2004/01/12 12:54:24  demon
// - reaname: формы выбора словарных атрибутов
//
// Revision 1.70  2003/12/29 15:12:22  demon
// - new behavior: переделан способ синхронизации между формами отображающей первый уровень дерева и полное дерево (теперь синхронизируемся по IeeNode).
//
// Revision 1.69  2003/12/29 13:46:44  demon
// - new behavior: переделан способ синхронизации между двумя формами отображающими "двухуровневое" дерево (ППС 5.х).
//
// Revision 1.68  2003/12/25 11:11:43  demon
// - fix: при фильтрации в ППС 5.х не правильно выставлялся текущий в первом уровне дерева.
//
// Revision 1.67  2003/12/24 16:48:22  demon
// - new behavior: CurentChanged теперь имеет два параметра
//
// Revision 1.66  2003/12/24 11:27:07  demon
// - new behavior: добавлена очистка правой части в ППС 5.х при полной фильтрации всех элементов словаря.
//
// Revision 1.65  2003/12/23 12:43:19  law
// - добавлены автоматические изменения, внесенный средой Delphi.
//
// Revision 1.64  2003/12/23 11:37:48  demon
// - bug fix: Для формы с фильтрами не верно выводился _Caption.
//
// Revision 1.63  2003/12/19 16:03:18  migel
// - change: переходим на новые настройки (добавлены/используем новые константы и методы).
//
// Revision 1.62  2003/12/17 14:36:07  dk3
// new settings
//
// Revision 1.61  2003/12/10 08:28:43  demon
// - new _uses autogenerated
//
// Revision 1.60  2003/12/04 18:35:29  law
// - change: сделан отложенный подсчет CountView, пока сильно не помогло, но и хуже вроде не стало.
//
// Revision 1.59  2003/11/30 11:41:00  law
// - change: используем автогенерированные типы пользовательских объектов. Почистил nsTypes.
//
// Revision 1.58  2003/11/20 20:40:03  law
// - new behavior: корректно генерируем список идентификаторов операций.
// - new behavior: вызов операций сущностей возможен теперь только по идентификатору.
// - cleanup: пытаемся в Design-Time отвязаться от GblAdapter (не получилось).
//
// Revision 1.57  2003/11/19 11:39:26  law
// - new behavior: регистрируем все сущности и операции в MenuManager'е для дальнейшей централизации редактирования. Само редактирование пока не доделано.
//
// Revision 1.56  2003/11/13 09:19:10  law
// - new behavior: CQ OIT5-00005190.
//
// Revision 1.55  2003/11/06 14:40:21  demon
// - cleanup
//
// Revision 1.54  2003/11/06 13:34:00  demon
// - new: операции получения параметров контекстной фильтрации
//
// Revision 1.53  2003/11/06 13:03:22  demon
// - new behavior: при контекстной фильтрации учитываются настройки
//
// Revision 1.52  2003/11/06 12:05:34  demon
// - new behavior: переделаны операции контекстной фильтрации (под две кнопки + под работу с двухуровневым деревом)
//
// Revision 1.51  2003/11/05 14:53:29  demon
// - new: операция установки контекстного фильтра (пока работает только как индикатор)
//
// Revision 1.50  2003/11/05 13:15:08  demon
// - new: Изменена логика допустимости установки логических операций в папках уже имеющих логическое выделение.
//
// Revision 1.49  2003/10/27 09:35:28  demon
// - new behavior: при контекстной фильтрации происходит смещение на первый найденный.
//
// Revision 1.48  2003/10/27 08:00:19  demon
// - new behavior: операция SetContextFilter в качестве результата стала возвращать первый из подходящих элементов.
//
// Revision 1.47  2003/10/23 11:50:14  demon
// - fix: неверно выводился _caption для поиска по источнику опубликования.
//
// Revision 1.46  2003/10/20 14:39:39  demon
// - fix: проблеммы отрисовки фильтрованного дерева при операции ExpandAll.
//
// Revision 1.45  2003/10/14 15:54:04  demon
// - new: операция "Контекстный фильтр" стала доступна пользователям.
//
// Revision 1.44  2003/10/10 11:25:57  demon
// - syntax fix
//
// Revision 1.43  2003/10/10 10:22:37  demon
// - new: операция контекстной фильтрации дерева (для тестовых целей).
//
// Revision 1.42  2003/10/09 14:51:45  demon
// - new behavior: При показе деревьев словарей AttributeRootNode беруться из закэшированного списка.
//
// Revision 1.41  2003/10/07 14:57:34  demon
// - bug fix: Неправильное название окна.
//
// Revision 1.40  2003/10/07 14:37:10  demon
// - new behavior: using new Attribute tag constants
//
// Revision 1.39  2003/10/07 13:48:59  demon
// - new behavior: в операции enAttributeTree.opDropLogicSelection добавлен дополнительный параметр для сброса выделения со всех детей.
//
// Revision 1.38  2003/10/06 15:50:14  demon
// - new behavior: изменены операции проверки _OnTest для логических операций
//
// Revision 1.37  2003/10/06 08:48:57  demon
// - remove some syntax warnings
//
// Revision 1.36  2003/09/22 07:55:56  demon
// - fix: перешел на использование IeeTreeView.CurrentNode
//
// Revision 1.35  2003/09/18 18:30:18  law
// - bug fix: при отдании TeeTreeView как IeeTreeView отцепляем его "теневой" объект (AV - с открытием в извлечениях).
//
// Revision 1.34  2003/09/08 17:58:37  demon
// - new: при смене Selection учитывается маска доступных логических операций.
//
// Revision 1.33  2003/09/02 10:07:54  demon
// - bug fix: не перерисовывалось дерево атрибутов после загрузки.
//
// Revision 1.32  2003/08/29 09:43:16  demon
// - new: сохранение и загрузка атрибутов из Query.
//
// Revision 1.31  2003/08/22 10:00:18  demon
// - fix: Изменены типы логических операций в адаптере.
//
// Revision 1.30  2003/08/20 11:24:04  demon
// - new behavior: изменено наследование интерфейсов для дополнительной информации о дереве.
//
// Revision 1.29  2003/08/20 08:29:56  demon
// - new: Сохранения параметорв дерева в RootNode и автоматически в истории
//
// Revision 1.28  2003/08/18 11:17:28  demon
// - new: операция загрузки выбранных значений из массива нод.
//
// Revision 1.27  2003/08/08 13:18:06  demon
// - new: Изменен принцип чтения словарного атрибута из Query
//
// Revision 1.26  2003/07/30 15:08:53  demon
// - bug fix: при возвращении из Истории в ППС 5.х снова рисовались плюсики.
//
// Revision 1.25  2003/07/30 14:39:03  demon
// - add: Добавлена операция загрузки выделенных атрибутов из Query.
//
// Revision 1.24  2003/07/29 14:37:15  demon
// - new: Добавлена нотификация для перерисовки зависимой формы при показе дерева в два окна.
//
// Revision 1.23  2003/07/29 12:49:06  demon
// - new: Доделана синхронизация между списком выделенных и деревом (для ППС а-ля 5.х)
//
// Revision 1.22  2003/07/29 08:11:45  demon
// - fix: Разделены операции SetRoot для разных типов форм.
//
// Revision 1.21  2003/07/28 18:00:00  demon
// - add: Переделано взаимодействие между первым и вторым уровнями атрибутов в ППС 5.х
//
// Revision 1.20  2003/07/28 15:30:52  demon
// - new: сделала поддержка работы с userType = _astOnelevel
//
// Revision 1.19  2003/07/28 11:09:35  demon
// - add: добавлена поддержка операции Clear (Очистить все)
//
// Revision 1.18  2003/07/25 17:51:47  demon
// - new: Доделана синхронизация между навигатором (атрибуты первого уровня) и деревом атрибутов в обе стороны.
//
// Revision 1.17  2003/07/25 15:46:22  demon
// - new: добавил в ППС форму отображение первого уровня в навигаторе.
//
// Revision 1.16  2003/07/25 08:32:55  demon
// - fix: Заведена сущность Folder для структуризации операций в контекстном меню
//
// Revision 1.15  2003/07/24 17:10:58  demon
// - new: переделано отображение полного пути в списке выделенных элементов. И сделана функция перейти на первый выделенный.
//
// Revision 1.14  2003/07/24 15:47:42  demon
// - new: Сделаны стандартные операции свернуть/развернуть...
//
// Revision 1.13  2003/07/24 14:23:49  demon
// - new: Сделана синхронизация дерева и списка выделенных при позиционировании в списке выделенных.
//
// Revision 1.12  2003/07/24 13:42:27  demon
// - new: добавлена возможность удаления элементов из списка выбранных значений.
//
// Revision 1.11  2003/07/24 12:47:04  demon
// - new: добавлена возможность установить (и снять) логическую операцию на несколько выделенных элементов.
//
// Revision 1.10  2003/07/24 10:01:44  demon
// - new: добавлена возможность ставить логические операции через команды меню и тулбара
//
// Revision 1.9  2003/07/23 18:59:20  demon
// - new: доделана работа с выделенными (наследование выделения детьми от папок, показ в папках наличия выделенных детей и т.п.)
//
// Revision 1.8  2003/07/23 15:28:14  demon
// - new: при выделении папки - дочерние элементы меняют иконку.
//
// Revision 1.7  2003/07/23 14:39:30  demon
// - new: Заработало выделение элементов при клике на иконку
//
// Revision 1.6  2003/07/23 14:04:03  demon
// - new: работа с выделенными элементами теперь ведется не для Selected. Дерево стало не Picked.
//
// Revision 1.5  2003/07/23 11:25:33  demon
// - fix: Отлажена работоспособность выделения элементов в дереве атрибутов и показа выделенных (есть проблемы с Drag Select).
//
// Revision 1.4  2003/07/22 17:46:26  demon
// - new: доделана поддержка иконок и выделения элементов несколькими логическими операциями.
//
// Revision 1.3  2003/07/22 13:21:10  demon
// - new: в дерево подложены иконки
//
// Revision 1.2  2003/07/22 11:54:40  demon
// - add: добавлена обработка изменения выделенных элементов.
//
// Revision 1.1  2003/07/21 16:35:45  demon
// - new: TefTreeAttributeSelect - форма отображения древовидного поискового атрибута.
//

interface

uses
  Windows,
  Messages,
  SysUtils,
  Classes,
  Graphics,
  Controls,
  Forms,
  Dialogs,

  OvcBase,

  l3Interfaces,
  l3InternalInterfaces,
  l3TreeInterfaces,
  l3Tree,
  l3Tree_TLB,
  l3InterfacedComponent,
  afwControl,
  afwInputControl,

  vtLister,
  vtOutliner,
  vtOutlinerWithQuickSearch,
  vtOutlinerWithDragDrop,

  vcmExternalInterfaces,
  vcmBase,
  vcmBaseEntities,
  vcmEntities,
  vcmEntityForm,
  vcmInterfaces,
  vcmComponent,

  eeInterfaces,
  eeTreeView,
  eeTreeViewExport,

  nscTreeView,

  DynamicTreeUnit,
  SearchUnit,

  ImgList,
  nsConst,
  nsTypes,

  nsLogicOperationToFlags,
  nscContextFilter, vtPanel, afwControlPrim, afwBaseControl,
  afwTextControlPrim, afwTextControl,

  SearchInterfaces,

  bsInterfaces,

  L10nInterfaces,
  SearchDomainInterfaces,

  PrimTreeAttributeSelectOptions_Form
  ;

type
  TefTreeAttributeSelect = class(TvcmEntityFormRef)
    Entities : TvcmEntities;
    BackgroundPanel: TvtPanel;
    ContextFilter: TnscContextFilter;
    AttributeTree: TnscTreeView;

    procedure vcmEntityFormInit;
    procedure enAttributeopLogicOrTest(const aParams: IvcmTestParamsPrim);
    procedure enAttributeopLogicAndTest(const aParams: IvcmTestParamsPrim);
    procedure enAttributeopLogicNotTest(const aParams: IvcmTestParamsPrim);

    procedure enAttributeopLogicOrExecute(const aParams: IvcmExecuteParams);
    procedure enAttributeopLogicAndExecute(const aParams: IvcmExecuteParams);
    procedure enAttributeopLogicNotExecute(const aParams: IvcmExecuteParams);
    function  AttributeTreeGetItemImage(Sender: TObject; Index: Integer;
                                        var aImages: TCustomImageList): Integer;
    procedure AttributeTreeActionElement(Sender: TObject; Index: Integer);
    procedure AttributeTreeLMouseDown(Sender: TObject; Button: TMouseButton;
                                      Shift: TShiftState; X, Y: Integer);
    procedure AttributeTreeCurrentChanged(Sender: TObject; NewCurrent, OldCurrent: Integer);
    procedure vcmEntityFormSaveState(out aState: IvcmBase;
                                     aStateType: TvcmStateType; var Saved: Boolean);
    procedure vcmEntityFormLoadState(const aState: IvcmBase;
                                     aStateType: TvcmStateType; var Loaded: Boolean);
    procedure enAttributeopDefaultActionExecute(const aParams: IvcmExecuteParams);
    procedure AttributeTreeNewCharPressed(aChar: AnsiChar); override;
    function AttributeTreeIsCommandProcessed(aSender: TObject; aOperation: Cardinal): Boolean;
    procedure AttributeTreeGetItemFont(Sender: TObject; Index: Integer; const aFont: Il3Font);
    procedure vcmEntityFormChangedDataSource(aSender: TObject; const aOld,
      aNew: IvcmFormDataSource; const aFromHistory : Boolean);
    procedure enAttributeopLogicOrContextTest(const aParams: IvcmTestParamsPrim);
    procedure enAttributeopLogicAndContextTest(const aParams: IvcmTestParamsPrim);
    procedure enAttributeopLogicNotContextTest(const aParams: IvcmTestParamsPrim);
    procedure ContextFilterChange(Sender: TObject);
    procedure AttributeTreeAfterFirstPaint(Sender: TObject);
    procedure enTreeopExpandAllTest(const aParams: IvcmTestParamsPrim);
    procedure enTreeopCollapseAllTest(const aParams: IvcmTestParamsPrim);
    procedure AttributeTreeTreeChanged(aSender: TObject; const anOldTree,
      aNewTree: Il3SimpleTree);
    procedure ContextFilterWrongContext(Sender: TObject);
  private
  // internal fields
    f_LockCurrentChange : Integer;
  private
  // property methods
    function pm_GetDS: IdsTreeAttributeSelect;
      {-}
  private
  // properties
    property DS: IdsTreeAttributeSelect
      read pm_GetDS;
      {-}
  private
  // internal methods
    function pm_GetTaggedTreeInfo: InsTaggedTreeInfo;
      {-}
    function pm_GetRootInfo: InsRootInfo;
      {-}
  private
  // internal fields
    f_OrState           : Boolean;
    f_AndState          : Boolean;
    f_NotState          : Boolean;
      {* - состояние кнопки логической операции }
   f_CaptionMap         : InsStringValueMap;
   f_Painted: Boolean;
  protected
    procedure CurrentChangedNotification(const aNode: Il3SimpleNode); override;
      {* - обработчик события смены текущего в дереве. }
  private
  // internal methods
    procedure CurrentChangedPrim(aNewIndex, aOldIndex: Integer; aForceUpdateParent: Boolean = False);
      {-}
    procedure SetLogicOperationOnNode(const aNode: INodeBase);
      {-}
    procedure LogicOperationTest(const aParams: IvcmTestParamsPrim; aOp: TLogicOperation);
      {-}
    procedure FormLogicOperation(const aNode: INodeBase; aOp: TLogicOperation; aWithNotify: Boolean = true); override;
      {-}
    procedure NotifyOperationChange(const aNode: INodeBase; aOldOp, aNewOp: TLogicOperation); override;
      {-}
    procedure NotifyMultipleChanges; override;
      {-}
    procedure SetRootForFirstLevelForm(const aTag: Il3Cstring); override;
      {-}
    procedure SetRootForFullForm(const aTag: Il3Cstring); override;
      {-}
    procedure SetCurrentNode(const aNode: Il3SimpleNode; aExpand: Boolean = false); override;
      {-}
    function  GetFirstLevelParent(const aNode: Il3SimpleNode) : Il3SimpleNode; overload;
      {-}
    function  GetFirstLevelParent(const aNode: INodeBase) : INodeBase; overload;
      {-}
    function  GetFirstLevelParent(aIndex: Integer) : Il3SimpleNode; overload;
      {-}
    procedure DropSelectedOperation; override;
      {-}
    procedure DropAllLogicSelection(aDropSelection: Boolean = false); override;
      {-}
    procedure ActivateElement(anIndex: Integer; LogicOperationOnly: Boolean = False); override;
      {-}
    procedure ChangeOperationOnSelected(aNewOp : TLogicOperation); override;
      {-}
    procedure InvalidateOtherTree; override;
      {-}
    procedure LoadFromQuery(const aQuery: IQuery); override;
      {-}
    function  SaveToQuery(const aQuery : IQuery) : Boolean; override;
      {-}
    function  CountItemImage(const aNode : INodeBase): Integer;
      {-}
    procedure LOToolbarTest(const aParams : IvcmTestParamsPrim;
                            const aLO     : TLogicOperation);
      {* - метод установки параметров в _OnTest для операций публикуемых в
           toolbar-е. Отличие в том, что они не показываются для ситуаций
           первого второго уровня. }
    procedure SendContextChangeMessage; override;
      {-}
    procedure SetupNewTreeStruct(const aTree: Il3SimpleTree); override;
      {-}
    procedure DoContextFilterChange(Sender: TObject); override;
    function GetRootInfo: InsRootInfo; override;
  private
  // properties
    property  TaggedTreeInfo : InsTaggedTreeInfo
      read pm_GetTaggedTreeInfo;
      {-}
    property  RootInfo : InsRootInfo
      read pm_GetRootInfo;
      {-}
  protected
  // protected methods
    procedure Cleanup;
      override;
      {-}
  end;

  TTreeAttributeSelectForm = TefTreeAttributeSelect;

implementation

{$R *.DFM}

uses
  StrUtils,

  OvcConst,

  l3Chars,
  l3InterfacesMisc,
  l3Types,
  l3String,
  l3Nodes,
  l3ControlsTypes,
  l3Base,

  eeTreeMisc,

  vcmForm,

  nscInterfaces,
  nscNewInterfaces,
  nscContextFilterState,

  DataAdapter,

  dsTreeAttributeSelect,

  nsNodes,

  {$If not Defined(Admin)}
  nsQuery,
  {$IfEnd}
  nsQueryUtils,
  nsSettings,
  nsTreeUtils,
  nsUtils,
  {$IfNDef Admin}
  nsSearchClasses,
  {$EndIf  Admin}
  nsValueMapsIDs,
  nsValueMaps,
  SearchRes,

  StdRes,

  BaseTypesUnit,

  deSearch,

  nsAttributeTreeCacheNew,
  nsAttributeTreeStruct,
  nsTreeAttributeNodesNew,
  nsTreeStruct,
  nsFirstLevelStruct,
  nsAttrBranchStruct,
  nsQueryInterfaces,
  nsSelectedAttributesIterators,

  SearchLite_Strange_Controls,

  PrimTreeAttributeSelect_astNone_UserType,
  PrimTreeAttributeSelect_astOneLevel_UserType,
  PrimTreeAttributeSelect_astFirstLevel_UserType,
  PrimTreeAttributeSelect_astTaxesPublishSearch_UserType
  ;

procedure TefTreeAttributeSelect.SetRootForFirstLevelForm(const aTag  : Il3CString);
begin
 AttributeTree.TreeStruct := TnsFirstLevelStruct.Make(aTag, AttributeTree.ShowRoot);
 CCaption := vcmCStr(str_SituationTitle);

 op_AttributeTree_ChangeRoot.Call(Aggregate,
                                  TaggedTreeInfo.Tag,
                                  AttributeTree.TreeStruct.RootNode,
                                  AttributeTree.TreeStruct.RootNode.Child);
end;

procedure TefTreeAttributeSelect.SetRootForFullForm(const aTag: Il3Cstring);
var
 l_TreeSource : Il3SimpleTree;
begin
 l_TreeSource := TnsAttributeTreeStruct.Make(aTag, AttributeTree.ShowRoot);

 with AttributeTree do 
 begin
  TreeStruct := l_TreeSource;
  if (Container.AsForm.ZoneType = vcm_ztParent) then
  begin
   if f_CaptionMap = nil then
    f_CaptionMap := nsStringMapManager.Map[smap_ContextParamsCaptions];
   if (l3Same(aTag, AT_KW)) then
   begin
    CCaption := f_CaptionMap.ValueToDisplayName(aTag);
    ExpandNode(GetCurrentNode, True);
   end
   else
   if (l3Same(aTag, AT_PUBLISH_SOURCE)) then
   begin
    if UserType = astTaxesPublishSearch then
     CCaption := CurUserTypeDef.Caption
    else
     CCaption := f_CaptionMap.ValueToDisplayName(aTag);
   end//l3Same(aTag, AT_PUBLISH_SOURCE)
   else
    CCaption := l3CStr(TreeStruct.RootNode);
  end//Container.AsForm.ZoneType = vcm_ztParent
  else
   CCaption := nil;
 end; //with AttributeTree
end;

function TefTreeAttributeSelect.GetFirstLevelParent(aIndex: Integer) : Il3SimpleNode;
var
 l_l3Node : Il3SimpleNode;
begin
 Result := nil;

 if (UserType = astOneLevel) then
  Result := AttributeTree.TreeStruct.RootNode
 else
 begin
  l_l3Node := AttributeTree.GetNode(aIndex);
  try
   Result := GetFirstLevelParent(l_l3Node);
  finally
   l_l3Node := nil;
  end;
 end;
end;

procedure TefTreeAttributeSelect.ChangeOperationOnSelected(aNewOp : TLogicOperation);
var
 l_Node,
 l_Root : INodeBase;
 l_Iterator : INodeIterator;
begin
 if (AttributeTree.TreeStruct.SelectCount > 0) and
    Supports(AttributeTree.TreeStruct.RootNode, INodeBase, l_Root) then
 begin
  l_Root.IterateNodes(FM_SELECTION, l_Iterator);
  try
   l_Iterator.GetNext(l_Node);
   while l_Node <> nil do
   begin
    if not l_Node.HasFilteredChildren then
     SetLogicOperation(l_Node, aNewOp);
    l_Iterator.GetNext(l_Node);
   end;
   NotifyMultipleChanges;
  finally
   l_Root := nil;
  end;
 end;
end;

procedure TefTreeAttributeSelect.DropSelectedOperation;
begin
 ChangeOperationOnSelected(loNone);
end;

procedure TefTreeAttributeSelect.vcmEntityFormInit;
begin
 (* задел на будущее чтобы в ResultopOk в aParams.Control было установлено
    дерево и нас бы не пришлось использовать GetFocus и FindControl  *)
// Entities.LinkControlToEntity(AttributeTree, 'enResult');
 ContextFilter.Images := dmStdRes.SmallImageList;
 AttributeTree.Images := nsSearchRes.ilSelectAttribute;
 if UserType = astOneLevel then
  AttributeTree.ViewOptions := AttributeTree.ViewOptions - [voShowOpenChip]
 else
  if UserType = astFirstLevel then
  begin
   AttributeTree.ViewOptions := AttributeTree.ViewOptions - [voShowOpenChip];
   AttributeTree.EditOptions := AttributeTree.EditOptions - [eoItemExpand];
  end;
 // Видимость контекстного поиска
 if not IsOldSchoolNone then
 begin
  ContextFilter.Visible := False;
  ContextFilter.Enabled := False;
 end;//not IsOldSchoolNone
end;

procedure TefTreeAttributeSelect.Cleanup;
// override;
{-}
begin
 if (AttributeTree.TreeStruct <> nil) then
  AttributeTree.TreeStruct.Unsubscribe(InsTreeDataListener(Self));
 f_CaptionMap := nil;
 inherited;
end;

function TefTreeAttributeSelect.AttributeTreeGetItemImage(Sender: TObject;
                                                          Index: Integer;
                                                          var aImages: TCustomImageList): Integer;
var
 l_Node: Il3SimpleNode;
 l_AdapterNode: INodeBase;
begin
 Result := -1;
 if Index >= 0 then
 begin
  l_Node := AttributeTree.TreeStruct.Nodes[Index];
  try
   if Supports(l_Node, INodeBase, l_AdapterNode) then
    try
     Result := CountItemImage(l_AdapterNode);
    finally
     l_AdapterNode := nil;
    end;
  finally
   l_Node := nil;
  end;
 end;
end;

procedure TefTreeAttributeSelect.AttributeTreeActionElement(Sender: TObject; Index: Integer);
begin
 ActivateElement(Index, False);
end;

procedure TefTreeAttributeSelect.AttributeTreeLMouseDown(Sender: TObject;
                                                         Button: TMouseButton;
                                                         Shift: TShiftState;
                                                         X, Y: Integer);
var
 l_Index    : Integer;
 l_ItemPart : Byte;
 l_l3Node   : Il3SimpleNode;
begin
 AttributeTree.HitTest(Point(X, Y), l_Index, l_ItemPart);
 if  (l_ItemPart = ihtIcon) then
 begin
  l_l3Node := AttributeTree.GetNode(l_Index);
  try
   AttributeTree.Current := l_Index;
   ActivateElement(l_Index, True);
  finally
   l_l3Node := nil;
  end;
 end;
end;

procedure TefTreeAttributeSelect.LOToolbarTest(const aParams : IvcmTestParamsPrim;
                                               const aLO     : TLogicOperation);
  {-}
begin
 // Обязательно нужно выполнить, потому, что для ситуаций первого второго уровня
 // кнопка не видима, но Test используется контейнером cfSaveLoad для установки
 // состония кнопки
 LogicOperationTest(aParams, aLO);
 // !!! Нельзя заменять на ExcludeType, т.к. вызов идет с другой формы-контейнера
 aParams.Op.Flag[vcm_ofVisible] := not (UserType in [astOneLevel, astFirstLevel]);
end;

procedure TefTreeAttributeSelect.enAttributeopLogicOrTest(const aParams: IvcmTestParamsPrim);
begin
 LOToolbarTest(aParams, loOr);
end;

procedure TefTreeAttributeSelect.enAttributeopLogicAndTest(const aParams: IvcmTestParamsPrim);
begin
 LOToolbarTest(aParams, loAnd);
end;

procedure TefTreeAttributeSelect.enAttributeopLogicNotTest(const aParams: IvcmTestParamsPrim);
begin
 LOToolbarTest(aParams, loNot);
end;

procedure TefTreeAttributeSelect.enAttributeopLogicOrExecute(const aParams: IvcmExecuteParams);
Var
 l_Node: INodeBase;
begin
 if (AttributeTree.TreeStruct.SelectCount <= 1) and
    (AttributeTree.Current >= 0) then
 begin
  if Supports(AttributeTree.GetCurrentNode, INodeBase, l_Node) then
   FormLogicOperation(l_Node, loOr);
 end
 else
  if f_OrState then
   DropSelectedOperation
  else
   ChangeOperationOnSelected(loOr);
 AttributeTree.Invalidate;
 InvalidateOtherTree;
end;

procedure TefTreeAttributeSelect.enAttributeopLogicAndExecute(const aParams: IvcmExecuteParams);
Var
 l_Node: INodeBase;
begin
 if (AttributeTree.TreeStruct.SelectCount <= 1) and
    (AttributeTree.Current >= 0) then
 begin
  if Supports(AttributeTree.GetCurrentNode, INodeBase, l_Node) then
   FormLogicOperation(l_Node, loAnd);
 end
 else
  if f_AndState then
   DropSelectedOperation
  else
   ChangeOperationOnSelected(loAnd);
 AttributeTree.Invalidate;
 InvalidateOtherTree;
end;

procedure TefTreeAttributeSelect.enAttributeopLogicNotExecute(const aParams: IvcmExecuteParams);
Var
 l_Node: INodeBase;
begin
 if (AttributeTree.TreeStruct.SelectCount <= 1) and
    (AttributeTree.Current >= 0) then
 begin
  if Supports(AttributeTree.GetCurrentNode, INodeBase, l_Node) then
   FormLogicOperation(AttributeTree.GetCurrentNode as INodeBase, loNot);
 end
 else
  if f_NotState then
   DropSelectedOperation
  else
   ChangeOperationOnSelected(loNot);
 AttributeTree.Invalidate;
 InvalidateOtherTree; 
end;

procedure TefTreeAttributeSelect.AttributeTreeCurrentChanged(Sender: TObject;
                                                             NewCurrent, OldCurrent: Integer);
begin
 if f_LockCurrentChange > 0 then
  exit;
 if NewCurrent <> -1 then
  CurrentChangedPrim(NewCurrent, OldCurrent, False);
end;

procedure TefTreeAttributeSelect.DropAllLogicSelection(aDropSelection: Boolean);
Var
 l_Root,
 l_AdapterNode: INodeBase;
 l_CurNode: Il3SimpleNode;
begin
 if Supports(AttributeTree.TreeStruct.RootNode, INodeBase, l_Root) then
 begin
  DropAllOperations(l_Root);
  if aDropSelection then
  begin
   l_CurNode := AttributeTree.GetCurrentNode;
   if not Supports(l_CurNode, INodeBase, l_AdapterNode) then
    l_AdapterNode := nil;
   DropExtraSelection(l_Root, l_AdapterNode);
  end;
  AttributeTree.Invalidate;
  InvalidateOtherTree;
 end;
end;

procedure TefTreeAttributeSelect.InvalidateOtherTree;
begin
 case UserType of
  astOneLevel:
   Op_AttributeTree_Invalidate.Call(Aggregate, Ord(astFirstLevel));
  astFirstLevel:
   Op_AttributeTree_Invalidate.Call(Aggregate, Ord(astOneLevel));
 end;//astOneLevel
end;

function TefTreeAttributeSelect.SaveToQuery(const aQuery : IQuery) : Boolean;
var
 lTaggedTreeInfo : InsTaggedTreeInfo;
begin
 Result := False;
 lTaggedTreeInfo := TaggedTreeInfo;
 if Assigned(lTaggedTreeInfo) then
 try
  Result := SaveLogicToQuery(aQuery, lTaggedTreeInfo.Tag,
   AttributeTree.TreeStruct);
 finally
  lTaggedTreeInfo := nil;
 end;
end;

procedure TefTreeAttributeSelect.vcmEntityFormSaveState(out aState: IvcmBase;
                                                        aStateType: TvcmStateType;
                                                        var Saved: Boolean);
var
 l_Query     : IQuery;
 {$If not Defined(Admin)}
 l_Container : TnsQueryContainer;
 {$IfEnd}
begin
 if IsOldSchoolNone then
 begin
  // В этом месте запрос носит чисто транспортные функции, поэтому его тип не
  // играет роли и задан "от фонаря":
  {$If not Defined(Admin)}
  defDataAdapter.Search.CreateQuery(QT_ATTRIBUTE, l_Query);
  try
    l_Container := TnsQueryContainer.Create;
    try
     if SaveToQuery(l_Query) then
      InsQueryContainer(l_Container).Query := l_Query
     else
      InsQueryContainer(l_Container).Query := nil;
     aState := l_Container as IvcmBase;
    finally
     vcmFree(l_Container);
    end;{try..finally}
  finally
   l_Query := nil;
  end;//try..finally
  {$Else}
  Saved := false;
  {$ifEnd}
 end;//IsOldSchoolNone
end;

procedure TefTreeAttributeSelect.vcmEntityFormLoadState(const aState: IvcmBase;
                                                        aStateType: TvcmStateType;
                                                        var Loaded: Boolean);
var
 l_Container: InsQueryContainer;
begin
 if (aStateType = vcm_stContent) and
    IsOldSchoolNone then
 begin
  if Supports(aState, InsQueryContainer, l_Container) then
   try
    DropAllLogicSelection;
    if (l_Container.Query <> nil) then
     LoadFromQuery(l_Container.Query);
   finally
    l_Container := nil;
   end;{try..finally}
 end;//if (aStateType = vcm_stContent) and
end;//vcmEntityFormLoadState

procedure TefTreeAttributeSelect.ActivateElement(anIndex: Integer; LogicOperationOnly: Boolean);
var
 l_l3Node : Il3SimpleNode;
 l_Node : INodeBase;
begin
 if anIndex >= 0 then
  l_l3Node := AttributeTree.GetNode(anIndex)
 else
  l_l3Node := AttributeTree.GetCurrentNode;

 if Supports(l_l3Node, INodeBase, l_Node) then
 begin
  if LogicOperationOnly or
     not l_Node.HasChildren then
  begin
   SetLogicOperationOnNode(l_Node);
   AttributeTree.Invalidate;
   InvalidateOtherTree;
  end
  else
   AttributeTree.ExpandNode(l_l3Node, not AttributeTree.TreeStruct.IsExpanded(l_l3Node));
 end;
end;

procedure TefTreeAttributeSelect.enAttributeopDefaultActionExecute(const aParams: IvcmExecuteParams);
begin
 Attribute_DefaultAction_Execute;
end;

function TefTreeAttributeSelect.GetFirstLevelParent(const aNode: Il3SimpleNode): Il3SimpleNode;
var
 l_Parent : Il3SimpleNode;
begin
 if (aNode = nil) then
  Result := nil
 else
  if (UserType = astOneLevel) then
   Result := AttributeTree.TreeStruct.RootNode
  else
  begin
   l_Parent := aNode.Parent;
   try
    if l_Parent = nil then
     Result := nil
    else
     if l_Parent.IsSame(AttributeTree.TreeStruct.RootNode) then
      Result := aNode
     else
     begin
      while not l_Parent.Parent.IsSame(AttributeTree.TreeStruct.RootNode) do
       l_Parent := l_Parent.Parent;
      Result := l_Parent;
     end;
   finally
    l_Parent := nil;
   end;
  end;
end;

function TefTreeAttributeSelect.CountItemImage(const aNode : INodeBase): Integer;
var
 l_Operation       : TLogicOperation;
 l_ParentOperation : TLogicOperation;
 l_FilteredNode    : Boolean;
begin
 l_Operation := GetLogicOperation(aNode);
 l_ParentOperation := GetParentsOperation(aNode);
 l_FilteredNode := aNode.HasFilteredChildren;
 if (l_Operation <> loNone) or
    (l_ParentOperation = loNone) then
 begin
  if aNode.HasChildren or (UserType = astFirstLevel) then
  begin
   if (l_Operation = loNone) and HasAnyChildOperation(aNode) then
    if (l_FilteredNode) then
      Result := c_saFilteredFolderHasSelectChild
    else
      Result := c_saFolderHasSelectChild
   else
    if (l_FilteredNode) then
      Result := c_saFilteredFolderStart + Byte(l_Operation)
    else
      Result := c_saFolderStart + Byte(l_Operation);
  end
  else
   Result := c_saElementStart + Byte(l_Operation);
 end
 else
 begin
  if (l_ParentOperation = loNot) then
  begin
   if aNode.HasChildren then
     if (l_FilteredNode) then
      Result := c_saFilteredFolderInSelectFolderDisable
     else
      Result := c_saFolderInSelectFolderDisable
   else
    Result := c_saChildInSelectFolderDisable;
  end
  else
  begin
   if aNode.HasChildren then
    if (l_FilteredNode) then
      Result := c_saFilteredFolderInSelectFolderEnable
    else
      Result := c_saFolderInSelectFolderEnable
   else
    Result := c_saChildInSelectFolderEnable;
  end;
 end;
end;

procedure TefTreeAttributeSelect.SetLogicOperationOnNode(const aNode: INodeBase);
var
 l_ParentOperation : TLogicOperation;
 l_OldOperation    : TLogicOperation;
 l_CurOperation    : TLogicOperation;
begin
 l_CurOperation := loNone;
 if not aNode.HasFilteredChildren then
 begin
  l_ParentOperation := GetParentsOperation(aNode);
  if l_ParentOperation <> loNot then
  begin
   l_OldOperation := GetLogicOperation(aNode);
   if l_OldOperation = High(TLogicOperation) then
    l_CurOperation := loNone
   else
   begin
    // Включаем\выключаем только первую разрешенную для узла операцию:
    if (l_ParentOperation = loNone) then
    begin
     // Выключаем операцию:
     if l_OldOperation <> loNone then
      l_CurOperation := loNone
     // Включаем операцию:
     else
     begin
      l_CurOperation := Succ(l_OldOperation);
      if Assigned(DS) then
       while (l_CurOperation <> loNone) and
         not (l_CurOperation in DS.Operations) do
       begin
        if l_CurOperation = High(TLogicOperation) then
         l_CurOperation := Low(TLogicOperation)
        else
         l_CurOperation := Succ(l_CurOperation);
       end;//while (l_CurOperation <> loNone) and...
     end;//if l_OldOperation <> loNone then
    end//if (l_ParentOperation = loNone) then
    else
     if Assigned(DS) then
      if loNot in DS.Operations then
       l_CurOperation := loNot
      else
       l_CurOperation := loNone;
   end;//if l_OldOperation = High(TLogicOperation) then
   SetLogicOperation(aNode, l_CurOperation);
   NotifyOperationChange(aNode, l_OldOperation, l_CurOperation);
  end;//if l_ParentOperation <> loNot then
 end//if not aNode.HasFilteredChildren then
 else
 begin
  l_OldOperation := GetLogicOperation(aNode);
  if l_OldOperation <> loNone then
  begin
   SetLogicOperation(aNode, loNone);
   NotifyOperationChange(aNode, l_OldOperation, loNone);
  end;//if l_OldOperation <> loNone then
 end;//if not aNode.HasFilteredChildren then
end;//SetLogicOperationOnNode

procedure TefTreeAttributeSelect.LogicOperationTest(const aParams : IvcmTestParamsPrim;
                                                    aOp           : TLogicOperation);
var
 l_l3Node : Il3SimpleNode;
 l_Node   : INodeBase;
begin
 case aOp of
  loOr: f_OrState := False;
  loAnd: f_AndState := False;
  loNot: f_NotState := False;
 end;

 if Assigned(DS) and
    not (aOp in DS.Operations) then
 begin
  //aParams.Op.Flag[vcm_ofVisible] := False;
  aParams.Op.Flag[vcm_ofEnabled] := False;
 end
 else
  if AttributeTree.Current >= 0 then
  begin
   l_l3Node := AttributeTree.GetCurrentNode;
   if Supports(l_l3Node, INodeBase, l_Node) and
      not l_Node.HasFilteredChildren then
   begin
    if GetLogicOperation(l_Node) = aOp then
    begin
     case aOp of
      loOr: f_OrState := True;
      loAnd: f_AndState := True;
      loNot: f_NotState := True;
     end;
     aParams.Op.Flag[vcm_ofChecked] := True
    end
    else
     if ((aOp <> loNot) and (GetParentsOperation(l_Node) <> loNone)) or
        ((aOp = loNot) and  (GetParentsOperation(l_Node) = loNot)) then
     begin
      aParams.Op.Flag[vcm_ofChecked] := False;
      aParams.Op.Flag[vcm_ofEnabled] := False;
     end
     else
     begin
      aParams.Op.Flag[vcm_ofChecked] := False;
      aParams.Op.Flag[vcm_ofEnabled] := True;
     end;
   end
   else
    aParams.Op.Flag[vcm_ofEnabled] := False;
  end
  else
   aParams.Op.Flag[vcm_ofEnabled] := False;
end;

procedure TefTreeAttributeSelect.FormLogicOperation(const aNode: INodeBase;
                                                    aOp: TLogicOperation;
                                                    aWithNotify: Boolean);
Var
 l_OldOp: TLogicOperation;
begin
 l_OldOp := GetLogicOperation(aNode);
 if l_OldOp = aOp then
  aOp := loNone;

 if (aOp = loNone) or
    not aNode.HasFilteredChildren then
 begin
  SetLogicOperation(aNode, aOp);
  if aWithNotify then
   NotifyOperationChange(aNode, l_OldOp, aOp);
 end;
end;

procedure TefTreeAttributeSelect.NotifyOperationChange(const aNode: INodeBase; aOldOp,
  aNewOp: TLogicOperation);
begin
{
 if (Aggregate <> nil) then
 begin
  if aOldOp = loNone then
   Aggregate.Operation(op_SelectedList_Add,
                       vcmParams.Add(aNode).Add(Byte(aNewOp)))
  else
   if aNewOp = loNone then
    Aggregate.Operation(op_SelectedList_Delete,
                        vcmParams.Add(aNode))
   else
    Aggregate.Operation(op_SelectedList_ChangeOperation,
                        vcmParams.Add(aNode).Add(Byte(aNewOp)));
 end;
}
 NotifyMultipleChanges;
end;

function TefTreeAttributeSelect.pm_GetTaggedTreeInfo: InsTaggedTreeInfo;
begin
 Supports(AttributeTree.TreeStruct, InsTaggedTreeInfo, Result);
end;

procedure TefTreeAttributeSelect.NotifyMultipleChanges;
Var
 l_Params : IvcmExecuteParams;
 l_Root   : INodeBase;
begin
 // Для формы входящую в сборку
 if Assigned(DS) and Assigned(DS.UseCaseController) then
  DS.UpdateSelectedAttributes
 // Для форм не входящих в сборку
 else
 begin
  if (UserType = astOneLevel) and (RootInfo <> nil) then
   l_Root := RootInfo.Root
  else
   Supports(AttributeTree.TreeStruct.RootNode, INodeBase, l_Root);

  if (l_Root <> nil) then
   op_SelectedList_RefreshValues.Call(Aggregate,
                                      TnsSelectedAttributesIterators.Make(
                                       GetOperationIterator(l_Root, loOr),
                                       GetOperationIterator(l_Root, loAnd),
                                       GetOperationIterator(l_Root, loNot)));
 end;
end;

procedure TefTreeAttributeSelect.LoadFromQuery(const aQuery: IQuery);
begin
 if Assigned(aQuery) then
  LoadLogicFromQuery(aQuery, TaggedTreeInfo.Tag, AttributeTree.TreeStruct);
end;

function TefTreeAttributeSelect.pm_GetRootInfo: InsRootInfo;
begin
 Result := nil;
 Supports(AttributeTree.TreeStruct, InsRootInfo, Result);
end;

function TefTreeAttributeSelect.GetFirstLevelParent(const aNode: INodeBase): INodeBase;
Var
 l_Parent,
 l_Node: INodeBase;
begin
 Result := nil;
 if (aNode <> nil) and
    (UserType = astOneLevel) then
  Supports(AttributeTree.TreeStruct.RootNode, INodeBase, Result)
 else
 begin
  l_Node := aNode;
  try
   while l_Node.GetLevel > 1 do
   begin
    l_Node.GetParent(l_Parent);
    l_Node := nil;
    if l_Parent = nil then
     exit;
    l_Node := l_Parent;
    l_Parent := nil;
   end;
   Result := l_Node;
  finally
   l_Node := nil;
  end;
 end;
end;

procedure TefTreeAttributeSelect.SetCurrentNode(const aNode: Il3SimpleNode;
                                                aExpand: Boolean);
var
 l_Node        : Il3SimpleNode;
 l_ParentNode  : INodeBase;
 l_AdapterNode : INodeBase;
 l_CurNode     : Il3SimpleNode;
 l_OldIndex    : Integer;
 l_OldParent   : Il3SimpleNode;

 procedure lpFirstLevelParentCollapse(const aNode: Il3SimpleNode);
 var
  l_NodeBase: INodeBase; 
 begin
  if Supports(aNode, INodeBase, l_NodeBase) then
  try
   l_NodeBase.SetFlag(FM_OPEN, False);
  finally
   l_NodeBase := nil;
  end;{try..finally}
 end;//lpFirstLevelParentCollapse

begin
 l_Node := aNode;
 if UserType = astFirstLevel then
 begin
  if Supports(l_Node, INodeBase, l_AdapterNode) then
  begin
   l_Node := nil;
   l_ParentNode := GetFirstLevelParent(l_AdapterNode);
   if l_ParentNode <> nil then
    l_Node := TnsSelectedNode.Make(l_ParentNode);
  end;
 end;

 if (l_Node <> nil) then
 begin
  if (AttributeTree.GetCurrentNode <> nil) and
     AttributeTree.GetCurrentNode.IsSame(l_Node) then
  begin
   AttributeTree.vlbMakeItemVisible(AttributeTree.Current);
   CurrentChangedPrim(AttributeTree.Current, AttributeTree.Current, True)
  end
  else
  begin
   l_OldIndex := AttributeTree.Current;
   l_OldParent := GetFirstLevelParent(l_OldIndex);
   if AttributeTree.GotoOnNode(l_Node) < 0 then
    exit;
   if (l_OldParent <> nil) and
      l_OldParent.IsSame(GetFirstLevelParent(AttributeTree.Current)) then
    CurrentChangedPrim(AttributeTree.Current, l_OldIndex, True);
  end;

 // второе условие - проверка, а нормальная ли нода к нам пришла (не И, ИЛИ, ..)
  if aExpand and IsOldSchoolNone then
  begin
   l_CurNode := AttributeTree.GetCurrentNode;
   AttributeTree.ExpandNode(l_CurNode, True);
   AttributeTree.TopIndex := AttributeTree.TreeStruct.GetIndex(l_CurNode);
  end;//if aExpand and
  if (UserType = astFirstLevel) and
     (Aggregate <> nil) then
  begin
   op_AttributeTree_SetOneLevelCurrent.Call(Aggregate, aNode);
   // После позиционирования в one level дереве, родитель развернется после
   // вызова Parent.GetVisibleDelta, что не допустимо для нашего рукотворного
   // одноуровненго дереве, в котором все родители должны быть свернуты, иначе
   // GetVisibleDelta будет возвращаеть результаты с учетом детей развернутых
   // родителей и позиционирование будет не правильным
   lpFirstLevelParentCollapse(l_Node);
  end;//if (UserType = astFirstLevel)
 end;//if (l_Node <> nil) then
end;//SetCurrentNode

procedure TefTreeAttributeSelect.AttributeTreeNewCharPressed(aChar: AnsiChar);
begin
 if UserType <> astOneLevel then
  ContextFilter.PressChar(aChar)
 else
  op_AttributeTree_ExternalCharPressed.Call(Aggregate, nsCStr(aChar));
end;

function TefTreeAttributeSelect.AttributeTreeIsCommandProcessed(aSender: TObject; aOperation: Cardinal): Boolean;
begin
 Result := True;
 case aOperation of
  ccActionItem:
   Result := False;
 end;
end;

procedure TefTreeAttributeSelect.AttributeTreeGetItemFont(Sender: TObject;
  Index: Integer; const aFont: Il3Font);
var
 l_Node: Il3SimpleNode;
 l_AdapterNode: INodeBase;
begin
 if Index >= 0 then
 begin
  l_Node := AttributeTree.TreeStruct.Nodes[Index];
  try
   if Supports(l_Node, INodeBase, l_AdapterNode) then
    try
     if l_AdapterNode.HasFilteredChildren then
      aFont.ForeColor := clRed
    finally
     l_AdapterNode := nil;
    end;
  finally
   l_Node := nil;
  end;
 end;
end;

procedure TefTreeAttributeSelect.CurrentChangedPrim(aNewIndex,
  aOldIndex: Integer; aForceUpdateParent: Boolean);
var
 l_NewParent : Il3SimpleNode;
 l_Root      : INodeBase;
begin
 case UserType of
  astFirstLevel:
  begin
   op_AttributeTree_ChangeRoot.Call(Aggregate,
                                    TaggedTreeInfo.Tag,
                                    AttributeTree.TreeStruct.RootNode,
                                    AttributeTree.GetNode(aNewIndex));
  end;//astFirstLevel
  astOneLevel:
  begin
   {!! можно выбросить, когда FirstLevel и OneLevel станут разными view }
   if Supports(AttributeTree.TreeStruct.RootNode, INodeBase, l_Root) then
    l_Root.SetFlag(FM_SELECTION, True);
  end;//astOneLevel
  else
   if (aNewIndex >= 0) then
   begin
    l_NewParent := GetFirstLevelParent(aNewIndex);
    try
     if (l_NewParent <> nil) and (Aggregate <> nil) and
       (aForceUpdateParent or not l_NewParent.
        IsSame(GetFirstLevelParent(aOldIndex))) then
      DS.CurrentChanged(l_NewParent);
    finally
     l_NewParent := nil;
    end;//try..finally
   end;//if (aNewIndex >= 0) then
 end;//case UserType of
end;//CurrentChangedPrim

function TefTreeAttributeSelect.pm_GetDS: IdsTreeAttributeSelect;
  {-}
begin
 // это временная мера пока ППС 5.х не переведена на сборку. Сделано потому, что
 // форма уже опирается на IdsTreeAttributeSelect, но есть случаи использования
 // формы вне сборки
{$If not defined(ADMIN)}
 if not Assigned(DataSource) and Assigned(TaggedTreeInfo) and not (csDestroying in Componentstate) then
  DataSource := TdsTreeAttributeSelect.Make(nil, TdeSearch.Make(TaggedTreeInfo.Tag, nil));
{$IfEnd}
 // Возвращаем честный _DataSource
 Result := dsTreeAttributeSelect;
end;

procedure TefTreeAttributeSelect.vcmEntityFormChangedDataSource(
  aSender: TObject; const aOld, aNew: IvcmFormDataSource; const aFromHistory : Boolean);
begin
 // Для формы с фиктивным DS, которая не входит в сборку ничего не делаем
 if Assigned(DS) and Assigned(DS.UseCaseController) then
 begin
  // Борьба с фильтром vs. история vs. _datasource
  if not aFromHistory then
  begin
   with AttributeTree do
   begin
    // Дерево:
    TreeStruct := DS.SimpleTree;
    // Разворачивает первый узел:
    ExpandNode(GetCurrentNode, True);
   end;//with AttributeTree do
   // Загрузим запрос:
   LoadFromQuery(DS.Search.Query);
   InvalidateOtherTree;
   NotifyMultipleChanges;
  end//not aFromHistory
  else
  if Assigned(aOld) and Assigned(aNew) and (TaggedTreeInfo <> nil) then
   DS.SimpleTree := TnsAttributeTreeStruct.Make(TaggedTreeInfo.Tag, False);
  CCaption := DS.DisplayName;
 end;//if Assigned(DS) and Assigned(DS.UseCaseController) then
end;//vcmEntityFormChangedDataSource

procedure TefTreeAttributeSelect.enAttributeopLogicOrContextTest(const aParams: IvcmTestParamsPrim);
begin
 //aParams.Op.Flag[vcm_ofVisible] := True;
 LogicOperationTest(aParams, loOr);
end;

procedure TefTreeAttributeSelect.enAttributeopLogicAndContextTest(const aParams: IvcmTestParamsPrim);
begin
 //aParams.Op.Flag[vcm_ofVisible] := True;
 LogicOperationTest(aParams, loAnd);
end;

procedure TefTreeAttributeSelect.enAttributeopLogicNotContextTest(const aParams: IvcmTestParamsPrim);
begin
 //aParams.Op.Flag[vcm_ofVisible] := True;
 LogicOperationTest(aParams, loNot);
end;

procedure TefTreeAttributeSelect.ContextFilterChange(Sender: TObject);
var
 l_Index: Integer;
 l_Tree: Il3FilterableTree;
 l_TreeSource: Il3SimpleTree;
begin
 if (UserType <> astOneLevel) then
 begin
  if Supports(AttributeTree.TreeStruct, Il3FilterableTree, l_Tree) then
  try
   // получаем _CreateView от рута дерева, а не от рута предыдущего view
   //при пустом Context, l_Index возвращает -2
   l_TreeSource := l_Tree.MakeFiltered(l_Tree.CloneFilters.SetCOntext(ContextFilter.ActiveContext),
                                      nil,
                                      l_Index,
                                      IsOldSchoolNone,
                                      ContextFilter.NeedRefilterTree or f_NeedRefilterTree);
   if l_TreeSource.CountView > 0 then
    SetupNewTreeStruct(l_TreeSource);
  finally
   l_Tree := nil;
  end;{try..finally}
  // Сообщим об изменении контекста
  ContextFilter.UpdateIsContextWrong;
  SendContextChangeMessage;
 end;
end;

procedure TefTreeAttributeSelect.SendContextChangeMessage;
begin
 {$If not Defined(Admin) AND not Defined(Monitorings) }
 op_ContextParams_ContextChanged.Call(Aggregate,
                                      ContextFilter.MakeState,
                                      ContextFilter.ContextFilterTarget);
 {$IfEnd}  
end;

procedure TefTreeAttributeSelect.SetupNewTreeStruct(
  const aTree: Il3SimpleTree);
var
 l_Root: INodeBase;
 l_NewParent: Il3SimpleNode;
begin
 //заплатка
 if Supports(aTree.RootNode, INodeBase, l_Root) then
  DropExtraSelection(l_Root, nil);
 inc(f_LockCurrentChange);
 try
  AttributeTree.Changing;
  try
   AttributeTree.LockChangeSelected;
   try
    AttributeTree.TreeStruct := aTree;
    if (Aggregate <> nil) and
       IsOldSchoolNone then
     op_AttributeTree_ExtSetRoot.Call(Aggregate, AttributeTree.TreeStruct.RootNode As INodeBase);
   finally
    AttributeTree.UnLockChangeSelected;
   end;{try..finally}
  finally
   AttributeTree.Changed;
  end;{try..finally}
 finally
  dec(f_LockCurrentChange);
 end;{try..finally}
 if (UserType = astFirstLevel) then
 begin
  if AttributeTree.Current >= 0 then
   l_NewParent := AttributeTree.GetCurrentNode
  else
   l_NewParent := nil;
  try
   op_AttributeTree_ChangeRoot.Call(Aggregate,
                                    TaggedTreeInfo.Tag,
                                    AttributeTree.TreeStruct.RootNode,
                                    l_NewParent);
  finally
   l_NewParent := nil;
  end;{try..finally}
 end;//if (UserType = astFirstLevel) then
end;

procedure TefTreeAttributeSelect.DoContextFilterChange(Sender: TObject);
begin
 ContextFilterChange(Sender);
end;

function TefTreeAttributeSelect.GetRootInfo: InsRootInfo;
begin
 Result := RootInfo;
end;

procedure TefTreeAttributeSelect.AttributeTreeAfterFirstPaint(
  Sender: TObject);
begin
 // А это грязный хак для борьбы с переключением баз/поднятием из истории и открбчением
 // контекстного фильтра в контейнере для ППС 5х (cfOldSituationSearch)
 if (UserType <> astOneLevel) and not f_Painted then
  SendContextChangeMessage;
 f_Painted := True;
end;

procedure TefTreeAttributeSelect.enTreeopExpandAllTest(
  const aParams: IvcmTestParamsPrim);
begin
 aParams.Op.Flag[vcm_ofEnabled] := IsOldSchoolNone
  and not TaggedTreeInfo.IsDataOneLevel;
end;

procedure TefTreeAttributeSelect.enTreeopCollapseAllTest(
  const aParams: IvcmTestParamsPrim);
begin
 aParams.Op.Flag[vcm_ofEnabled] := IsOldSchoolNone
  and not TaggedTreeInfo.IsDataOneLevel;
end;

procedure TefTreeAttributeSelect.AttributeTreeTreeChanged(aSender: TObject;
  const anOldTree, aNewTree: Il3SimpleTree);
begin
 if (anOldTree <> nil) then
  anOldTree.Unsubscribe(InsTreeDataListener(Self));
 if Assigned(DS) then
  DS.SimpleTree := aNewTree;
 if (aNewTree <> nil) then
  aNewTree.Subscribe(InsTreeDataListener(Self));
end;

procedure TefTreeAttributeSelect.CurrentChangedNotification(
  const aNode: Il3SimpleNode);
begin
 SetCurrentNode(aNode, True);
end;

procedure TefTreeAttributeSelect.ContextFilterWrongContext(
  Sender: TObject);
begin
 nsBeepWrongContext;
end;

end.


