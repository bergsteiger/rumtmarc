unit nsQueryAttribute;
(*-----------------------------------------------------------------------------
 Unit Name: nsQueryAttribute
 Author:    Инишев Дмитрий & Михаил Морозов
 Purpose:   Модуль содержит классы для работы "Поиска по реквизитам"
 History:
 $Id: nsQueryAttribute.pas,v 1.363 2013/04/24 09:35:56 lulin Exp $

 $Log: nsQueryAttribute.pas,v $
 Revision 1.363  2013/04/24 09:35:56  lulin
 - портируем.

 Revision 1.362  2012/08/16 16:16:49  kostitsin
 [$381878311]

 Revision 1.361  2012/03/21 11:16:46  lulin
 {RequestLink:349114873}

 Revision 1.360  2012/01/19 14:09:29  lulin
 {RequestLink:327825257}

 Revision 1.359  2012/01/17 14:05:53  gensnet
 http://mdp.garant.ru/pages/viewpage.action?pageId=326773154

 Revision 1.358  2011/12/15 16:24:19  lulin
 {RequestLink:320734796}

 Revision 1.357  2011/09/06 15:06:59  lulin
 {RequestLink:271758153}.

 Revision 1.356  2011/06/23 15:30:13  lulin
 {RequestLink:254944102}.

 Revision 1.355  2011/05/19 12:18:14  lulin
 {RequestLink:266409354}.

 Revision 1.354  2011/04/13 14:34:01  lulin
 {RequestLink:258607641}.

 Revision 1.353  2011/03/30 13:46:41  lulin
 {RequestLink:259180243}.

 Revision 1.352  2011/03/22 13:21:40  lulin
 {RequestLink:255964947}.

 Revision 1.351  2010/12/22 18:25:00  lulin
 {RequestLink:242845936}.

 Revision 1.350  2010/11/22 13:39:10  lulin
 [$242845500].

 Revision 1.349  2010/11/02 15:19:14  lulin
 {RequestLink:237994238}.

 Revision 1.348  2010/11/01 17:20:09  lulin
 {RequestLink:237994238}.
 - передаём ссылку на "модель".
 - делаем, чтобы собирались другие проекты.

 Revision 1.347  2010/11/01 13:20:45  lulin
 {RequestLink:237994238}.

 Revision 1.346  2010/10/25 09:55:14  lulin
 {RequestLink:237502802}.
 Шаг №3.

 Revision 1.345  2010/07/21 05:58:39  lulin
 {RequestLink:227478809}.
 [$227967127].

 Revision 1.344  2010/07/05 11:33:05  lulin
 {RequestLink:207389954}.
 - bug fix: не собирался Admin.

 Revision 1.343  2010/05/27 05:30:00  oman
 - new: {RequestLink:197493008}

 Revision 1.342  2010/05/26 12:09:58  oman
 - new: {RequestLink:197493008}

 Revision 1.341  2010/05/07 12:55:56  oman
 - new: {RequestLink:210043512}

 Revision 1.340  2010/03/16 15:50:30  lulin
 {RequestLink:197496426}.

 Revision 1.339  2009/12/03 14:33:01  lulin
 {RequestLink:172986031}.

 Revision 1.338  2009/11/16 18:59:27  lulin
 {ReqestLink:159360578}. №58.

 Revision 1.337  2009/10/29 14:35:47  lulin
 - вторая волна компании по борьбе со старыми внутренними операциями.

 Revision 1.336  2009/10/26 09:23:55  oman
 - fix: {RequestLink:121160631}

 Revision 1.335  2009/10/16 13:26:54  oman
 - new: Переносим на модель {RequestLink:164596503}

 Revision 1.334  2009/10/15 08:50:43  oman
 - new: Чистим устаревшие методы доступа {RequestLink:122652464}

 Revision 1.333  2009/10/12 11:27:29  lulin
 - коммитим после падения CVS.

 Revision 1.333  2009/10/08 12:26:08  lulin
 - добавляем ссылку на поиск "СМИ по налогам и бухучёту".

 Revision 1.332  2009/09/18 12:21:37  lulin
 - невоплощённое убиваем, ошмётки переносим на модель.

 Revision 1.331  2009/09/15 10:09:09  lulin
 - избавляемся от операций модуля и ссылок на класс форм.

 Revision 1.330  2009/09/03 18:49:13  lulin
 - реструктуризируем поиски и удаляем ненужное.

 Revision 1.329  2009/09/03 13:26:17  lulin
 - делаем прецеденты более изолированными друг от друга.

 Revision 1.328  2009/08/14 14:57:53  lulin
 {RequestLink:129240934}. №42.

 Revision 1.327  2009/08/14 11:31:30  oman
 - fix:  {RequestLink:159356254}

 Revision 1.326  2009/08/14 11:14:38  oman
 - fix:  {RequestLink:159356254}

 Revision 1.325  2009/07/31 17:30:07  lulin
 - убираем мусор.

 Revision 1.324  2009/04/01 06:43:30  oman
 - fix: Недоубили использование

 Revision 1.323  2009/02/20 10:12:57  lulin
 - чистка комментариев.

 Revision 1.322  2009/02/10 19:04:03  lulin
 - <K>: 133891247. Вычищаем морально устаревший модуль.

 Revision 1.321  2009/02/09 19:17:30  lulin
 - <K>: 133891247. Выделяем интерфейсы поиска.

 Revision 1.320  2009/01/12 15:58:38  lulin
 - <K>: 133138664. № 22.

 Revision 1.319  2009/01/11 10:44:22  lulin
 - <K>: 134709278. Пытаемся выживать в сложных условиях.

 Revision 1.318  2008/12/29 16:41:04  lulin
 - <K>: 134316705.

 Revision 1.317  2008/12/25 12:20:19  lulin
 - <K>: 121153186.

 Revision 1.316  2008/12/08 09:33:27  lulin
 - <K>: 128292941.

 Revision 1.315  2008/11/07 09:38:54  oman
 - fix: Недоизжили IvcmDataReset (К-121157455)

 Revision 1.314  2008/11/06 09:56:31  lulin
 - <K>: 121167188.

 Revision 1.313  2008/10/30 15:09:22  lulin
 - <K>: 121159648.

 Revision 1.312  2008/10/24 17:29:57  lulin
 - чистка кода.

 Revision 1.311  2008/09/19 14:55:22  lulin
 - удалён ненужный модуль.

 Revision 1.310  2008/09/19 10:55:06  oman
 - fix: Неверно сравнивали контекст с ошибками (К-118394016)

 Revision 1.309  2008/09/16 07:05:40  oman
 - fix: Выясненяем неисправимый контекст другим макаром (К-117604398)

 Revision 1.308  2008/08/20 11:33:26  lulin
 - <K>: 96483355.

 Revision 1.307  2008/08/14 11:00:46  oman
 - fix: Мягче зачищаем фильтр (K-108627041)

 Revision 1.306  2008/08/11 08:57:02  lulin
 - <K>: 96483518.

 Revision 1.305  2008/08/01 07:16:03  oman
 - fix: Нельзя вставлять в свернутую группу (K-105251120)

 Revision 1.304  2008/07/24 12:55:38  oman
 К-104432064

 Revision 1.303  2008/07/22 11:22:15  oman
 - new: Отключение пищалки - КЗ (К-103940886)

 Revision 1.302  2008/07/16 12:43:05  oman
 - new: Фильтр на инфоблоки (К-97846369)

 Revision 1.301  2008/07/07 14:27:14  lulin
 - подготавливаемся к переименованию.

 Revision 1.300  2008/07/04 05:39:14  oman
 - new: Отключаем подсказки для инфарма (К-96484656)

 Revision 1.299  2008/07/03 07:50:15  oman
 - new: Заготовочные изменения интерфейсов (К-96484656)

 Revision 1.298  2008/06/25 10:37:36  lulin
 - <K>: 95487937.

 Revision 1.297  2008/06/20 14:48:44  lulin
 - используем префиксы элементов.

 Revision 1.296  2008/06/20 13:55:34  lulin
 - используем префиксы элементов.

 Revision 1.295  2008/06/19 13:46:13  oman
 - fix: Контекст проверяем только в контекстных полях (cq29412)

 Revision 1.294  2008/06/19 13:25:41  oman
 - fix: Бросали исключение в неправильном месте (cq29406)

 Revision 1.293  2008/06/18 13:27:53  oman
 - fix: Пытаемся сбрасывать успешно найденную опечатку (cq29204)

 Revision 1.292  2008/06/18 13:09:05  oman
 - fix: Проверяем морфологию по всем атрибутам (cq29204)

 Revision 1.291  2008/06/18 11:20:12  oman
 - fix: Пользуем более правильное исключение (cq29204)

 Revision 1.290  2008/06/18 10:43:10  oman
 - new: Переделка исправления опечаток (cq29204)

 Revision 1.289  2008/06/17 13:26:27  oman
 - new: Для информа корректируем контекст по особому (cq29273)

 Revision 1.288  2008/06/09 11:39:50  demon
 - new: функция ISearch.CorrectContext получила дополнительный параметр - для Инфарм или нет

 Revision 1.287  2008/05/27 09:04:26  lulin
 - удалена старая проверка валидности контекста.

 Revision 1.286  2008/05/27 08:54:06  lulin
 - <CQ>: 29024.

 Revision 1.285  2008/05/16 10:57:21  lulin
 - переименованы константы.

 Revision 1.284  2008/05/08 16:11:09  lulin
 - изменения в рамках <K>: 90442475.

 Revision 1.283  2008/05/08 06:13:32  oman
 - Не собирались

 Revision 1.282  2008/04/14 13:43:54  lulin
 - <K>: 89096854.

 Revision 1.281  2008/03/19 12:45:37  oman
 - fix: Не падаем в случае отсутствия значений

 Revision 1.280  2008/03/04 19:54:50  lulin
 - <K>: 86114496.

 Revision 1.279  2008/02/14 17:08:49  lulin
 - cleanup.

 Revision 1.278  2008/02/12 14:39:57  lulin
 - методы для чтения списка переехали на примесь.

 Revision 1.277  2008/01/31 13:29:57  oman
 - new: Поддержка _TrimLeafFilter (cq14053)

 Revision 1.276  2008/01/22 13:59:55  oman
 - new: TrimFilter для ОИЗ (cq14053)

 Revision 1.275  2008/01/10 07:23:08  oman
 Переход на новый адаптер

 Revision 1.273.2.3  2007/12/21 09:45:43  mmorozov
 - MERGE WITH HEAD;

 Revision 1.273.2.2  2007/11/26 09:04:10  oman
 Перепиливаем на новый адаптер

 Revision 1.273.2.1  2007/11/21 15:07:46  oman
 Перепиливаем на новый адаптер

 Revision 1.274  2007/12/21 07:12:12  mmorozov
 - new: подписка на уведомление об обновлении данных (CQ: OIT5-27823);

 Revision 1.273  2007/11/01 13:15:51  oman
 - fix: Более корректно очищаем для мониторингов - излишне
  зачищалась название

 Revision 1.272  2007/10/19 09:23:39  oman
 - fix: При разборе контекста выдаем сообщение - более
  структурный вариант (К-57051004)

 Revision 1.271  2007/10/08 07:54:14  oman
 - fix: При выборе из карточки атрибута переполучаем его. Т.к. на
  переключнии баз он становиться невалиндным (cq26951)
 - fix: При выборе из карточки атрибута ставим в него фокус. Т.к. на
  переключнии баз он теряется.

 Revision 1.270  2007/09/19 13:27:13  lulin
 - bug fix: зачем-то ставили фокус в очищаемый атрибут - в результате КЗ открывалась с курсором на строчке "Да".

 Revision 1.269  2007/09/11 16:43:23  lulin
 - bug fix: не запускался Прайм (CQ OIT5-26654).

 Revision 1.268  2007/09/10 14:19:59  lulin
 - bug fix: падала КЗ ППР при переключении баз (CQ OIT5-26548).

 Revision 1.267  2007/08/22 11:17:25  oman
 - fix: Убираем AT_TEXT_OPT (cq25394)

 Revision 1.266  2007/08/14 14:29:57  lulin
 - оптимизируем перемещение блоков памяти.

 Revision 1.265  2007/08/01 10:38:34  oman
 - new: Выделяем процедуру проверки контекста на распознаваемость

 Revision 1.264  2007/07/18 15:07:04  lulin
 - выпрямляем зависимости. Схема документа, теперь не зависит от Эвереста.

 Revision 1.263  2007/06/28 12:57:27  lulin
 - cleanup.

 Revision 1.262  2007/06/20 14:58:24  lulin
 - переделана загрузка значения по умолчанию (<K>-13240526).

 Revision 1.261  2007/06/20 12:45:29  lulin
 - удалены ненужные параметры (<K>-20219481).

 Revision 1.260  2007/06/20 12:06:10  lulin
 - вычищены ненужные методы (<K>-20219395).

 Revision 1.259  2007/06/19 12:01:48  lulin
 - удалены ненужные параметры (<K>-20218355).

 Revision 1.258  2007/06/19 10:32:01  lulin
 - удален ненужный метод (<K>-18677829).

 Revision 1.257  2007/06/19 08:42:29  lulin
 - заполненность поля с датой проверяем особенным образом (<K>-20218207).

 Revision 1.256  2007/06/19 08:10:24  lulin
 - выделен метод проверки заполненности хотя бы одного из полей атрибута. В рамках <K>-18677820.

 Revision 1.255  2007/06/19 08:00:03  lulin
 - переносим получение списка доступных операция с утилитного класса на класс-параграф над нодой (<K>-20218184).

 Revision 1.254  2007/06/18 15:01:55  lulin
 - удален ненужный метод (<K>-20218066).

 Revision 1.253  2007/06/18 13:32:45  lulin
 - удален ненужный и крайне непрозрачный метод (<K>-20217991).

 Revision 1.252  2007/06/18 12:48:16  lulin
 - удален ненужный метод (<K>-20217944).

 Revision 1.251  2007/06/18 10:43:04  lulin
 - обобщаем код (<K>-20217891).

 Revision 1.250  2007/06/18 10:28:26  lulin
 - обобщаем код (<K>-20217886).

 Revision 1.249  2007/06/18 10:21:23  lulin
 - обобщаем код (<K>-18677820).

 Revision 1.248  2007/06/18 09:28:07  lulin
 - обобщаем код (<K>-19759427).

 Revision 1.247  2007/06/15 12:44:18  lulin
 - переименован метод - для читабельности (<K>-19759257).

 Revision 1.246  2007/06/15 11:15:22  lulin
 - метод обработки ESC переехал на более подходящий интерфейс (<K>-14516868).

 Revision 1.245  2007/06/14 16:50:04  lulin
 - cleanup.

 Revision 1.244  2007/06/14 16:46:11  lulin
 - избавляемся от лишней рекурсии (<K>-15368270).

 Revision 1.243  2007/06/14 09:18:52  lulin
 - убрана ненужная проверка (<K>-18677938).

 Revision 1.242  2007/06/14 08:56:31  lulin
 - убрано ненужное свойство (<K>-18677883).

 Revision 1.241  2007/06/14 07:40:18  lulin
 - теперь в метод проверки того заполнено поле или нет подается базовый контрол (<K>-18677854).

 Revision 1.240  2007/06/13 17:59:20  lulin
 - cleanup.

 Revision 1.239  2007/06/13 17:40:58  lulin
 - унифицируем код (<K>-18677824).

 Revision 1.238  2007/06/13 17:18:22  lulin
 - метод переехал в общую библиотеку (<K>-18677805).

 Revision 1.237  2007/06/13 16:55:46  lulin
 - переименовываем метод (<K>-18677801).

 Revision 1.236  2007/06/13 16:39:21  lulin
 - удален ненужный метод (<K>-18677793).

 Revision 1.235  2007/06/13 15:44:28  lulin
 - cleanup.

 Revision 1.234  2007/06/13 15:13:57  lulin
 - метод переименован в соответствии с тем, что он делает (<K>-18219651).

 Revision 1.233  2007/06/13 14:12:12  lulin
 - удален ненужный интерфейс (<K>-18219558).

 Revision 1.232  2007/06/13 13:51:04  lulin
 - метод переехал с интерфейса в глобальную область (<K>-18219517).

 Revision 1.231  2007/06/13 13:32:13  lulin
 - cleanup.

 Revision 1.230  2007/06/09 12:30:46  lulin
 - восстановлена загрузка нод по умолчанию (<K>-14516759).

 Revision 1.229  2007/06/08 15:01:11  lulin
 - реквизит теперь сам загружает значение ноды по-умолчанию, а не через утилитный класс. Контролу текст и нода пока не передаются. В рамках <K>-14516759.

 Revision 1.228  2007/06/07 12:47:10  lulin
 - убраны ненужные локальные переменные, в рамках <K>-17334761.

 Revision 1.227  2007/06/06 14:23:33  lulin
 - получаем дерево напрямую, а не через реквизит.

 Revision 1.226  2007/06/06 14:02:34  lulin
 - cleanup.

 Revision 1.225  2007/06/06 13:44:02  lulin
 - перенес получение дерева на более подходящий объект (<K>-16352466).

 Revision 1.224  2007/06/06 13:25:29  lulin
 - выделяем метод определения фильтра. В рамках <K>-16352466.

 Revision 1.223  2007/06/06 13:07:33  lulin
 - избавился от полиморфности метода получения дерева (<K>-16352476).

 Revision 1.222  2007/06/06 12:19:02  lulin
 - перенес историю контекста на более подходящий объект (<K>-14516869).

 Revision 1.221  2007/06/06 11:57:43  lulin
 - (!) Коментарий неверен, см. комментарий выше (!) избавляемся от вредоносного параметра по-умолчанию (<K>-16352239). 

 Revision 1.220  2007/06/06 10:46:20  lulin
 - убрал сброс флажка модифицированности из метода загрузки реквизита (<K>-16352110).

 Revision 1.219  2007/06/05 08:05:22  lulin
 - bug fix: в поле даты не вбивался текст (CQ OIT5-25529, <K>-15958376).

 Revision 1.218  2007/06/04 08:23:15  lulin
 - вычищен ненужный метод (<K>-15663181).

 Revision 1.217  2007/06/04 08:12:53  lulin
 - вычищен ненужный тег (<K>-15663142).

 Revision 1.216  2007/06/01 10:38:02  lulin
 - восстановил загрузку текста атрибута по-умолчанию (<K>-14516770).

 Revision 1.215  2007/06/01 07:35:10  lulin
 - в нулевом приближении восстановил закгрузку текста атрибута по-умолчанию (<K>-14516770).

 Revision 1.214  2007/06/01 06:38:27  lulin
 - вычищено ненужное свойство (<K>-13239053).

 Revision 1.213  2007/06/01 06:32:18  lulin
 - cleanup.

 Revision 1.212  2007/06/01 06:25:26  lulin
 - cleanup.

 Revision 1.211  2007/05/31 13:09:01  lulin
 - cleanup.

 Revision 1.210  2007/05/31 13:01:46  lulin
 - вычистил ненужный метод (<K>-14516874).

 Revision 1.209  2007/05/31 12:18:39  lulin
 - вычистил ненужный метод (<K>-14516876).

 Revision 1.208  2007/05/31 06:39:58  lulin
 - вычищены ненужные методы (<K>-14516757).

 Revision 1.207  2007/05/31 06:13:28  lulin
 - убран вызов метода, который приводил к бесконечной рекурсии (для восстановления см. <K>-14516759).

 Revision 1.206  2007/05/31 06:06:13  lulin
 - cleanup.

 Revision 1.205  2007/05/30 18:01:23  lulin
 - вчерне выкинуто хранение реквизитов в списке (<K>-14516571).

 Revision 1.204  2007/05/30 16:21:52  lulin
 - добавлен метод итерирования атрибутов без их хранения с списке - пока не использется (<K>-14516706).

 Revision 1.203  2007/05/30 15:33:41  lulin
 - правим форматирование.

 Revision 1.202  2007/05/30 15:30:57  lulin
 - сосредотачиваем логику на менеджере поиска (<K)-14516571).

 Revision 1.201  2007/05/30 14:18:45  lulin
 - с менеджера поиска вычищено ненужное свойство (<K>-14516583).

 Revision 1.200  2007/05/30 13:19:00  lulin
 - убрал из реквизита хранение ссылки на объект модели (<K>-14516447).

 Revision 1.199  2007/05/30 11:41:14  lulin
 - вычищено поле, мешающее классы стать утилитным (<K>-14516416).

 Revision 1.198  2007/05/30 10:49:06  lulin
 - вычищаем признак модифицированности атрибута из утилитного класса, перекладываем его в тег (<K>-13239999).

 Revision 1.197  2007/05/30 10:28:02  lulin
 - вычищен ненужный параметр (<K>-14516397).

 Revision 1.196  2007/05/30 10:09:45  lulin
 - ненужный код убран под директивы компиляции.

 Revision 1.195  2007/05/30 09:51:12  lulin
 - optimization: получаем список операций только если его не получали.

 Revision 1.194  2007/05/30 09:41:59  lulin
 - вычищено хранение списка доступных операций с утилитного класса, теперь операции хранятся в теге (<K>-13239724).

 Revision 1.193  2007/05/30 09:18:00  lulin
 - избавляемся от хранения полей, из которых формируется поле "Тема" (<K>-14516317).
 - избавляемся от ссылки на поле "Тема" (<K>-13240375).

 Revision 1.192  2007/05/30 08:16:24  lulin
 - избавился от хранения вычисляемого атрибута (<K>-14516310).

 Revision 1.191  2007/05/30 07:39:20  lulin
 - теперь при изменении признака модифицированности атрибута меняется признак модифицированности карточки (<K>-14516282).

 Revision 1.190  2007/05/30 07:07:53  lulin
 - со списка реквизитов вычищен признак модифицированности (<K>-13239064).
 - переупорядочен код.

 Revision 1.189  2007/05/30 06:29:28  lulin
 - определение типа создаваемого класса атрибута перенесено в фабричную функцию (<K>-14516258).

 Revision 1.188  2007/05/29 12:09:19  lulin
 - прячем неиспользуемое поле.

 Revision 1.187  2007/05/29 12:01:25  lulin
 - вычищено хранение признака модифицированности с утилитного класса (<K>-13795407).

 Revision 1.186  2007/05/29 09:50:12  lulin
 - убран ненужный метод интерфейса (<K>-13795334).

 Revision 1.185  2007/05/29 09:34:57  lulin
 - удалено хранение вычисляемого атрибута (<K>-13239062).

 Revision 1.184  2007/05/29 08:10:14  lulin
 - вычистил ненужный метод интерфейса (<K>-13240506).
 - вычищено ненужное поле "атрибута" (<K>-13240502).

 Revision 1.183  2007/05/29 07:32:32  lulin
 - вычистил ненужный параметр (<K>-13240520).

 Revision 1.182  2007/05/29 07:11:29  lulin
 - переименовал методы - чтобы не путаться (<K>-13239997).

 Revision 1.181  2007/05/29 05:44:30  lulin
 - правильнее выделяем защищенный код.

 Revision 1.180  2007/05/28 15:33:04  lulin
 - спрятан ненужный метод.

 Revision 1.179  2007/05/28 14:33:01  lulin
 - вычищен невостребованный метод (<K>-13239036).

 Revision 1.178  2007/05/28 14:00:45  lulin
 - с интерфейса вычищен ненужный метод (<K>-13240402).

 Revision 1.177  2007/05/28 12:58:28  lulin
 - вычищена возможность чтения свойства (<K>-13240379).

 Revision 1.176  2007/05/28 11:44:41  lulin
 - вычистил с интерфейса ненужный метод (<K>-13240319).

 Revision 1.175  2007/05/28 10:51:36  lulin
 - bug fix: неправильно вычислялся список доступных операций (CQ OIT5-25435).

 Revision 1.174  2007/05/25 14:59:40  lulin
 - не вычисляем фильтр, если он не нужен.

 Revision 1.173  2007/05/25 12:54:00  lulin
 - передаем не имя атрибута, а сам атрибут - чтобы лишний раз не искать его.

 Revision 1.172  2007/05/25 10:48:16  lulin
 - cleanup.

 Revision 1.171  2007/05/25 07:38:46  lulin
 - вычистил ненужное хранимое значение (<K>-13239753).

 Revision 1.170  2007/05/24 14:06:47  lulin
 - избавляемся от ненужной локальной переменной.

 Revision 1.169  2007/05/24 14:01:37  lulin
 - не получаем операцию два раза.

 Revision 1.168  2007/05/24 13:40:56  lulin
 - cleanup.

 Revision 1.167  2007/05/23 15:46:40  lulin
 - переименовываем метод прятанья выпавшего контрола в соответствии с тем, что он делает (<K>-13239271).

 Revision 1.166  2007/05/23 12:45:45  lulin
 - вычистил кеширование вычисляемого значения (K-13239075).

 Revision 1.165  2007/05/23 10:28:52  lulin
 - вычищено кеширование вычисляемого значения.

 Revision 1.164  2007/05/23 06:56:49  lulin
 - cleanup.

 Revision 1.163  2007/05/23 06:44:16  lulin
 - вычищено ненужное свойство атрибута _NumList_.

 Revision 1.162  2007/05/22 12:44:58  lulin
 - вычищено дублированное хранение множественности атрибута.

 Revision 1.161  2007/05/22 12:00:41  lulin
 - вычищено дублированное хранение имени атрибута.

 Revision 1.160  2007/05/22 11:11:52  lulin
 - изменен тип имени контрола.

 Revision 1.159  2007/05/22 08:15:27  lulin
 - вычищен мусор.

 Revision 1.158  2007/05/22 07:36:02  lulin
 - убрано лишнее хранение текста атрибута.

 Revision 1.157  2007/05/22 07:24:50  lulin
 - неиспользуемый код убран под директиву условной компиляции.

 Revision 1.156  2007/05/22 07:14:13  lulin
 - изменен тип заголовка контрола.

 Revision 1.155  2007/05/22 07:02:53  lulin
 - cleanup.

 Revision 1.154  2007/05/21 14:25:37  lulin
 - сразу инициализируем реквизит необходимым значением, а не устанавливаем его потом.

 Revision 1.153  2007/05/21 14:11:05  lulin
 - удалено ненужное свойство интерфейса.

 Revision 1.152  2007/05/18 15:45:26  lulin
 - забыли модификатор константности.

 Revision 1.151  2007/05/18 13:55:11  lulin
 - убрано сложное приведение к интерфейсу.

 Revision 1.150  2007/05/17 14:04:25  lulin
 - избавляем список атрибутов от знаний о менеджере.

 Revision 1.149  2007/05/17 12:29:53  lulin
 - вычищаем код, до которого не доходило дело.

 Revision 1.148  2007/05/17 11:08:36  oman
 cleanup

 Revision 1.147  2007/05/16 15:32:43  lulin
 - вычищаем ненужную функциональность.

 Revision 1.146  2007/05/16 14:36:08  oman
 Читаем историю контекста из единого места

 Revision 1.145  2007/05/16 14:04:08  oman
 Cleanup

 Revision 1.144  2007/05/16 13:54:32  oman
 Cleanup

 Revision 1.143  2007/05/16 13:25:36  oman
 - fix: История контекстов сохраняется в одни ворота (InsContextFindNotifier) (cq25145)

 Revision 1.142  2007/05/16 11:40:02  oman
 - new: Логика сохранения истории запросов (cq25145)

 Revision 1.141  2007/04/09 10:53:49  lulin
 - cleanup.

 Revision 1.140  2007/04/05 14:57:50  oman
 - fix: Не собирались мониторинги

 Revision 1.139  2007/04/05 14:10:23  lulin
 - избавляемся от лишних преобразований строк.

 Revision 1.138  2007/04/05 13:42:52  lulin
 - избавляемся от лишних преобразований строк.

 Revision 1.137  2007/04/05 12:20:56  lulin
 - cleanup.

 Revision 1.136  2007/04/05 11:16:50  lulin
 - cleanup.

 Revision 1.135  2007/04/05 07:58:27  lulin
 - избавляемся от лишних преобразований строк при записи в настройки.

 Revision 1.134  2007/04/05 06:39:23  lulin
 - избавляемся от лишних преобразований строк.

 Revision 1.133  2007/03/30 09:12:11  oman
 - fix: Устанавливаем дополнительные фильтры и на выпадающий
  список, а не только на карточку атрибутов (cq24456)

 Revision 1.132  2007/03/29 13:18:58  oman
 Вычитываем таки параметры контекстного фильтра для атрибутов

 Revision 1.131  2007/03/28 14:51:21  oman
 - new: Избавляемся от ContextParams в КЗ (cq24456)

 Revision 1.130  2007/03/28 08:39:45  oman
 cleanup

 Revision 1.129  2007/03/27 12:43:17  oman
 Пользуем родные деревья для атрибутов

 Revision 1.128  2007/03/27 11:59:34  oman
 Переводим тэг атрибутов на константную строку

 Revision 1.127  2007/03/19 12:08:52  lulin
 - используем свою функцию форматирования.

 Revision 1.126  2007/03/19 11:35:29  lulin
 - разделяем приведение к строке для форматирования и для исключения.

 Revision 1.125  2007/03/16 16:57:16  lulin
 - избавляемся от излишнего копирования и преобразования строк.

 Revision 1.124  2007/03/14 16:41:47  lulin
 - cleanup.

 Revision 1.123  2007/03/14 16:28:08  lulin
 - cleanup.

 Revision 1.122  2007/03/14 15:51:20  lulin
 - cleanup.

 Revision 1.121  2007/03/14 15:46:06  lulin
 - cleanup.

 Revision 1.120  2007/03/14 15:36:48  lulin
 - cleanup.

 Revision 1.119  2007/03/06 10:13:48  oman
 Cleanup - убран мусорный параметр

 Revision 1.118  2007/03/06 08:17:59  oman
 Cleanup

 Revision 1.117  2007/03/06 08:14:19  oman
 Cleanup - убрано мусорное свойство ContextFilterType

 Revision 1.116  2007/03/05 14:22:20  oman
 - fix: Неверно определяли поле для удаления (cq24549)

 Revision 1.115  2007/02/27 13:39:11  lulin
 - cleanup.

 Revision 1.114  2007/02/16 18:06:14  lulin
 - избавляемся от стандартного строкового типа.

 Revision 1.113  2007/02/16 15:16:53  lulin
 - cleanup.

 Revision 1.112  2007/02/16 14:53:09  lulin
 - избавляемся от использования стандартных строк.

 Revision 1.111  2007/02/14 17:49:30  lulin
 - избавляемся от использования стандартных строк.

 Revision 1.110  2007/02/14 17:04:59  lulin
 - избавляемся от использования стандартных строк.

 Revision 1.109  2007/02/14 16:51:00  lulin
 - избавляемся от использования стандартных строк.

 Revision 1.108  2007/02/14 16:13:54  lulin
 - переводим на строки с кодировкой.

 Revision 1.107  2007/02/14 14:24:20  lulin
 - переводим на строки с кодировкой.

 Revision 1.106  2007/02/13 14:33:32  lulin
 - cleanup.

 Revision 1.105  2007/02/13 09:33:52  lulin
 - переводим на строки с кодировкой.

 Revision 1.104  2007/02/12 19:35:56  lulin
 - переводим на строки с кодировкой.

 Revision 1.103  2007/02/12 17:15:54  lulin
 - переводим на строки с кодировкой.

 Revision 1.102  2007/02/12 09:58:51  lulin
 - bug fix: искажались входные строковые параметры адаптера.

 Revision 1.101  2007/02/09 12:58:29  lulin
 - выделена функция преобразования к входной строке адаптера.

 Revision 1.100  2007/02/07 17:48:54  lulin
 - избавляемся от копирования строк при чтении из настроек.

 Revision 1.99  2007/02/07 14:47:35  lulin
 - переводим на строки с кодировкой.

 Revision 1.98  2007/02/07 12:45:11  lulin
 - переводим на строки с кодировкой.

 Revision 1.97  2007/02/05 09:40:13  lulin
 - две функции объединены в одну.

 Revision 1.96  2007/02/05 09:07:26  lulin
 - bug fix: не собирались мониторинги.

 Revision 1.95  2007/02/02 13:23:58  lulin
 - упрощаем преобразование строк.

 Revision 1.94  2007/02/02 12:25:44  lulin
 - переводим на строки с кодировкой.

 Revision 1.93  2007/02/02 09:10:50  lulin
 - упрощаем преобразование строк.

 Revision 1.92  2007/02/02 08:39:25  lulin
 - переводим на строки с кодировкой.

 Revision 1.91  2007/01/26 14:34:23  lulin
 - поправил обращение к неправильному параметру.

 Revision 1.90  2007/01/20 15:30:33  lulin
 - разделяем параметры операции для выполнения и для тестирования.

 Revision 1.89  2006/12/01 15:20:35  mmorozov
 - new: информация о локали выделана в отдельный интерфейс;

 Revision 1.88  2006/11/28 15:35:29  mmorozov
 - опубликован идентификатор языка приложения IafwApplication.LocateId: LCID;
 - существовавшее свойство LocateId переименовано в DetailedLanguageId;
 - после чтения строкового идентфикатора языка приложения проверяем его на допустимость;
 - формируем идентфикаторы языков приложения по первому требованию;
 - при определении языка прилоежния используем идентфикаторы опубликованные в afwInterfaces;

 Revision 1.87  2006/11/20 12:12:10  oman
 Merge from B_NEMESIS_6_4

 Revision 1.86  2006/11/10 16:00:02  oman
 Merge from B_NEMESIS_6_4

 Revision 1.85  2006/11/07 14:28:30  oman
 Merge from B_NEMESIS_6_4

 Revision 1.84  2006/11/03 09:46:21  oman
 Merge with B_NEMESIS_6_4_0

 Revision 1.83.2.4.2.3  2006/11/20 12:06:11  oman
 - fix: В сообщении не выводилось значение поля (cq23690)

 Revision 1.83.2.4.2.2  2006/11/10 10:05:55  oman
 Убран ненужный метод

 Revision 1.83.2.4.2.1  2006/11/07 14:23:19  oman
 - fix: При укладке в кэш не чистились атрибуты (cq23452)

 Revision 1.83.2.4  2006/10/25 07:29:39  oman
 Продолжаем избавлятся от StdStr

 Revision 1.83.2.3  2006/10/25 06:49:57  oman
 - fix: Более гуманная зачистка перед поиском (cq23205, 23114)

 Revision 1.83.2.2  2006/10/24 09:46:54  oman
 - fix: В КЗ при возврате по истории оставались мусорные поля
  - теперь пустые поля удаляются _перед_ сохранением (cq23114)

 Revision 1.83.2.1  2006/10/24 09:43:54  oman
 no message

 Revision 1.83  2006/10/04 11:01:43  oman
 - fix: При выборе из карточки атрибутов не сбрасывалось выделение

 Revision 1.82  2006/09/28 15:03:31  oman
 - new: Выделена функция починяющая контекст при вставке
  из клипборда (cq22776)

 Revision 1.81  2006/09/27 13:42:15  mmorozov
 В рамках работы над CQ: OIT500022679.

 - remove: TTagSearch, TTagSearchList, TAvailableTags. В списки были не работоспособны, в единственном месте где списки использовались, можно было обойтись _IAttributeInfo;
 - remove: неиспользуемые операции в enSelectedAttributesForm (enSelectedList: opAdd, opDelete, opChangeOperation);
 - new: TnsTaggedTreeInfo наделен логикой;

 Revision 1.80  2006/09/18 11:33:40  oman
 -new: для КЗ ПП сохраняем ФИО и телефон послу успешной посылки
  в настройки и восстанавливаем их при открытии (cq22612)

 Revision 1.79  2006/09/18 09:08:41  oman
 - fix: Корректная проверка правильности ввода
 - fix: Корректное ограничение на длину полей
 cleanup (ненужные операции/сообщения/проверки)

 Revision 1.78  2006/09/14 14:16:27  oman
 - new: Изменения в КЗ ПП (cq22535)

 Revision 1.77  2006/09/11 14:02:16  oman
 - new: Схлопывание подсказки в ППР (cq21474)
 - fix: Более корректная работа с гиперссылками в КЗ.

 Revision 1.76  2006/07/18 09:59:24  oman
 - fix: При работе с карточкой атрибута неверно обновлялось
  название в мониторингах (cq21909)

 Revision 1.75  2006/07/12 15:03:08  oman
 - new beh: Формирование заголовка для новостной ленты другим макаром (cq21699)

 Revision 1.74  2006/07/10 08:04:40  oman
 - new beh: В карточке выбора даты подставляем заголовок от
  редактируемого атрибута (cq21733)

 Revision 1.73  2006/07/05 10:00:12  oman
 - new beh: При вставке в контекст из клипборда убираем нераспознаваемые символы (cq21628)

 Revision 1.72  2006/06/29 11:56:13  mmorozov
 - change: изменения в связи с поялением типа GblAdapter.TDateTime;

 Revision 1.71  2006/06/29 10:29:36  mmorozov
 - new behaviour: перед вставкой элемента в список анализируем его на предмет сортированности (CQ: OIT500021526);

 Revision 1.70  2006/06/21 09:09:44  dinishev
 Дополнительная проверка дат перед вызовом диалога

 Revision 1.69  2006/06/16 09:23:48  oman
 - fix: Отсутствовал признак посланности консультации для истории -
 не все учел... (cq21330)

 Revision 1.68  2006/06/16 07:45:41  oman
 - fix: В карточку выбора дат отдавался реквизит, который после
  переключения баз становился дохлым => имели AV (cq21336)

 Revision 1.67  2006/06/15 08:35:48  oman
 - fix: Отсутствовал признак посланности консультации для истории (cq21330)

 Revision 1.66  2006/06/09 12:24:09  dinishev
 Bug fix: не компилировались мониторинги

 Revision 1.65  2006/06/09 08:44:38  dinishev
 Использование одной операции для кнопок видимости кнопок и добавления текста

 Revision 1.64  2006/06/08 14:41:49  dinishev
 Bug fix: сохранялись данные для откакти при заполнении КЗ значениями по умолчнанию или загруженными значениями

 Revision 1.63  2006/05/23 16:09:06  dinishev
 Cleanup

 Revision 1.62  2006/05/19 11:06:04  dinishev
 Cleanup

 Revision 1.61  2006/04/24 08:58:11  dinishev
 Отъехало очищение логического значения для реквизита

 Revision 1.60  2006/04/21 12:44:32  dinishev
 new constansts

 Revision 1.59  2006/04/21 12:12:15  dinishev
 Bug fix: была возможность сохранить запрос в утилите заказа рассылки с пустым именем

 Revision 1.58  2006/04/20 08:53:53  oman
 - new beh: перекладываем StdStr в _StdRes

 Revision 1.57  2006/04/19 13:34:22  oman
 - new beh: перекладываем StdStr в _StdRes

 Revision 1.56  2006/04/19 09:08:03  dinishev
 Cleanup

 Revision 1.55  2006/04/18 14:06:55  oman
 - new beh: перекладываем StdStr в _StdRes

 Revision 1.54  2006/04/17 14:42:38  oman
 - new beh: перекладываем StdStr в _StdRes

 Revision 1.53  2006/04/14 13:23:08  dinishev
 Cleanup

 Revision 1.52  2006/04/13 17:07:21  lulin
 - падали при неприсвоенной карточке.

 Revision 1.51  2006/04/11 14:16:05  dinishev
 Более правильная установка курсора после ошибки

 Revision 1.50  2006/04/10 14:38:53  dinishev
 Bug fix: отъехала выдача сообщений о пустых полях в тулзе заказа рассылки

 Revision 1.49  2006/04/07 08:46:21  mmorozov
 - add: _NeedSettings для запроса на консультацию не нужен;

 Revision 1.48  2006/04/07 08:25:24  mmorozov
 - приведение к общему знаменателю Поиска с правовой поддержкой, Запроса на консультацию, Консультации;

 Revision 1.47  2006/04/03 16:26:18  dinishev
 Не компилировалось

 Revision 1.46  2006/04/03 15:56:14  dinishev
 _CleanUp

 Revision 1.45  2006/03/31 07:42:34  lulin
 - изменен тип параметров, подаваемый в Execte операции.

 Revision 1.44  2006/03/27 13:35:35  lulin
 - cleanup.

 Revision 1.43  2006/03/22 08:41:54  oman
 - new beh: Перекладываем все текстовые константы в три места (StdStr, DebugStr и SystemStr)

 Revision 1.42  2006/03/20 15:11:00  dinishev
 Bug fix: не сохранялся запрос в историю

 Revision 1.41  2006/03/20 09:27:50  oman
 - new beh: Перекладываем все текстовые константы в три места (StdStr, DebugStr и SystemStr)

 Revision 1.40  2006/03/17 14:31:51  dinishev
 Bug fix: List Index out of bounds при возврате по истории при символах разделителя в контексте.

 Revision 1.39  2006/03/16 15:24:31  dinishev
 Bug fix: при повторном вызове новой КЗ появлялось пустое окно

 Revision 1.38  2006/03/15 15:06:18  dinishev
 Корректная очиста многострочного поля

 Revision 1.37  2006/03/10 13:37:53  dinishev
 Подключение новой КЗ

 Revision 1.36  2006/03/07 10:35:03  mmorozov
 - warnings fix;

 Revision 1.35  2006/03/04 13:15:11  dinishev
 Более корректная установка курсора после очистки КЗ

 Revision 1.34  2006/03/02 14:45:34  dinishev
 Comment

 Revision 1.33  2006/03/02 14:15:20  dinishev
 Bug fix: в результате откатки не сбрасывался выбранный узел.

 Revision 1.32  2006/02/16 12:52:01  mmorozov
 - bugfix: после обновления при сбросе дерева не выключался контекстный фильтр (CQ: 17586) + интерфейс InscContextParams переехал в правильное место;

 Revision 1.31  2006/02/13 15:01:32  dinishev
 Коррекция поведения кнопки "Добавить"

 Revision 1.30  2006/02/07 11:07:11  dinishev
 Cleanup

 Revision 1.29  2006/02/06 17:02:19  dinishev
 Bug fix: при вызове операции "Удалить все" курсор ставился не в нужное место (CQ19357)

 Revision 1.28  2006/01/30 07:58:16  mmorozov
 bugfix: при открытии формы выбора атрибутов не передавались параметры контекстной фильтрации;

 Revision 1.27  2006/01/17 15:37:57  dinishev
 Bug fix: валились на обработке значения  вида "1, ,2"  в буфере.

 Revision 1.26  2006/01/16 17:32:09  dinishev
 Убрал сбрасываемость выделения красным неправильного значения

 Revision 1.25  2005/12/29 11:54:07  dinishev
 К сожалению, заплатка все еще нужна. Вернул вчерашнее изменения.

 Revision 1.24  2005/12/28 18:20:13  dinishev
 Bug fix: после обновления при возврате по истории приходила некорректная КЗ

 Revision 1.23  2005/12/27 11:36:43  dinishev
 Bug fix: не записываем дублирующие значения в историю ввода контекста

 Revision 1.22  2005/12/26 15:52:37  dinishev
 Выключена некорректно работающая проверка на дублирующие значения для полей конекста

 Revision 1.21  2005/12/23 15:45:45  dinishev
 Bug fix: в утилите заказа рассылки была возможность закрыть дерево, без подстановки значения и поле "Название" на это не среагирует

 Revision 1.20  2005/12/22 17:33:12  lulin
 - убрано предупреждение.

 Revision 1.19  2005/12/22 16:44:48  dinishev
 Bug fix: не очищалась КЗ после выбора из истории запросов

 Revision 1.18  2005/12/19 13:55:48  dinishev
 Bug fix: утечка памяти

 Revision 1.17  2005/12/14 15:56:26  dinishev
 Cleanup

 Revision 1.16  2005/12/13 16:20:48  dinishev
 Bug fix: не всегда корректно перерисовывалась КЗ после загрузке/возврате по истории

 Revision 1.15  2005/12/12 17:15:54  dinishev
 Bug fix: считывалась не вся история ввода контекста

 Revision 1.14  2005/12/08 18:13:45  dinishev
 Cleanup

 Revision 1.13  2005/12/07 18:08:54  dinishev
 Cleanup

 Revision 1.12  2005/12/06 06:56:48  dinishev
 no message

 Revision 1.11  2005/11/28 17:59:44  dinishev
 Bug fix: портилось поведение контекстных полей при возврате по истории

 Revision 1.10  2005/11/24 18:03:15  dinishev
 Bug fix: не всегда обновляли метку в первом поле

 Revision 1.9  2005/11/24 15:12:58  dinishev
 Cleanup

 Revision 1.8  2005/11/24 09:45:22  dinishev
 _CleanUp

 Revision 1.7  2005/11/23 17:08:56  dinishev
 Cleanup

 Revision 1.6  2005/11/23 08:59:17  dinishev
 Bug fix: корректное поведение кнопки "Добавить"

 Revision 1.5  2005/11/22 18:54:31  lulin
 - продолжаем пилить дерево на разные функциональные части.

 Revision 1.4  2005/11/21 09:06:23  dinishev
 Bug fix: текст в поле ввода мог выделяться красным, даже если было выбрано правильное значение.

 Revision 1.3  2005/11/18 16:40:10  dinishev
 Cleanup

 Revision 1.2  2005/11/17 13:22:39  dinishev
 Избавляемся от заплаток

 Revision 1.1  2005/11/17 05:46:17  dinishev
 _Move to directory 'Search'

 Revision 1.105  2005/11/15 12:41:10  dinishev
 Bug fix: неправильно выставлялся признак полей с номерами

 Revision 1.104  2005/11/14 14:24:36  dinishev
 Bug fix: корректная реакция на символ '*' в полях номера

 Revision 1.103  2005/11/11 20:23:17  dinishev
 Подсветка красным дублирующих значений в контекстных полях

 Revision 1.102  2005/11/10 15:54:18  dinishev
 Bug fix: после обновления загруженный запрос очищался.

 Revision 1.101  2005/11/09 18:45:26  dinishev
 Подправлено обновление

 Revision 1.100  2005/11/08 15:11:15  mmorozov
 bugfix: избавляемся от неосвобожденных объектов;

 Revision 1.99  2005/11/08 13:17:13  mmorozov
 bugfix: освобождаем память;

 Revision 1.98  2005/11/04 16:50:10  dinishev
 Нажатия Enter приводит к открытию окна выбора или запуску поиска (в зависимости от реквизита)

 Revision 1.97  2005/11/01 18:24:27  dinishev
 AV при попытке очистить КЗ при открытом дереве

 Revision 1.96  2005/10/31 17:25:25  dinishev
 no message

 Revision 1.95  2005/10/28 13:43:58  dinishev
 Bug fix: теперь вычищаем историю Undo после очистки КЗ

 Revision 1.94  2005/10/27 13:30:30  dinishev
 Bug fix: не обновлялось дерево, реквизита, для которого было открыто окно выбора.

 Revision 1.93  2005/10/27 11:11:06  dinishev
 Метод ChangeValues перенесен в другой класс

 Revision 1.92  2005/10/24 15:38:20  dinishev
 _CleanUp

 Revision 1.91  2005/10/22 11:41:55  dinishev
 Bug fix: могли быть не переинициализированы деревья при обновлении

 Revision 1.90  2005/10/21 16:35:22  dinishev
 Bug fix: не компилировались мониторинги

 Revision 1.89  2005/10/21 16:23:39  dinishev
 Clenup

 Revision 1.88  2005/10/21 14:54:24  dinishev
 Bug fix: сообщение об ошибке в дате

 Revision 1.87  2005/10/20 16:38:22  dinishev
 Обработка запятой и точки с запятой в контестных полях (вставка из буфера с добавлением полей)

 Revision 1.86  2005/10/20 15:03:56  dinishev
 добавлена возможность проверки для поля "Слова в названии"

 Revision 1.85  2005/10/19 16:50:24  dinishev
 Bug fix: не показывались хинты для кнопок

 Revision 1.84  2005/10/19 14:25:39  dinishev
 Bug fix: раскрытие панелей при загрузке

 Revision 1.83  2005/10/18 07:33:29  dinishev
 _CleanUp

 Revision 1.82  2005/10/14 13:32:29  dinishev
 _CleanUp

 Revision 1.81  2005/10/13 17:25:08  dinishev
 Попытка отвязать модель от редактора и привязать её к DocumentContainer

 Revision 1.80  2005/10/12 16:43:22  dinishev
 Предварительные изменения для корректной обработки события обновления

 Revision 1.79  2005/10/11 11:46:09  dinishev
 Bug fix: правильное выставление признака _Modified

 Revision 1.78  2005/10/11 09:39:29  dinishev
 Bug fix: кнопка "Удалить" у поля "Название" в F1Prime при загрузке была видима.

 Revision 1.77  2005/10/11 09:31:15  dinishev
 Bug fix: кнопка у поля "Название" в F1Prime просто очищала поле, не подставляя значение по умолчанию

 Revision 1.76  2005/10/06 17:48:52  dinishev
 Не копировалась история ввода во вторичные поля + не всегда срабатывало заполнение истрии

 Revision 1.75  2005/10/05 17:37:10  dinishev
 Контекстные меню

 Revision 1.74  2005/10/03 17:00:30  dinishev
 Bug fix: корректная загрузка операций по умолчанию

 Revision 1.73  2005/09/29 15:06:53  dinishev
 Подстветка красным дублирующих значений

 Revision 1.72  2005/09/29 11:26:22  dinishev
 Доработки работы с доступными операциями

 Revision 1.71  2005/09/29 08:17:51  dinishev
 Bug fix: не показывалась история запросов

 Revision 1.70  2005/09/27 16:25:16  dinishev
 Bug fix: при нажатии кнопки "добавить" не устанавливался фокус во вновь добавленное окно.

 Revision 1.69  2005/09/27 16:12:56  dinishev
 _CleanUp

 Revision 1.68  2005/09/27 15:09:32  dinishev
 Bug fix: попытка проверки морфологии при выходе без выполнения

 Revision 1.67  2005/09/26 11:01:12  dinishev
 Bug fix: используем Trim-фильтр для "Обзора законодательства"

 Revision 1.66  2005/09/23 16:22:42  dinishev
 Поддержка нового типа фильтра

 Revision 1.65  2005/09/23 13:39:13  dinishev
 Bug fix: можно свернуть группу, даже если в ней есть отмеченные значения

 Revision 1.64  2005/09/23 12:12:36  dinishev
 Bug fix: пункты  "где искать контекст" и "Искать в недействующих редакциях"
  снабжены кнопкой логич. условия слева от поля

 Revision 1.63  2005/09/22 15:02:34  dinishev
 Проверка морфологического контекста

 Revision 1.62  2005/09/22 10:20:17  dinishev
 Comments

 Revision 1.61  2005/09/21 14:28:56  dinishev
 Bug fix: неправильная загрузка дат в запрос

 Revision 1.60  2005/09/21 14:04:53  dinishev
 Bug fix: не компилировался Nemesis

 Revision 1.59  2005/09/21 13:54:29  dinishev
 Для утилиты мониторингов установка фокуса в поле "Название" (как в старой КЗ)

 Revision 1.58  2005/09/20 11:26:39  dinishev
 Bug fix: не сохранялось значение реквизита при открытом дереве и начале выполнения запроса

 Revision 1.57  2005/09/19 15:00:47  dinishev
 AV при удалении поля + перемещение дерева при изменении размеров поля ввода + подстановка значений по умолчанию

 Revision 1.56  2005/09/16 15:03:25  dinishev
 Первое приближение обработки гиперссылок + автоматическое формирование значений + проверка E-mail

 Revision 1.55  2005/09/15 14:11:06  dinishev
 Загрузка значений по умолчанию + Bug fix: AV при вводе символов с клавиатуры

 Revision 1.54  2005/09/14 13:50:38  dinishev
 Передача флага для фильтрации полей

 Revision 1.53  2005/09/12 16:05:38  dinishev
 Bug fix: не запоминалась история ввода контекста в поля.

 Revision 1.52  2005/09/12 14:39:47  dinishev
 Bug fix: висла оболочка

 Revision 1.51  2005/09/09 13:20:24  dinishev
 Bug fix: контекстные поля не определялись

 Revision 1.50  2005/09/09 12:02:57  dinishev
 Hints к кнопкам.

 Revision 1.49  2005/09/08 16:16:49  dinishev
 Small changes

 Revision 1.48  2005/09/08 14:56:45  dinishev
 Загрузка и сохранение истории ввода для контекста

 Revision 1.47  2005/09/07 14:27:01  dinishev
 New function NeedHistory

 Revision 1.46  2005/09/07 09:08:29  dinishev
 Remove interface InevInputListner

 Revision 1.45  2005/09/05 10:53:52  dinishev
 Поддержка запрета множественного выбора реквизита

 Revision 1.44  2005/09/03 13:07:11  migel
 - fix: не компилировалось.

 Revision 1.43  2005/09/02 14:52:05  dinishev
 Загрузка и сохранение КЗ (в частности запроса) из истории

 Revision 1.42  2005/09/02 10:16:14  dinishev
 Bug fix: AV при старте КЗ

 Revision 1.41  2005/09/02 09:44:00  dinishev
 Bug fix: не компилировалось

 Revision 1.40  2005/09/02 09:21:17  dinishev
 Поддержка истории ввода

 Revision 1.39  2005/09/01 15:06:28  dinishev
 Ошибка загрузки логических значений

 Revision 1.38  2005/09/01 14:42:52  dinishev
 Remove class TqaReqDict

 Revision 1.37  2005/09/01 12:15:02  dinishev
 Корректная загрузка дат

 Revision 1.36  2005/08/31 17:40:58  dinishev
 Не сохраняем значение AT_TEXT_OPT, если не выставлено AT_TEXT

 Revision 1.35  2005/08/31 17:30:03  dinishev
 Очистка всех видов реквизитов + _CleanUp

 Revision 1.34  2005/08/30 09:50:26  dinishev
 Bug fix: утечки памяти в утилите

 Revision 1.33  2005/08/29 09:28:15  dinishev
 Борьба с утечками памяти.

 Revision 1.32  2005/08/25 15:23:43  dinishev
 Bug fix: более правильное подставление логического значения

 Revision 1.31  2005/08/25 14:20:59  dinishev
 Bug fix: из прослойки получались неправильные логические значения.

 Revision 1.30  2005/08/25 11:08:52  dinishev
 Доработка передачи данных из окна выбора реквизитов и обратно.

 Revision 1.29  2005/08/24 16:41:55  dinishev
 Расширение интерфейсов для поддержки обработки дат.

 Revision 1.28  2005/08/24 08:04:30  dinishev
 AV при попытке поиска.

 Revision 1.27  2005/08/23 14:07:44  dinishev
 Не компилировалось

 Revision 1.26  2005/08/23 13:43:55  dinishev
 Нотификация об изменении текста в поле редактора

 Revision 1.25  2005/08/19 07:38:39  dinishev
 Bug fix: некомпилировалось

 Revision 1.24  2005/08/19 07:01:40  dinishev
 Сleanup

 Revision 1.23  2005/08/19 06:42:32  dinishev
 Bug fix: незаполнялся список атрибутов, формирующих название рассылки.

 Revision 1.22  2005/08/18 14:13:56  dinishev
 Не компилировалиь мониторинги

 Revision 1.21  2005/08/18 13:54:15  dinishev
 Подправлены названия тегов

 Revision 1.20  2005/08/18 08:10:56  dinishev
 Восстановление логики формирования автоматического значения в утилите

 Revision 1.19  2005/08/18 06:59:13  dinishev
 Bug fix: Значение по умолчанию не передавалось в запрос.

 Revision 1.18  2005/08/16 15:03:24  dinishev
 no message

 Revision 1.17  2005/08/16 13:08:07  dinishev
 Убран лишний код при создании КЗ

 Revision 1.16  2005/08/16 07:31:13  dinishev
 Rename evScriptModel -> evDropControls

 Revision 1.15  2005/08/15 13:28:54  dinishev
 Получение реквизита по имени + директива LOAD_FROM_CARD - для загрузки данных запросов из КЗ

 Revision 1.14  2005/08/15 12:04:43  dinishev
 Bug fix: не компилировалось.

 Revision 1.13  2005/08/15 10:49:20  dinishev
 Поддержка DefaultValue

 Revision 1.12  2005/08/15 08:27:32  dinishev
 Отказ от _Events в интерфейсах Починка отъехавших иконок в деревьях.

 Revision 1.11  2005/08/12 16:36:03  dinishev
 Новые интерфейсы с обработчиками - подготовка к переходу на листнеры

 Revision 1.10  2005/08/12 15:47:51  dinishev
 Некоторые классы переехали в другие модули

 Revision 1.9  2005/08/11 16:42:04  dinishev
 no message

 Revision 1.8  2005/08/11 16:29:06  dinishev
 no message

 Revision 1.7  2005/08/11 15:30:51  dinishev
 _CleanUp

 Revision 1.6  2005/08/11 14:42:07  dinishev
 Bug fix: зависание при выборе дерева контекста

 Revision 1.5  2005/08/11 14:15:42  dinishev
 Получение картинок для некоторых атрибутов

 Revision 1.4  2005/08/11 12:51:32  dinishev
 Нормальная инициализация бизнес-логики

 Revision 1.3  2005/08/08 14:06:32  dinishev
 Change: вернул код, вырезанный Мишей Морозовым. Код пока отключен, так что AV не будет.

 Revision 1.2  2005/07/26 12:55:47  mmorozov
 bugfix: AV при открытии карточки (удалены рудиментные методы);

 Revision 1.1  2005/07/22 15:48:40  dinishev
 Новая EVD

-----------------------------------------------------------------------------*)

{$Include nsDefine.inc}

interface

//{$DEFINE NEW_TREE}

uses
  ImgList,
  Classes,

  l3Interfaces,
  l3Types,
  l3Base,
  l3TreeInterfaces,
  l3CacheableBase,
  l3CObjectRefList,

  afwInterfaces,

  vcmBase,
  vcmEntities,
  vcmExternalInterfaces,

  nevBase,
  nevTools,
  
  evQueryCardInt,

  nsTypes,
  nscInterfaces,
  {$IfNDef Admin}
  nsSearchClasses,
  {$EndIf  Admin}
  nsQueryInterfaces,

  BaseTreeSupportUnit,
  DynamicTreeUnit,
  SearchUnit,

  lgTypes,

  SearchDomainInterfaces

  {$If not Defined(Admin) AND not Defined(Monitorings)}
  ,
  BaseSearchInterfaces
  {$IfEnd}
  ;

type
  TqaMgrSearch = class;

  TqaReq = class(Tl3CacheableBase, IqaReqPrim, IqaReq)
  private
   // internal fields
   f_MgrSearch    : IqaMgrSearch;
    {-}
   f_EditorReq    : IevReq;
    {* - Интерфейс реквизита из редактора. }
  protected
   {$IFDEF Monitorings}
   procedure MakeChangedReq;
     {-}
   {$ENDIF Monitorings}
   function  Get_EditorReq: IevReq;
     {-}
   function  Get_Multy: Boolean;
     virtual;
     {-}
   function  Get_TagCaption: Il3Cstring;
     {-}
   function  Get_TagName: Il3CString;
     {-}
   function CanAdd: Boolean;
     virtual;
     {* - Проверяет можно ли добавить еще одно поле к реквизиту. }
   function CanOpenTree: Boolean;
     virtual;
     {* - Проверяет можно ли добавить еще одно поле к реквизиту. }
   function IsAttrValid: Boolean;
     { Проверяет втрибут на правильность ввода }
   procedure DoOperateChanged;
     virtual;
     {* - Обработчик изменения поля. }
   function  Get_Modified: Boolean;
   procedure Set_Modified(Value: Boolean);
     {-}
   function  GetReqAsString(const aSeparator: Il3CString): Il3CString;
     virtual;
     {* - Формирует строку всех полей реквизита, определенных пользователем
          и разделенных разделителем aSeparator. }
   {$IFDEF Monitorings}
   procedure MakeFieldValue;
     virtual;
     {-}
   {$EndIF Monitorings}  
   function BeforeGroupCollapse : Boolean;
     virtual;
     {-}
   procedure SaveReq;
     virtual;
     abstract;
     {-}
   procedure Cleanup;
     override;
     {-}
   function IsEditEmpty: Boolean;
     {* - Проверяет есть ли значения в поле ввода. Имеет смысл только для
          одиночных полей. }
   procedure Load;
     virtual;
     {-}
   procedure DeleteEmptyValues;
     {-}
  public
   // public methods
   constructor Create(const aMgrSearch : IqaMgrSearch;
                      const aEditorReq : IevReq);
    reintroduce;
    virtual;
     {-}
   class function Make(const aMgrSearch : IqaMgrSearch;
                       const aEditorReq : IevReq): IqaReq;
     {-}
   procedure Clear;
     virtual;
     {-}
   procedure OpenSelectWindow;
     virtual;
     {-}
   function IsSet(aElseDefaultValue : Boolean = False): Boolean;
     {* - Если True, то в компоненте установлено значение. }
   procedure CheckAttr;
     virtual;
     {-}
   function CheckFromControl(out aExceptionClass : EaqExceptionClass;
                             out aMessage        : String;
                             out aControl        : IevEditorControlField): Boolean;
     virtual;
     {-}
   procedure Save;
     {-}
   procedure ReqClear;
     virtual;
     {* - Очистка реквизита с удалением всех полей, кроме одного. }
  public
   // public properties    
   property Multy: Boolean
     read Get_Multy;
     {-}
   property TagName: Il3CString
     read Get_TagName;
     {-}
   property TagCaption: Il3Cstring 
     read Get_TagCaption;
     {-}
   property EditorReq: IevReq
     read Get_EditorReq;
     {* - Ссылка на внутренний атрибут. }
   property Modified: Boolean 
     read Get_Modified 
     write Set_Modified;
     {* - Атрибут модифицирова пользователем со времени последнего сохранения. }
  end;//TqaReq
  
  TqaAttrInfo = class(Tl3CObjectRefList)
  {* - Предназначен для сохранения IDictNode и типа операции. }
  private
   // private fields
   f_Mask : Il3CString;
     {-}
   f_Oper : TLogicOperation;
     {-}
   f_Node : INodeBase;
     {-}
  protected
   // protected methods
   procedure Cleanup;
     override;
     {-}
  public
   // public methods
   constructor Create(const aOper : TLogicOperation = loNone;
                      const aNode : INodeBase = nil;
                      const aMask : Il3CString = nil);
     reintroduce;
     virtual;
     {* - Создает класс и инициализирует значениями. }
  public
   // public properties
   property Mask: Il3CString 
     read f_Mask 
     write f_Mask;
     {* - Пользователь установил маску в поле ввода. }
   property Oper: TLogicOperation 
     read f_Oper 
     write f_Oper;
     {-}
   property NodeBase : INodeBase 
     read f_Node;
     {-}
  end;//TqaAttrInfo
  
  TqaAttrInfoList = class(Tl3CObjectRefList)
  end;//TqaAttrInfoList

  TqaEventReq = class(TqaReq, IevModelListner)
  //Класс создан исключительно ради поддержки интерфейса IevModelListner.
  protected
   function GetHint4Button(const aValue: IevEditorControlButton): Il3CString;
     virtual;
     {* - Возвращает текст к кнопке для конкретных реквизитов. }  
   function StateIndex2LogicState(aValue: Integer): TLogicOperation;
    {* - Переводит логическое состояние в TLogicOperation. }
   //interface IevModelListner
   function CheckValue(const aField : IevEditorControlField): Boolean;
     {* - Проверка значения поля. }
   function GetImage(Index: Longint;
                     var aImages: InevImageList) : Integer;
     {-}
   procedure EnterPressed;
     virtual;
     {* - Обработчик нажатия на "Enter". }
   procedure TextChange;
     virtual;
     {-}
   procedure AfterSetText(const aField: IevEditorControlField);
     virtual;
     {-}
   function  AnalysString(const aValue : Il3CString;
                          out aRslt    : Il3CString): Boolean;
     virtual;
     {-}
   procedure HyperLinkClick;
     virtual;
     {-}
   function GetHint(const aValue: IevEditorControl): Il3CString;
     {-}
   function pm_GetAdditionalFilter: TnsFilterType;
     {-}
  protected
  // internal properties
   property AdditionalFilter: TnsFilterType
     read pm_GetAdditionalFilter;
     {-}
  end;//TqaEventReq

  TqaReqComboField = class(TqaEventReq)
  public
   function CheckFromControl(out aExceptionClass : EaqExceptionClass;
                             out aMessage        : String;
                             out aControl        : IevEditorControlField): Boolean;
     override;
     {-}
   procedure CheckAttr;
     override;
     {-}
   procedure ReqClear;
     override;
     {* - Очистка реквизита с удалением всех полей, кроме одного. }
  end;//TqaReqComboField

  TqaCustomReqContext = class(TqaReqComboField)
  protected
   function  AnalysString(const aValue : Il3CString;
                          out aRslt    : Il3CString): Boolean;
    override;
    {-}
   function  GetReqAsString(const aSeparator: Il3CString): Il3CString;
     override;
     {* - Формирует строку контекста из всех строк определенных пользователем
          и разделенную разделителем aSeparator. }
   procedure FillReqListAsString(const aList: Il3StringsEx);
     {-}
   procedure EnterPressed;
     override;
     {* - Обработчик нажатия на "Enter". }
   function CanAdd: Boolean;
     override;
     {* - Проверяет можно ли добавить еще одно поле к реквизиту. }
   procedure Load;
     override;
     {-}
  public
   constructor Create(const aMgrSearch : IqaMgrSearch;
                      const aEditorReq : IevReq);
     override;
     {-}
   procedure SaveReq;
     override;
     {-}
  end;//TqaCustomReqContext

  TqaReqContext = class(TqaCustomReqContext, IqaMorphoReq)
   procedure CheckAttr;
     override;
     {-}
  end;//TqaReqContext

  TqaCommonStrReq = class(TqaCustomReqContext)
  protected
   procedure TextChange;
     override;
     {-}
   procedure Load;
     override;
     {-}
  public
   procedure SaveReq;
     override;
     {-}
   procedure ReqClear;
     override;
     {* - Очистка реквизита с удалением всех полей, кроме одного. }
  end;//TqaCommonStrReq

  TqaReqMemo = class(TqaCommonStrReq)
  end;//TqaReqMemo

  TqaReqStr = class(TqaCommonStrReq)
  protected
   function  Get_Multy: Boolean;
     override;
     {-}
   {$IFDEF Monitorings}
   procedure MakeFieldValue;
     override;
     {* - Функция, устанавливающая значение поля при изменении. }
   procedure ReqClear;
     override;
      {-}
   {$EndIF Monitorings}  
   procedure Load;
     override;
     {-}
  end;//TqaReqStr

  TqaReqEMail = class(TqaReqStr)
   procedure CheckAttr;
     override;
     {-}
   function CheckFromControl(out aExceptionClass : EaqExceptionClass;
                             out aMessage        : String;
                             out aControl        : IevEditorControlField): Boolean;
     override;
     {-}
  end;//TqaReqEMail

  TqaReqAttribute = class(TqaReqComboField, IqaReqAttribute)
  private
   // internal methods
   function Root : INodeBase;
     {* - Полученное view. Создаётся один раз и раздаётся полям ввода. }
   procedure SetAttributesToView;
     {* - Устанавливаем флаги операций нода в дереве. }
   procedure GetAttributesFromView(const aRoot : INodeBase);
     {* - Вычитываем флаги операций из дерева (создаёт поля ввода). }
  protected
   // protected methods
   procedure EnterPressed;
     override;
     {* - Обработчик нажатия на "Enter". }
   procedure AfterSetText(const aField: IevEditorControlField);
     override;
     {-}
   function GetReqAsString(const aSeparator: Il3CString): Il3CString;
     override;
     {-}
   procedure SaveFieldToQuery(const aValue: IevEditorControlField);
     {* - Замена TasField.SaveToQuery. }
   procedure DoOperateChanged;
     override;
     {* - Обработчик изменения поля. }
   function FieldLogicOperation(const aValue: IevEditorFieldWithTree): TLogicOperation;
     {* - Возващает логическую операцию для поля. }
   procedure LoadField(const aValue: IevEditorFieldWithTree;
                       aLogicOper:  TLogicOperation;
                       const aNode: INodeBase);
     {* - Загрузить данные в поле. }
   function CanAdd: Boolean;
     override;
     {* - Проверяет можно ли добавить еще одно поле к реквизиту. }
   function CanOpenTree: Boolean;
     override;
     {* - Проверяет можно ли открыть окно выбора реквизитов для реквизита. }
  public
   // public methods
   procedure OpenSelectWindow;
     override;
     {-}
   procedure Load;
     override;
     {-}
   procedure SaveReq;
     override;
     {-}
  end;//TqaReqAttribute

  TqaReqNum = class(TqaReqAttribute)
  protected
   procedure InitFields;
     override;
     {-}
  end;//TqaReqNum

  TqaReqDate = class(TqaEventReq, IqaDateReq)
  protected
   // protected methods
   function Get_Multy: Boolean;
     override;
     {-}
   function GetHint4Button(const aValue: IevEditorControlButton): Il3CString;
     override;
     {* - Возвращает текст к кнопке для конкретных реквизитов. }
   function Get_EndDate: System.TDateTime;
     {-}
   function Get_StartDate: System.TDateTime;
     {-}
   procedure Set_EndDate(const Value: System.TDateTime);
     {-}
   procedure Set_StartDate(const Value: System.TDateTime);
     {-}
   function BeforeGroupCollapse : Boolean;
     override;
     {-}
   procedure InitFields;
     override;
     {-}
   procedure SaveReq;
     override;
     {-}
   procedure HyperLinkClick;
     override;
     {-}
   procedure EnterPressed;
     override;
     {* - Обработчик нажатия на "Enter". }
   function CanOpenTree: Boolean;
     override;
     {* - Проверяет можно ли добавить еще одно поле к реквизиту. }
  public
   // public methods
   procedure OpenSelectWindow;
     override;
     {-}
   procedure Load;
     override;
     {-}
   procedure ReqClear;
     override;
     {-}
   procedure CheckAttr;
     override;
     {-}
   function CheckFromControl(out aExceptionClass : EaqExceptionClass;
                             out aMessage        : String;
                             out aControl        : IevEditorControlField): Boolean;
     override;
     {-}
   property StartDate: System.TDateTime
     read Get_StartDate
     write Set_StartDate;
     {-}
   property EndDate: System.TDateTime
     read Get_EndDate
     write Set_EndDate;
     {-}
  end;//TqaReqDate

  TqaDateReqDataHolder = class(TvcmBase, IqaDateReqDataHolder)
  private
   f_StartDate: System.TDateTime;
     {-}
   f_EndDate: System.TDateTime;
     {-}
   f_IsOk: Boolean;
     {-}
   f_ReqCaption: Il3CString;
     {-}
   function Get_EndDate: System.TDateTime;
     {-}
   function Get_StartDate: System.TDateTime;
     {-}
   procedure Set_EndDate(const Value: System.TDateTime);
     {-}
   procedure Set_StartDate(const Value: System.TDateTime);
     {-}
   function Get_IsOk: Boolean;
     {-}
   procedure Set_IsOk(const Value: Boolean);
     {-}
   function Get_ReqCaption: Il3CString;
     {-}
   function IsStartDateEmpty: Boolean;
     {-}
   function IsEndDateEmpty: Boolean;
     {-}
  protected
  // internal methods
   procedure Cleanup;
     override;
     {-}
  public
   constructor Create(const aReq: IqaDateReq);
    reintroduce;
     {-}
   class function Make(const aReq: IqaDateReq): IqaDateReqDataHolder;
    reintroduce;
     {-}
   property StartDate: System.TDateTime
     read Get_StartDate
     write Set_StartDate;
     {-}
   property EndDate: System.TDateTime
     read Get_EndDate
     write Set_EndDate;
     {-}
   property IsOk: Boolean
     read Get_IsOk
    write Set_IsOk;
     {-}
   property ReqCaption: Il3CString
     read Get_ReqCaption;
  end;//TqaDateReqDataHolder

  TqaReqPhone = class(TqaEventReq, IqaPhoneReq)
  protected
   // protected methods
   function  Get_Multy: Boolean;
     override;
     {-}
   function  Get_Number: Il3CString;
   procedure Set_Number(const Value: Il3CString);
     {-}
   function  Get_Code: Il3CString;
   procedure Set_Code(const Value: Il3CString);
     {-}
   procedure SaveReq;
     override;
     {-}
   function CanOpenTree: Boolean;
     override;
     {* - Проверяет можно ли добавить еще одно поле к реквизиту. }
  public
   // public methods
   procedure Load;
     override;
     {-}
   procedure ReqClear;
     override;
     {-}
  public
   property Code: Il3CString
       read Get_Code
      write Set_Code;
   property Number: Il3CString
       read Get_Number
      write Set_Number;
  end;//TqaReqPhone

  TqaMgrSearch = class(TvcmBase, IqaMgrSearch, IevAdapterModel
                       {$If not Defined(Admin) AND not Defined(Monitorings)}
                       ,
                       InsMistakesCorrector
                       {$IfEnd}
                       )
  {* - Предназначен для загрузки из IQuery и выгрузки из IQuery, управление
       элементами поиска. }
  private
   f_FormName          : Il3CString;
     {-}
   f_Query             : IQuery;
     {-}
   f_IsQueryNew        : Boolean;
     {-}
   f_QueryType         : TlgQueryType;
     {-}
   f_QueryCard         : IevQueryCard;
     {-}
   f_OnDateQuery       : TOnDateQuery;
     {-}
   f_OnNeedExecQuery   : TNotifyEvent;
     {-}
   f_OnModifiedChanged : TNotifyEvent;
     {-}
   f_InModifiedChanged : Integer;
     {-}
   f_FromHistory       : Boolean;
     {-}
   {$If not Defined(Admin) AND not Defined(Monitorings)}
   f_ContextHistory    : InsContextSearchHistory;
     {-}
   {$IfEnd}  
   f_Modified          : Integer;
   f_GettingAttributesFromView : Integer;
   f_FirstErrorContextReq: IevEditorControlField;
  private  
   // private methods
   function  NeedSettings: Boolean;
     {-}
   procedure FinishEntering;
     {-}
   // property methods
   function Get_Modified: Boolean;
     {-}
   procedure Set_Modified(Value: Boolean);
     {-}
   function Get_IsNew: Boolean;
     {-}
   function Get_QueryType: TlgQueryType;
     {-}
   function MakeGroupsSettingId: Il3CString;
     {-}
   function MakeDescriptionsSettingId: Il3CString;
     {-}
  protected
   {$If not Defined(Admin) AND not Defined(Monitorings)}
   // InsMistakesCorrector
   procedure Correct(const aCorrectedContext: Il3StringsEx;
     const aMistakesList: Il3StringsEx);
   {$IfEnd}  
   // IAdapterModel
   procedure FocusStartField;
     {-}
   procedure LimitCharsReached(const aControl: IevEditorControl);
     {* - Обработчик достижания максимального количества символов в контроле. }
   function  ModelListner(const aReq: IevReq): IevModelListner;
     {-}
   // protected methods
   {$If not Defined(Admin) AND not Defined(Monitorings)}
   function Get_HistoryList: IvcmStrings;
     {-}
   {$IfEnd}  
   function Get_QueryCard: IevQueryCard;
     {-}
   {$IFDEF Monitorings}
   function GetName4Query: Il3CString;
     {* - Возвращают имя для запроса. }
   {$ENDIF Monitorings}
   procedure FinishOpenTree(const aRoot : INodeBase;
                            const aReq  : IqaReq);
     {-}
   function GetCurrentReq: IqaReq;
     {* - Возвращает текущий реквизит для контрола. }
   function GetCurrentEditorReq: IevReq;
     {* - Возвращает текущий реквизит для контрола. }
   function GetCurrentField: IevEditorControlField;
     {* - Возвращает текущий контрол для реквизита. }
   function Get_FromHistory: Boolean;
     {-}
   procedure Set_FromHistory(const Value: Boolean);
     {-}
   function Get_Query: IQuery;
     {-}
   procedure Set_Query(const Value: IQuery);
     {-}
   procedure IterateAttrsF(anAction : Tl3FreeAction);
     {-}
   procedure DeleteValue(const aView: InevView);
     {-}
   procedure DeleteAll;
     {-}
   procedure AddValue(const aView: InevView);
     {-}
   procedure DateQuery(const aValue: IqaDateReq);
     {-}
   procedure CallModifiedChanged;
    {-}
   procedure ModifiedChanged(aValue: Boolean);
    {-}
   procedure ExecQuery;
     {* - Запустить запрос на выполнение. }
   procedure OpenSelectWindow;
     {* - Открыть окно выбора реквизита. }
   function  FindAttr(const aTagName : Il3CString): IqaReq;
     {* - Возвращает атрибут по имени. }
   procedure ClearAttrs;
     {-}
   function  GettingFromView: Boolean;
     {-}
   procedure StartGettingFromView;
     {-}
   procedure FinishGettingFromView;
     {-}
   function  GetTreeFromAdapter(const aReq: Il3CString): Il3SimpleTree;
     {* - Получает дерево с адаптера. }
   function  GetPromptTreeFromAdapter: Il3SimpleTree;
     {* - Получает дерево с адаптера. }
   procedure NotifyContextWrong;
     {-}
   procedure Cleanup;
     override;
     {-}
  public
    // public methods
   constructor Create(const aQuery            : IQuery;
                      aQueryType              : TlgQueryType;
                      const aFormName         : Il3CString;
                      const OnDateQuery       : TOnDateQuery;
                      const OnNeedExecQuery   : TNotifyEvent;
                      const OnModifiedChanged : TNotifyEvent
                      {$If not Defined(Admin) AND not Defined(Monitorings)}
                      ;
                      const aContextHistory   : InsContextSearchHistory
                      {$ifEnd}
                      );
      reintroduce;
      virtual;
     {* - Парамтры:
          - aQueryType (тип запроса);
          - aFormName (имя формы для сохранения в настройки); }
   class function Make(const aQuery            : IQuery;
                       aQueryType              : TlgQueryType;
                       const aFormName         : Il3CString;
                       const OnDateQuery       : TOnDateQuery;
                       const OnNeedExecQuery   : TNotifyEvent;
                       const OnModifiedChanged : TNotifyEvent
                       {$If not Defined(Admin) AND not Defined(Monitorings)}
                       ;
                       const aContextHistory   : InsContextSearchHistory
                       {$IfEnd}
                       ): IqaMgrSearch;
     {-}
   procedure InitUpdate;
     {-}
   procedure CheckAttrs;
     {-}
   {$If not (defined(Monitorings) or defined(Admin))}
   procedure CheckMorpho;
     {-}
   {$IfEnd}  
   function  Save(aIgnoreError: Boolean = False): Boolean;
     {-}
   function  IsSomeFieldFilled(aElseDefaultValue: Boolean = False): Boolean;
     {-}
   procedure Load;
     {-}
   procedure ReadSettings;
     {-}
   procedure WriteSettings;
     {-}
   {$IFDEF Monitorings}
   procedure Check;
     {-}
   {$EndIF Monitorings}
   procedure Clear;
     reintroduce;
     {-}
   procedure ClearContextMistakes;
     {-}
   procedure CreateTree(const aQueryCard: IevQueryCard);
     {-}
   procedure InitFocus;
     {* - Устанавливает фокус первой панели. }
   procedure EscPressed(const aField: IevEditorFieldWithTree);
     {-}
   {$IFDEF Monitorings}
   function ChangableReq: IqaReq;
     {* - Изменяющаеся значение при изменении реквизита. }
   {$ENDIF Monitorings}
  public
   // public property
   procedure ChangeStateAll(const aExpand: Boolean);
      {-}
   property Query: IQuery
     read Get_Query
     write Set_Query;
     {-}
   property QueryType: TlgQueryType
     read Get_QueryType;
     {-}
   property IsQueryNew: Boolean
     read Get_IsNew;
     {* - Является ли запрос новым, т.е. не загруженным из базы. }
   property Modified: Boolean
     read Get_Modified
     write Set_Modified;
     {* - Атрибут модифицирова пользователем со времени последнего сохранения. }
   property QueryCard: IevQueryCard 
     read Get_QueryCard 
     write f_QueryCard;  
     {* - Вход в прослойку со стороны редактора. }
   property FromHistory: Boolean 
     read Get_FromHistory 
     write Set_FromHistory;
     {-}
   {$If not Defined(Admin) AND not Defined(Monitorings)}
   property HistoryValues: IvcmStrings
     read Get_HistoryList;
     {-}
   {$ifEnd}  
  end;//TqaMgrSearch

  _afwApplicationDataUpdate_Parent_ = TvcmCacheableBase;
  {$Include afwApplicationDataUpdate.imp.pas}
  TqaHistory = class(_afwApplicationDataUpdate_,
                     IvcmBase,
                     IqaHistory)
  {* - реализует интерфейс IqaHistory. }
  private
   f_Filter            : INode;
   f_Query             : IQuery;
   f_DataReset         : Boolean;
   f_ConsultationSened : Boolean;
  private
   // property methods
   function  GetFilter: INode;
     {-}
   procedure SetFilter(const aNode: INode);
     {-}
   function  GetQuery: IQuery;
     {-}
   procedure pm_SetQuery(const aValue: IQuery);
     {-}
   function GetDataReset : Boolean;
     {-}
   procedure SetConsultationSended(const aValue : Boolean);
     {-}
   function GetConsultationSended: Boolean;
     {-}
  protected
   procedure FinishDataUpdate;
     override;
     {* вызывает по окончании обновления }
  protected
   // protected methods
   procedure Cleanup;
     override;
     {-}
  end;//TqaHistory
  
  TqaReqClass = class of TqaReq;

{$If not defined(Admin)}
procedure LoadDateNew(const aQuery    : IQuery;
                      const aTagName  : Il3CString;
                      var aStartDate  : System.TDateTime;
                      var aEndDate    : System.TDateTime);
  {* - Загрузить диапазон дат из IQuery. }
{$IfEnd}

procedure LoadPhone(const aQuery    : IQuery;
                    const aTagName  : Tl3WString;
                    out aCode       : Il3CString;
                    out aNumber     : Il3CString);
  {* - Загрузить номер телефона из IQuery. }

{$IfNDef Admin}
procedure LoadDictionaryNew(aList          : TqaAttrInfoList;
                            const aQuery   : IQuery;
                            const aTagName : Il3CString);
  {* - Загрузить значение реквизита. }
{$EndIf  Admin}  
  
implementation

uses
  SysUtils,
  Math,

  Controls,
  Dialogs,
  Forms,

  StdRes,
  SystemStr,
  DebugStr,
  {$IfNDef Admin}
  SearchRes,
  {$EndIf  Admin}

  l3Const,
  l3Chars,
  l3Date,
  l3String,
  l3Bits,
  l3ImageList,

  k2Tags,

  afwFacade,

  evdTypes,
  evControlParaConst,
  evControlParaTools,
  evParaTools,
  evSearch,
  evdStyles,

  evTypes,
  evSegLst,

  vcmForm,
  vcmSettings,
  vcmStringList,
  vcmInterfaces,

  bsUtils,

  {$If not defined(Admin)}
  nsQuery,
  {$IfEnd}
  nsConst,
  nsTreeUtils,
  nsQueryUtils,
  nsDataResetTreeStruct,
  nsVerifyValue,
  {$If not defined(Admin)}
  nsbQueryUtils,
  {$IfEnd}
  nsContextUtils,
  nsINodeWrap,
  nsLogicOperationToFlags,
  nsAttributeTreeCacheNew,
  nsUtils,
  nsAttributeTreeStruct,
//  nsBaseSearchPromptTree, // К-104432064

  IOUnit,

  DataAdapter,
  bsInterfaces

  {$If not Defined(Admin) AND not Defined(Monitorings)}
  ,
  nsContextHistory
  {$IfEnd}

  ,
  vcmMessagesSupport
  ;

{$Include afwApplicationDataUpdate.imp.pas}

{$IfNDef Admin}
const
 c_InpharmSearches = [lg_qtInpharmSearch];

procedure LoadDictionaryNew(aList          : TqaAttrInfoList;
                            const aQuery   : IQuery;
                            const aTagName : Il3CString);
var
 l_List        : IQueryAttributeList;
 l_Index       : Integer;
 l_Context     : IQueryContextAttribute;
 l_Node        : IQueryNodeAttribute;
 l_ContextList : IContextValueList;
 l_I           : Integer;
 l_NodeList    : INodeValueList;
 l_AttrInfo    : TqaAttrInfo;
 l_Count       : Integer;
 l_ContCount   : Integer;
 l_NodeCount   : Integer;
 l_Attribute   : IQueryAttribute;
 l_ContextValue: TContextValue;
 l_NodeValue   : TQueryNodeValue;
begin
 aQuery.AttributesByTag(nsAStr(aTagName).S, l_List);
 if Assigned(l_List) then
 try
  l_Count := l_List.Count - 1;
  for l_Index := 0 to l_Count do
  begin
   l_List.pm_GetItem(l_Index, l_Attribute);
   case l_Attribute.GetType of
      // Маска для номеров
      QTT_CONTEXT:
      if Supports(l_Attribute, IQueryContextAttribute, l_Context) then
       try
        l_Context.GetValues(l_ContextList);
       l_ContCount := l_ContextList.Count - 1;
        for l_I := 0 to l_ContCount do
       begin
        l_ContextList.pm_GetItem(l_I, l_ContextValue);
        with l_ContextValue do
         begin
          l_AttrInfo := TqaAttrInfo.Create(LQOperationToLSelection(rOperation),
                                       nil,
                                       nsCStr(rContext));
          try
           aList.Add(l_AttrInfo);
          finally
           vcmFree(l_AttrInfo);
          end;
         end;
       end;
       finally
        l_Context := nil;
       end;
      // Древовидное значение
      QTT_NODE:
      if Supports(l_Attribute, IQueryNodeAttribute, l_Node) then
       try
        l_Node.GetValues(l_NodeList);
       l_NodeCount := l_NodeList.Count - 1;
        for l_I := 0 to l_NodeCount do
       begin
        l_NodeList.pm_GetItem(l_I, l_NodeValue);
        with l_NodeValue do
         begin
          l_AttrInfo := TqaAttrInfo.Create(LQOperationToLSelection(rOperation),
                                           rNode);
          try
           aList.Add(l_AttrInfo);
          finally
           vcmFree(l_AttrInfo);
          end;
         end;
       end;
       finally
        l_Node := nil;
       end;
    end;
  end;
 finally
  l_List := nil;
 end;
end;
{$EndIf  Admin}

{$If not defined(Admin)}
procedure LoadDateNew(const aQuery    : IQuery;
                      const aTagName  : Il3CString;
                      var aStartDate  : System.TDateTime;
                      var aEndDate    : System.TDateTime);
  {* - Загрузить диапазон дат из IQuery. }
var
 l_Node      : IQueryDateAttribute;
 l_List      : IQueryAttributeList;
 l_ValueList : IDateValueList;
 l_Attribute : IQueryAttribute;
 l_DateValue : TDateValue;
begin
 aStartDate := NullDate;
 aEndDate := NullDate;
 aQuery.AttributesByTag(nsAStr(aTagName).S, l_List);
 if Assigned(l_List) and (l_List.Count > 0) then
 begin
  // Для одного тега может быть только одно значение
  l_List.pm_GetItem(0, l_Attribute);
  if (l_Attribute.GetType = QTT_DATE) and Supports(l_Attribute,
    IQueryDateAttribute, l_Node) then
   try
    // Список значений
    l_Node.GetValues(l_ValueList);
   if l_ValueList.Count > 0 then
   begin
    l_ValueList.pm_GetItem(0, l_DateValue);
    with l_DateValue do
     begin
      // Начало
      if not IsNullDate(rFrom) then
       aStartDate := GblAdapterDateToDateTime(rFrom);
      // Конец
      if not IsNullDate(rTo) then
       aEndDate := GblAdapterDateToDateTime(rTo);
     end;//with l_ValueList.GetDataPtr(0)^
   end;
   finally
    l_Node := nil;
   end;//try..finally
 end;//l_List.GetCount > 0
end;
{$IfEnd}

procedure LoadPhone(const aQuery   : IQuery;
                    const aTagName : Tl3WString;
                    out aCode      : Il3CString;
                    out aNumber    : Il3CString);
  {* - Загрузить номер телефона из IQuery. }
var
 l_Node : IQueryPhoneNumberAttribute;
 l_Str  : IString;
begin
 aQuery.GetPhoneNumberAttribute(nsAStr(aTagName).S, l_Node);
 l_Node.GetCityCode(l_Str);
 aCode := nsCStr(l_Str);
 l_Node.GetPhoneNumber(l_Str);
 aNumber := nsCStr(l_Str);
end;

function DoShowTree(const aTagName           : Il3CString;
                    const anAdditionalFilter : TnsFilterType) : Boolean;
var
 l_Cursor : TCursor;
begin
 Result := False;
 l_Cursor := Screen.Cursor;
 try
  Screen.Cursor := crHourGlass;
  Result := TdmStdRes.OpenTreeSelection(aTagName, anAdditionalFilter, nil) = mrOk;
 finally
  Screen.Cursor := l_Cursor;
 end;//try..finally
end;

// start class TqaMgrSearch

function TqaMgrSearch.Get_Query: IQuery;
begin
 Result := f_Query;
end;

function TqaMgrSearch.Get_QueryType: TlgQueryType;
begin
 Result := f_QueryType;
end;

class function TqaMgrSearch.Make(const aQuery            : IQuery;
                                 aQueryType              : TlgQueryType;
                                 const aFormName         : Il3CString;
                                 const OnDateQuery       : TOnDateQuery;
                                 const OnNeedExecQuery   : TNotifyEvent;
                                 const OnModifiedChanged : TNotifyEvent
                                 {$If not Defined(Admin) AND not Defined(Monitorings)}
                                 ;
                                 const aContextHistory: InsContextSearchHistory
                                 {$IfEnd}
                                 ): IqaMgrSearch;
var
 l_MsgSearch: TqaMgrSearch;
begin
 l_MsgSearch := Create(aQuery, aQueryType, aFormName, OnDateQuery, OnNeedExecQuery,
  OnModifiedChanged
  {$If not Defined(Admin) AND not Defined(Monitorings)}
  , aContextHistory
  {$IfEnd}
  );
 try
  Result := l_MsgSearch;
 finally
  l3Free(l_MsgSearch);
 end;
end;

procedure TqaMgrSearch.ChangeStateAll(const aExpand: Boolean);
var
 l_Index: Integer;
 l_Group: IevQueryGroup;
begin  
 for l_Index := 0 to f_QueryCard.GroupCount - 1 do
 begin
  l_Group := f_QueryCard.QueryGroup[l_Index];
  try
   l_Group.Expanded := aExpand;
  finally
   l_Group := nil;
  end;
 end;   
end;

{$IFDEF Monitorings}
procedure TqaMgrSearch.Check;
begin
 try
  CheckAttrs;
 except
  on E: EqaException do
   begin
    with E.ErrorControl do
    begin
     with Req.Group do
      if not Expanded then
       Expanded := True;
     Req.SetFocus(E.ErrorControl, True);
    end;
    raise;
   end;
 end;
end;
{$EndIF Monitorings}

procedure TqaMgrSearch.Cleanup;
begin
 f_FirstErrorContextReq := nil;
 f_FormName := nil;
 {$If not Defined(Admin) AND not Defined(Monitorings)}
 f_ContextHistory := nil;
 {$IfEnd}
 if (f_QueryCard <> nil) then
  f_QueryCard.ReleaseListners;
 f_QueryCard := nil;
 f_Query := nil;
 inherited;
end;

procedure TqaMgrSearch.Clear;
begin
 if (f_QueryCard <> nil) then
 begin
  (f_QueryCard As InevControlListner).HideDroppedControl(True);
  ClearAttrs;
  Self.QueryCard.CardClear
 end;//f_QueryCard <> nil
 {$IFDEF Monitorings}
 f_Query := nil;
 nsQuery.CreateQuery(f_Query, BusinessQueryToAdapterQuery(f_QueryType));
 {$ELSE Monitorings}
 f_Query.Clear;
 {$ENDIF Monitorings}
end;

constructor TqaMgrSearch.Create(const aQuery            : IQuery;
                                aQueryType              : TlgQueryType;
                                const aFormName         : Il3CString;
                                const OnDateQuery       : TOnDateQuery;
                                const OnNeedExecQuery   : TNotifyEvent;
                                const OnModifiedChanged : TNotifyEvent
                                {$If not Defined(Admin) AND not Defined(Monitorings)}
                                ;
                                const aContextHistory   : InsContextSearchHistory
                                {$IfEnd}
                                );
begin
 f_FormName := aFormName;
 f_QueryType := aQueryType;
 f_IsQueryNew := True;
 f_OnDateQuery := OnDateQuery;
 f_OnNeedExecQuery := OnNeedExecQuery;
 f_OnModifiedChanged := OnModifiedChanged;
 {$If not Defined(Admin) AND not Defined(Monitorings)}
 f_ContextHistory := aContextHistory;
 {$IfEnd}
 // Загрузим IQuery
 if (aQuery = nil) then
  {$If not defined(Admin)}
  nsQuery.CreateQuery(f_Query, BusinessQueryToAdapterQuery(aQueryType))
  {$Else}
  Assert(false)
  {$IfEnd}
 else
 begin
  f_Query := aQuery;
  f_IsQueryNew := False;
 end;//aQuery = nil
end;

procedure TqaMgrSearch.CreateTree(const aQueryCard: IevQueryCard);
{$IFDEF Monitorings}
var
 CR : IqaReq;
{$EndIF Monitorings}
begin
 if (aQueryCard <> f_QueryCard) then
 begin
  if (f_QueryCard <> nil) then
   f_QueryCard.LinkListner(nil);
  f_QueryCard := aQueryCard;
  f_QueryCard.LinkListner(Self);
 end;//aQueryCard <> f_QueryCard
 // Загрузим значения 
 if not f_IsQueryNew then
  Load;
 {$IFDEF Monitorings}
 CR := ChangableReq;
 if (CR <> nil) then //Значение по умолчанию для поля "Тема"
  CR.MakeFieldValue;
 {$ENDIF Monitorings}
 InitFocus;
 if (QueryCard <> nil) then
  QueryCard.CardClear;
end;

function TqaMgrSearch.FindAttr(const aTagName : Il3CString): IqaReq;
  {* - Возвращает атрибут по имени. }

 function DoReq(const aReq: IqaReq): Boolean;
 begin
  Result := not l3Same(aReq.TagName, aTagName, true);
  if not Result then
   FindAttr := aReq;
 end;

begin
 Result := nil;
 IterateAttrsF(l3L2FA(@DoReq));
end;

procedure TqaMgrSearch.ClearAttrs;
  {-}

 function DoReq(const aReq: IqaReq): Boolean;
 begin
  Result := true;
  aReq.ReqClear;
 end;

{$IfDef Monitorings}
var
 l_CR : IqaReq;
{$EndIf Monitorings}
begin
 IterateAttrsF(l3L2FA(@DoReq));
{$IfDef Monitorings}
 l_CR := ChangableReq;
 if (l_CR <> nil) then
  l_CR.MakeFieldValue;
{$EndIf Monitorings}
end;

function TqaMgrSearch.GettingFromView: Boolean;
  {-}
begin
 Result := (f_GettingAttributesFromView > 0);
end;

procedure TqaMgrSearch.StartGettingFromView;
  {-}
begin
 Inc(f_GettingAttributesFromView);
 QueryCard.StartLongOperation;
end;

procedure TqaMgrSearch.FinishGettingFromView;
  {-}
begin
 QueryCard.EndLongOperation;
 Dec(f_GettingAttributesFromView);
end;

function GetAdditionalFilter(const aTagName   : Il3CString;
                             const aQueryType : TlgQueryType): TnsFilterType;
begin
 Case aQueryType of
  lg_qtLegislationReview:
  begin
   if l3Same(aTagName, AT_CLASS) or
      l3Same(aTagName, AT_CLASS_REVIEW) then
    Result := ns_ftTrim
   else
   if (l3Same(aTagName, AT_SOURCE) or
       l3Same(aTagName, AT_SOURCE_REVIEW) OR
       l3Same(aTagName, AT_PREFIX_REVIEW)) then
    Result := ns_ftTrimLeaf
   else
    Result := ns_ftNone;
  end;//lg_qtLegislationReview
  lg_qtAttribute:
  begin
   if l3Same(aTagName, AT_PREFIX) then
    Result := ns_ftTrimLeaf
   else
    Result := ns_ftNone;
  end;//lg_qtAttribute
  else
   Result := ns_ftNone;
 end;//Case aQueryType
 if l3Same(aTagName, AT_BASES) then
  Result := ns_ftBlocks;
end;

function TqaMgrSearch.GetTreeFromAdapter(const aReq: Il3CString): Il3SimpleTree;
  {* - Получает дерево с адаптера. }
var
 l_Filters : InsAttributeTreeFilters;
 l_Tree    : Il3FilterableTree;
 l_Index   : Integer;
 l_AF      : TnsFilterType;
begin
 Result := TnsAttributeTreeStruct.Make(aReq, False);
 if Supports(Result, Il3FilterableTree, l_Tree) and
    Supports(l_Tree.CloneFilters, InsAttributeTreeFilters, l_Filters) then
 begin
  l_AF := GetAdditionalFilter(aReq, QueryType);
  if (l_Filters.FilterType <> l_AF) then
   Result := l_Tree.MakeFiltered(l_Filters.SetFilterType(l_AF).
                                           SetContext(nil),
                                 nil,
                                 l_Index,
                                 True,
                                 true);
 end;//Supports(Result, Il3FilterableTree, l_Tree)..
end;

procedure TqaMgrSearch.IterateAttrsF(anAction : Tl3FreeAction);
  {-}
var
 I, J         : Integer;
 l_QueryGroup : IevQueryGroup;
 l_Req        : IqaReq;
begin
 if Assigned(anAction) then
  try
   if (f_QueryCard <> nil) then
   begin
    for I := 0 to f_QueryCard.GroupCount - 1 do
    begin
     l_QueryGroup := f_QueryCard.QueryGroup[I];
     try
      for J := 0 to l_QueryGroup.ReqCount - 1 do
      begin
       l_Req := TqaReq.Make(Self, l_QueryGroup.Req[J]);
       try
        if not anAction(Pointer(l_Req)) then
         Exit;
       finally
        l_Req := nil;
       end;//try..finally
      end;//for J
     finally
      l_QueryGroup := nil;
     end;//try..finally
    end;//for I
   end;//f_QueryCard <> nil
  finally
   l3FreeFA(anAction);
  end;//try..finally
end;

procedure TqaMgrSearch.InitFocus;
begin
 if NeedSettings then
  f_QueryCard.StartSetFocus;
end;

{$IFDEF Monitorings}
const
 cSrc : array [0..1] of string = (AT_ANNO_KIND, AT_ANNO_USER);
{$ENDIF Monitorings}

procedure TqaMgrSearch.EscPressed(const aField: IevEditorFieldWithTree);
  {-}
{$IFDEF Monitorings}
var
 l_CR : IqaReq;
{$ENDIF Monitorings}
begin
 {$IFDEF Monitorings}
 if l3SomeOf(aField.Req.ReqName, cSrc) then
 begin
  l_CR := ChangableReq;
  if (l_CR <> nil) then
   l_CR.MakeFieldValue;
 end;//l3Same(aField.Req.ReqName, cSrc[l_Index])
 {$ENDIF Monitorings}
end;

{$IFDEF Monitorings}
function TqaMgrSearch.ChangableReq: IqaReq;
  {* - Изменяющаеся значение при изменении реквизита. }
begin
 Result := FindAttr(nsCStr(cChangableReqName));
end;
{$ENDIF Monitorings}

function TqaMgrSearch.IsSomeFieldFilled(aElseDefaultValue: Boolean): Boolean;

 function DoReq(const aReq: IqaReq): Boolean;
 begin
  Result := not aReq.IsSet(aElseDefaultValue);
  if not Result then
   IsSomeFieldFilled := true;
 end;

begin
 Result := false;
 IterateAttrsF(l3L2FA(@DoReq));
end;

procedure TqaMgrSearch.Load;

 function DoReq(const aReq: IqaReq): Boolean;
 begin
  Result := true;
  aReq.Load;
 end;

{$IFDEF Monitorings}
var
 CR : IqaReq;
{$EndIF Monitorings}
begin
 QueryCard.StartLongOperation;
 try
  IterateAttrsF(l3L2FA(@DoReq));
  {$IFDEF Monitorings}
  CR := ChangableReq;
  if (CR <> nil) then //Значение по умолчанию для поля "Тема"
   CR.MakeFieldValue;
  {$ENDIF Monitorings}
  Modified := False;
 finally
  QueryCard.EndLongOperation;
 end;// asLockedPaint;
end;

function TqaMgrSearch.Get_IsNew: Boolean;
begin
 Result := f_IsQueryNew;
end;

function TqaMgrSearch.Get_Modified: Boolean;
begin
 Result := (f_Modified > 0);
end;

procedure TqaMgrSearch.Set_Modified(Value: Boolean);

 function DoReq(const aReq: IqaReq): Boolean;
 begin
  Result := true;
  aReq.Modified := Value;
 end;

begin
 if (Get_Modified <> Value) then
 begin
  Inc(f_InModifiedChanged);
  try
   IterateAttrsF(l3L2FA(@DoReq));
  finally
   Dec(f_InModifiedChanged);
  end;//try..finally
  CallModifiedChanged;
 end;//Get_Modified <> Value
end;

procedure TqaMgrSearch.CallModifiedChanged;
 {-}
begin
 if (f_InModifiedChanged <= 0) then
 begin
  Inc(f_InModifiedChanged);
  try
   if Assigned(f_OnModifiedChanged) then
    f_OnModifiedChanged(Self);
  finally
   Dec(f_InModifiedChanged);
  end;//try..finally
 end;//f_InModifiedChanged <= 0
end;

procedure TqaMgrSearch.ModifiedChanged(aValue: Boolean);
 {-}
begin
 if aValue then
  Inc(f_Modified)
 else
  Dec(f_Modified);  
 CallModifiedChanged;
end;

function TqaMgrSearch.MakeDescriptionsSettingId: Il3CString;
begin
 Result := l3Fmt('%s/%s', [pi_CollapsedDescriptions, f_FormName]);
end;

procedure TqaMgrSearch.Set_Query(const Value: IQuery);
{$IFDEF Monitorings}
var
 CR : IqaReq;
{$EndIF Monitorings}
begin
 if (Value <> nil) then
 begin
  if f_Query <> nil then
   f_Query.Clear;
  if not f_FromHistory then
  begin
   ClearAttrs;
   Self.QueryCard.CardClear;
  end;//not f_FromHistory
  f_Query := nil;
  f_Query := Value;
  Load;
  f_IsQueryNew := False; //Формирование значения поля для загруженного запроса
  {$IFDEF Monitorings}
  CR := ChangableReq;
  if (CR <> nil) then
  begin
   CR.MakeFieldValue;
   InitFocus;
  end;//CR <> nil
  {$ENDIF Monitorings}
 end//Value <> nil
 else
 begin
  f_IsQueryNew := True; //Чистая КЗ
  f_Query := nil;
 end;//Value <> nil
end;

procedure TqaMgrSearch.CheckAttrs;
  {-}

 function DoCheckReq(const aReq: IqaReq): Boolean;
 begin
  Result := true;
  aReq.CheckAttr;
 end;

begin
 IterateAttrsF(l3L2FA(@DoCheckReq));
end;

function TqaMgrSearch.Save(aIgnoreError: Boolean): Boolean;

 function DoReq(const aReq: IqaReq): Boolean;
 begin
  Result := true;
  aReq.Save;
 end;

begin
 FinishEntering;
 Result := True;
 try
  CheckAttrs;
  {$If not (defined(Monitorings) or defined(Admin))}
  if not aIgnoreError then
   CheckMorpho;
  {$IfEnd} 
 except
  on E: EqaException do
  begin
   Result := False;
   if not aIgnoreError then
   begin
    with E.ErrorControl do
    begin
     with Req.Group do
      if not Expanded then
       Expanded := True;
     Req.SetFocus(E.ErrorControl, True);
    end;//with E.ErrorControl
    raise;
   end;//not aIgnoreError
  end;//on E: EqaException
 end;//try..except
 // При переключении конфигурации запрос мог достаться от карточки 5.х с типом
 // QT_OLD_ATTRIBUTE, поэтому создаем новый запрос
(* if f_Query.GetType = QT_OLD_ATTRIBUTE then
  {$If not defined(Admin)}
  nsQuery.CreateQuery(f_Query, BusinessQueryToAdapterQuery(f_QueryType));
  {$Else}
  Assert(false);
  {$IfEnd}*)
 f_Query.Clear;
 IterateAttrsF(l3L2FA(@DoReq));
end;//Save

procedure TqaMgrSearch.FinishEntering;
begin
 (f_QueryCard As InevControlListner).HideDroppedControl(True);  
end;//FinishEntering

procedure TqaMgrSearch.ReadSettings;
const
 FuckMagic = 'NOT DEFINED';
var
 l_Groups       : Il3CString;
 l_Index        : Integer;
 l_DIdx         : Integer;
 l_GroupCount   : Integer;
 l_Descriptions : Il3CString;
begin
 if NeedSettings then
 begin
  g_Dispatcher.FormDispatcher.Lock;
  try
   l_GroupCount := f_QueryCard.GroupCount - 1;
   l_Descriptions := afw.Settings.LoadString(nsAStr(MakeDescriptionsSettingId).S,'');
   for l_Index := 0 to l_GroupCount do
    with f_QueryCard.QueryGroup[l_Index] do
     for l_DIdx := 0 to DescriptionReqCount-1 do
      with DescriptionReq[l_DIdx] do
       Collapsed := (l3Pos(l_Descriptions,
                           l3Cat([nsCStr(' '),
                                  l3Upper(ReqName),
                                  nsCStr(' ')])) >= 0);
   l_Groups := afw.Settings.LoadString(nsAStr(MakeGroupsSettingId).S, FuckMagic);
   // читаем из настроек
   if (l_GroupCount = 0) then
    f_QueryCard.QueryGroup[0].Expanded := True
   else
    if (f_QueryType = lg_qtPostingOrder) then
     f_QueryCard.ChangeStateAll(True)
    else
     if not l3Same(l_Groups, FuckMagic) then
      for l_Index := 0 to l_GroupCount do
       with f_QueryCard.QueryGroup[l_Index] do
        Expanded := (l3Pos(l_Groups, GroupName) >= 0)
     // при первой загрузке "Расширенные реквизиты свернуты"
     else
     if (l_GroupCount >= 0) then
     begin
      // свернём все
      f_QueryCard.ChangeStateAll(False);
      // развернём только первую
      f_QueryCard.QueryGroup[0].Expanded := True;
     end;//l_GroupCount >= 0
  finally
   g_Dispatcher.FormDispatcher.UnLock;
  end;// g_Dispatcher.FormDispatcher.Lock;
 end;//NeedSettings
end;//ReadSettings

procedure TqaMgrSearch.WriteSettings;
var
 l_Index        : Integer;
 l_DIdx         : Integer;
 l_Groups       : Il3CString;
 l_Descriptions : Il3CString;
 l_Group        : IevQueryGroup;
begin
 if NeedSettings AND (f_QueryCard <> nil) then
 begin
  l_Descriptions := nil;
  l_Groups := nil;
  // Запишем группы, которые развернуты
  for l_Index := 0 to f_QueryCard.GroupCount - 1 do
  begin
   l_Group := f_QueryCard.QueryGroup[l_Index];
   try
    for l_DIdx := 0 to l_Group.DescriptionReqCount-1 do
     with l_Group.DescriptionReq[l_DIdx] do
      if Collapsed then
       l_Descriptions := l3Cat([l_Descriptions,
                                nsCStr(' '),
                                l3Upper(ReqName),
                                nsCStr(' ')]);
    if l_Group.Expanded then
     l_Groups := l3Cat([l_Groups, l_Group.GroupName]);
   finally
    l_Group := nil;
   end;//try..finally
  end;//for l_Index
  // Запомним закрытые группы в настройках
  afw.Settings.SaveString(nsAStr(MakeGroupsSettingId).S, l_Groups);
  afw.Settings.SaveString(nsAStr(MakeDescriptionsSettingId).S, l_Descriptions);
 end;//NeedSettings
end;

function TqaMgrSearch.MakeGroupsSettingId: Il3CString;
begin
 Result := l3Fmt('%s/%s', [pi_ClosedGroups, f_FormName]);
end;

function TqaMgrSearch.Get_FromHistory: Boolean;
begin
 Result := f_FromHistory;
end;

procedure TqaMgrSearch.Set_FromHistory(const Value: Boolean);
begin
 f_FromHistory := Value;
end;

procedure TqaMgrSearch.FocusStartField;

 {$IFNDEF Monitorings}
 function DoReq(const aReq: IqaReq): Boolean;
 begin
  Result := false;
  // - прекращаем на первом реквизите
  aReq.EditorReq.FirstField.SetFocus;
 end;
 {$EndIF  Monitorings}

{$IFDEF Monitorings}
var
 l_Req : IqaReq;
{$EndIF Monitorings}
begin
 {$IFDEF Monitorings}
 l_Req := FindAttr(nsCStr(cChangableReqName));
 if (l_Req <> nil) then
  l_Req.EditorReq.FirstField.SetFocus;
 {$ELSE}
 IterateAttrsF(l3L2FA(@DoReq));
 {$ENDIF Monitorings}
end;

procedure TqaMgrSearch.DeleteValue(const aView: InevView);
var
 l_Field: IevEditorControlField;
 l_Req : IevReq;
begin
 l_Field := GetCurrentField;
 if Assigned(l_Field) then
 begin
  l_Req := GetCurrentEditorReq;
  if Assigned(l_Req) then
   l_Req.DeleteField(aView, l_Field, True);
 end;
end;

procedure TqaMgrSearch.AddValue(const aView: InevView);
var
 l_Req : IevReq;
begin
 l_Req := GetCurrentEditorReq; 
 if l_Req <> nil then
  l_Req.AddField(aView, True);
end;

procedure TqaMgrSearch.DeleteAll;
var
 l_Req : IqaReq;
begin
 l_Req := GetCurrentReq; 
 if l_Req <> nil then
  l_Req.ReqClear;
end;

procedure TqaMgrSearch.OpenSelectWindow;
var
 l_Req : IqaReq;
begin
 l_Req := GetCurrentReq; 
 if l_Req <> nil then
  l_Req.OpenSelectWindow;
end;

function TqaMgrSearch.GetCurrentReq: IqaReq;
var
 l_CustCtrl : IevCustomEditorControl; 
 l_Control  : IevEditorControl;
begin
 l_CustCtrl := QueryCard.GetStateControl;
 if (l_CustCtrl <> nil) and l_CustCtrl.Visible then
 begin
  if Supports(l_CustCtrl, IevEditorControl, l_Control) then
   Result := TqaReq.Make(Self, l_Control.Req)
  else
   Result := nil;
 end//(l_CustCtrl <> nil) and l_CustCtrl.Visible 
 else 
  Result := nil; 
end;

function TqaMgrSearch.GetCurrentEditorReq: IevReq;
var
 l_CustCtrl : IevCustomEditorControl;
 l_Control  : IevEditorControl;
begin
 l_CustCtrl := QueryCard.GetStateControl;
 if (l_CustCtrl <> nil) and l_CustCtrl.Visible then
 begin
  if Supports(l_CustCtrl, IevEditorControl, l_Control) then
   Result := l_Control.Req
  else
   Result := nil;
 end
 else
  Result := nil;
end;

function TqaMgrSearch.GetCurrentField: IevEditorControlField;
var
 l_CustCtrl : IevCustomEditorControl;
 l_Control  : IevEditorControl;
begin
 l_CustCtrl := QueryCard.GetStateControl;
 if (l_CustCtrl <> nil) and l_CustCtrl.Visible then
 begin
  if Supports(l_CustCtrl, IevEditorControl, l_Control) then
   if l_Control.Field = nil then
    l_Control.QueryInterface(IevEditorControlField, Result)
   else
    Result := l_Control.Field
 end
 else
  Result := nil;
end;

function TqaMgrSearch.Get_QueryCard: IevQueryCard;
begin
 Result := f_QueryCard;
end;

procedure TqaMgrSearch.FinishOpenTree(const aRoot : INodeBase;
                                      const aReq  : IqaReq);
var
 l_ReqAttr : IqaReqAttribute;
begin
 QueryCard.Editor.Selection.Unselect;
 if (aReq <> nil) and Supports(FindAttr(aReq.TagName), IqaReqAttribute, l_ReqAttr) then //Его может и не быть после обновления.
 try
  l_ReqAttr.GetAttributesFromView(aRoot);
 finally
  l_ReqAttr := nil;
 end;//aReq <> nil
end;

procedure TqaMgrSearch.DateQuery(const aValue: IqaDateReq);
var
 l_Req       : IqaReq;
 l_DateField : IevEditorCalendarField;
 l_TagName   : Il3CString;
 l_DateReq   : IqaDateReq;
 l_Holder    : IqaDateReqDataHolder;
begin
 if Assigned(f_OnDateQuery) and Supports(aValue, IqaReq, l_Req) then
 begin
  l_TagName := l_Req.TagName;
  //Заплатка: после откатки поле может содержать старую дату.
  l_Req.EditorReq.FirstField.CheckDataText;
  if Supports(l_Req.EditorReq.FirstField, IevEditorCalendarField, l_DateField) then
   l_DateField.GetOtherField.CheckDataText;
  //--Заплатка
  l_Req := nil;
  l_Holder := TqaDateReqDataHolder.Make(aValue);
  f_OnDateQuery(l_Holder);
  if l_Holder.IsOk then
  begin
   l_Req := FindAttr(l_TagName);
   if Supports(l_Req, IqaDateReq, l_DateReq) then
   begin
    l_DateReq.StartDate := l_Holder.StartDate;
    l_DateReq.EndDate := l_Holder.EndDate;
    with l_Req.EditorReq do
     if l_Holder.IsStartDateEmpty and Supports(FirstField, IevEditorCalendarField, l_DateField) then
      SetFocus(l_DateField.GetOtherField)
     else
      SetFocus(l_DateField);
   end;
  end;
 end;
end;

procedure TqaMgrSearch.ExecQuery;
begin
 if Assigned(f_OnNeedExecQuery) then
  f_OnNeedExecQuery(Self);
end;

procedure TqaMgrSearch.InitUpdate;
begin
 f_QueryCard := nil;
end;

{$If not Defined(Admin) AND not Defined(Monitorings)}
function TqaMgrSearch.Get_HistoryList: IvcmStrings;
begin
 Assert(Assigned(f_ContextHistory));
 Result := f_ContextHistory.History;
end;
{$IfEnd}

procedure TqaMgrSearch.LimitCharsReached(const aControl: IevEditorControl);
begin
 vcmSay(err_LimitCharsReached,[aControl.MaxLength]);
end;

function TqaMgrSearch.ModelListner(const aReq: IevReq): IevModelListner;
  {-}
begin
 if (aReq = nil) then
  Result := nil
 else
  Supports(TqaReq.Make(Self, aReq), IevModelListner, Result);
end;
  
function TqaMgrSearch.NeedSettings: Boolean;
begin
 Result := not (f_QueryType in [lg_qtSendConsultation]);
end;

{$IFDEF Monitorings}
function TqaMgrSearch.GetName4Query: Il3CString;
var
 l_Field : IevEditorControlField;
 CR      : IqaReq;
begin
 CR := ChangableReq;
 Assert(CR <> nil);
 l_Field := CR.EditorReq.FirstField;
 if l_Field.IsFieldEmpty then
  CR.MakeFieldValue;
 Result := l_Field.Text;
end;
{$ENDIF Monitorings}

// start class TqaReq

function TqaReq.BeforeGroupCollapse: Boolean;
begin
 Result := True;
end;

procedure TqaReq.CheckAttr;
begin
 if f_EditorReq.IsRequired and not IsSet(False) then
  raise EqaRequiredValue.CreateFmt(EditorReq.FirstField,
                                   vcmConstString(str_RequiredValue),
                                   	          [nsEStr(EditorReq.ReqCaption)]);
end;

procedure TqaReq.Cleanup;
begin
 f_EditorReq := nil;
 f_MgrSearch := nil;
 inherited;
end;

procedure TqaReq.Clear;
begin
 ReqClear;
 Modified := True;
 inherited;
end;

constructor TqaReq.Create(const aMgrSearch : IqaMgrSearch;
                          const aEditorReq : IevReq);
begin
 inherited Create;
 f_MgrSearch := aMgrSearch;
 f_EditorReq := aEditorReq;
end;

procedure TqaReq.DoOperateChanged;
begin
 {$IFDEF Monitorings}
 if Modified then
  MakeChangedReq;
 {$ENDIF Monitorings}
end;

function TqaReq.GetReqAsString(const aSeparator: Il3CString): Il3CString;
begin
 Result := nil;
end;

function TqaReq.IsEditEmpty: Boolean;
  {-}
begin
 Result := not IsSet(True);
end;

function TqaReq.IsSet(aElseDefaultValue: Boolean): Boolean;
  {-}
begin
 Result := evIsSomeFieldFilled(f_EditorReq, aElseDefaultValue);
end;

procedure TqaReq.Load;
begin
end;

{$IFDEF Monitorings}
procedure TqaReq.MakeFieldValue;
begin

end;
{$EndIF Monitorings}

procedure TqaReq.OpenSelectWindow;
begin

end;

function TqaReq.Get_Modified: Boolean;
begin
 Result := f_EditorReq.Para.BoolA[k2_tiModified];
end;

procedure TqaReq.Set_Modified(Value: Boolean);
begin
 with f_EditorReq.Para do
  if (BoolA[k2_tiModified] <> Value) then
  begin
   BoolA[k2_tiModified] := Value;
   if Assigned(f_MgrSearch) then
    f_MgrSearch.ModifiedChanged(Value);
  end;//BoolA[k2_tiModified] <> Value
end;

procedure TqaReq.ReqClear;
begin

end;

procedure TqaReq.DeleteEmptyValues;
var
 l_Index    : Integer;
 l_ComboField : IevEditorFieldWithTree;
begin
 if f_EditorReq.FieldsCount > 0 then
  for l_Index := f_EditorReq.FieldsCount - 1 downto 0 do
   if Supports(f_EditorReq.Fields[l_Index], IevEditorFieldWithTree, l_ComboField) and
      l_ComboField.IsFieldEmpty then
    f_EditorReq.DeleteField(nil, f_EditorReq.Fields[l_Index]);
end;

procedure TqaReq.Save;
begin
 DeleteEmptyValues;
 if IsSet then
  SaveReq;
 Modified := false;
end;

class function TqaReq.Make(const aMgrSearch : IqaMgrSearch;
                           const aEditorReq : IevReq): IqaReq;
var
 l_Req      : TqaReq;
 l_CType    : TevControlType;
 l_ReqClass : TqaReqClass;
 l_EdReq    : IevComboReq;
begin
 if (aEditorReq <> nil) then
  l_CType := aEditorReq.FirstField.ControlType
 else
  l_CType := ev_ctCombo;
 case l_CType of
  ev_ctEdit:
   l_ReqClass := TqaReqStr;
  ev_ctEmailEdit:
   l_ReqClass := TqaReqEMail;
  ev_ctMemoEdit:
   l_ReqClass := TqaReqMemo;
  ev_ctCombo:
  begin
   if Supports(aEditorReq, IevComboReq, l_EdReq) then
   begin
    if l_EdReq.IsContext then
     l_ReqClass := TqaReqContext
    else
    if aEditorReq.Para.BoolA[k2_tiNumList] then
     l_ReqClass := TqaReqNum
    else
     l_ReqClass := TqaReqAttribute;
   end//Supports(aEditorReq, IevComboReq, l_EdReq)
   else
    l_ReqClass := TqaReqAttribute;
  end;//ev_ctCombo
  ev_ctCalEdit:
   l_ReqClass := TqaReqDate;
  ev_ctPhoneEdit:
   l_ReqClass := TqaReqPhone;
  else
   l_ReqClass := nil;
 end;//case l_CType
 Assert(Assigned(l_ReqClass), caUnsuppotedAttributeType);
 l_Req := l_ReqClass.Create(aMgrSearch, aEditorReq);
 try
  Result := l_Req;
 finally
  l3Free(l_Req);
 end;//try..finally 
end;

function TqaReq.Get_EditorReq: IevReq;
begin
 Result := f_EditorReq;
end;

function TqaReq.Get_TagCaption: Il3Cstring;
begin
 Result := f_EditorReq.ReqCaption;
end;

function TqaReq.Get_TagName: Il3CString;
begin
 Result := f_EditorReq.ReqName;
end;

{$IFDEF Monitorings}
procedure TqaReq.MakeChangedReq;
  {-}
var
 l_CR : IqaReq;
begin
 if l3SomeOf(TagName, cSrc) then
 begin
  l_CR := f_MgrSearch.ChangableReq;
  if (l_CR <> nil) then
   l_CR.MakeFieldValue;
 end;//l3Same(TagName, cSrc[l_Index])
end;
{$ENDIF Monitorings}

function TqaReq.Get_Multy: Boolean;
  {-}
var
 l_EdComboReq : IevComboReq;
begin
 if not Supports(f_EditorReq, IevComboReq, l_EdComboReq) then
  Assert(false);
 Result := l_EdComboReq.IsMulty;
end;

function TqaReq.CanAdd: Boolean;
begin
 Result := False;
end;

function TqaReq.CanOpenTree: Boolean;
begin
 Result := False;
end;

function TqaReq.IsAttrValid: Boolean;
var
 l_Exception: EaqExceptionClass;
 l_Message: String;
 l_Control: IevEditorControlField;
begin
 Result := CheckFromControl(l_Exception, l_Message, l_Control);
end;

function TqaReq.CheckFromControl(out aExceptionClass : EaqExceptionClass;
                                 out aMessage        : String;
                                 out aControl        : IevEditorControlField): Boolean;
begin
 aExceptionClass := nil;
 aMessage := '';
 aControl := nil;
 Result := True;
end;

{ TqaCustomReqContext }

function TqaCustomReqContext.GetReqAsString(const aSeparator: Il3CString): Il3CString;
var
 l_Index : Integer;
 l_Count : Integer;
 l_Field : IevEditorControlField;
begin
 l_Count := f_EditorReq.FieldsCount - 1;
 // Сформируем строку контекста из всех строк определенных пользователем
 for l_Index := 0 to l_Count do
 begin
  l_Field := f_EditorReq.Fields[l_Index];
  try
   l_Field.Text := nsContextUtils.CheckContext(l_Field.Text);
   Result := nsContextUtils.AddPhrase(Result, l_Field.Text);
   if (l_Index < l_Count) then
    Result := l3Cat([Result, aSeparator]);
  finally
   l_Field := nil;
  end;//try..finally
 end;//for l_Index
end;

procedure TqaCustomReqContext.Load;
var
 l_Context    : Il3CString;
 l_Index      : Integer;
 l_Count      : Integer;
 l_ED         : IevEditorControlField;
 l_Phrases    : IvcmStrings;
 l_FieldCount : Integer;
begin 
 if LoadContextNew(f_MgrSearch.Query, Get_TagName, l_Context) then
 begin  
  l_Phrases := nsContextUtils.ContextToPhrases(l_Context);
  l_FieldCount := f_EditorReq.FieldsCount;
  try
   // Загрузим фразы
   l_Count := l_Phrases.Count - 1;
   for l_Index := 0 to l_Count do
   begin
    if (l_Index = 0) or (l_FieldCount > l_Index) then
     with f_EditorReq do
     begin
      if (l_Index = 0) then
       l_ED := FirstField
      else
       l_ED := Fields[l_Index];
      try
       l_ED.Text := l_Phrases.ItemC[l_Index];
      finally
       l_ED := nil;
      end;//try..finally
     end//with f_EditorReq
    else
     with f_EditorReq do
     begin
      AddField(nil);
      l_ED := LastField;
      try
       l_ED.Text := l_Phrases.ItemC[l_Index];
      finally
       l_ED := nil;
      end;//try..finally
     end;//with f_EditorReq
   end;//for l_Index
  finally
   l_Phrases := nil;
  end;//try..finally  
  EditorReq.Group.Expanded := True;  
 end;//LoadContextNew
 inherited;
end;

procedure TqaCustomReqContext.SaveReq;
begin
 {$If not defined(Admin)}
 SaveContextNew(f_MgrSearch.Query, Get_TagName, GetReqAsString(nil));
 {$Else}
 Assert(false);
 {$IfEnd}
end;

procedure TqaReqAttribute.Load;
var
 l_List       : TqaAttrInfoList;
 l_Index      : Integer;
 l_Node       : INodeBase;
 l_Count      : Integer; 
 l_FieldCount : Integer;
 l_FieldTree  : IevEditorFieldWithTree;
 l_ED         : IevEditorControlField;
 l_Tree       : Il3SimpleTree;
begin
 l_List := TqaAttrInfoList.Make;
 try
  {$IfNDef Admin}
  LoadDictionaryNew(l_List, f_MgrSearch.Query, Get_TagName);
  {$Else   Admin}
  Assert(false);
  {$EndIf  Admin}
  l_Count := l_List.Count - 1;
  l_FieldCount := f_EditorReq.FieldsCount;
  Assert((l_FieldCount = 1) OR (l_Count >= l_FieldCount - 1));
  // - http://mdp.garant.ru/pages/viewpage.action?pageId=227478809&focusedCommentId=227967127#comment-227967127
  for l_Index := 0 to l_Count do
  begin
   { Новый TasField }
   if (l_Index = 0) then
    l_ED := f_EditorReq.FirstField
   else
   if (l_FieldCount > l_Index) then
    l_ED := f_EditorReq.Fields[l_Index]
   else
   begin
    f_EditorReq.AddField(nil);
    l_ED := f_EditorReq.LastField;
   end;//l_FieldCount > l_Index
   try
    { Введена маска }
    if not l3IsNil(TqaAttrInfo(l_List[l_Index]).Mask) then
     l_ED.Text := TqaAttrInfo(l_List[l_Index]).Mask
    { Выбран конкретный элемент }
    else
     with TqaAttrInfo(l_List[l_Index]) do
     begin
      if Supports(l_ED, IevEditorFieldWithTree, l_FieldTree) then
      try
       l_Tree := l_FieldTree.SourceTree;
       if Supports(l_Tree, Il3ExpandedSimpleTree) then
       begin
        // преобразуем ноду в IQuery в ноду в дереве
        // l_Node := GetTwinNode(l_Mgr.ComboBox.TreeStruct, NodeBase);
        // !! обход бага в дереве, связанного с тем, что ноды в View и IQuery - разные
        // поправить после правки бага в дереве
        {$IFDEF NEW_TREE}
        LoadField(l_FieldTree, Oper, NodeBase);
        {$ELSE}
        l_Node := GetTwinNode(TnsAttributeTreeStruct.Make(TagName, l_Tree.ShowRoot), NodeBase);
        try
         LoadField(l_FieldTree, Oper, l_Node);
        finally
         l_Node := nil;
        end;//try..finally
        {$ENDIF NEW_TREE}
       end;//Supports(l_Tree, Il3ExpandedSimpleTree)
      finally
       l_FieldTree := nil;
      end;//try..finally
     end;//with TqaAttrInfo(l_List[l_Index])
   finally
    l_ED := nil;
   end;//try..finally
  end;//for l_Index
  if (EditorReq.FieldsCount > 0) and IsSet(True) then
  begin
   EditorReq.Group.Expanded := True;   
   //EditorReq.Valid := True; //Проверяем загруженные данные 
  end;//EditorReq.FieldsCount > 0..
 finally
  vcmFree(l_List);
 end;//try..finally
 isAttrValid;
 inherited;
end;

function TqaCustomReqContext.CanAdd: Boolean;
begin
 Result := True;
end;

procedure TqaCustomReqContext.EnterPressed;
begin
 f_MgrSearch.ExecQuery; 
end;

function TqaCustomReqContext.AnalysString(const aValue : Il3CString;
                                    out aRslt    : Il3CString): Boolean;
var
 l_ControlListner: InevControlListner;
begin
 if Supports(EditorReq.QueryCard, InevControlListner, l_ControlListner)
  and l_ControlListner.IsPasting then
 begin
  {$If not defined(Admin)}
  aRslt := RepairContext6x(aValue);
  {$Else}
  Assert(false);
  {$IfEnd}
  Result := not l3Same(aRslt, aValue);
 end//Supports(EditorReq.QueryCard, InevControlListner, l_ControlListner)
 else
  Result := inherited AnalysString(aValue, aRslt);
end;

constructor TqaCustomReqContext.Create(const aMgrSearch : IqaMgrSearch;
                                 const aEditorReq : IevReq);
var
 i           : Integer;
 l_FieldTree : IevEditorFieldWithTree;
begin
 inherited;
 for i := 0 to f_EditorReq.FieldsCount - 1 do
  if Supports(f_EditorReq.Fields[i], IevEditorFieldWithTree, l_FieldTree) then
   try
    l_FieldTree.ComboStyle := ev_cbDropDown;
   finally
    l_FieldTree := nil;
   end;//try..finally
end;

// start class TqaAttrInfo

constructor TqaAttrInfo.Create(const aOper : TLogicOperation = loNone;
                               const aNode : INodeBase = nil;
                               const aMask : Il3CString = nil);
  {* - Создает класс и инициализирует значениями. }
begin
 inherited Create;
 f_Oper := aOper;
 f_Mask := aMask;
 f_Node := aNode;
end;

procedure TqaAttrInfo.Cleanup;
  // override;
  {-}
begin
 f_Mask := nil;
 f_Node := nil;
 inherited;
end;

procedure TqaCustomReqContext.FillReqListAsString(
  const aList: Il3StringsEx);
var
 l_Index : Integer;
 l_Count : Integer;
 l_Field : IevEditorControlField;
begin
 l_Count := f_EditorReq.FieldsCount - 1;
 // Сформируем строку контекста из всех строк определенных пользователем
 for l_Index := 0 to l_Count do
 begin
  l_Field := f_EditorReq.Fields[l_Index];
  try
   l_Field.Text := nsContextUtils.CheckContext(l_Field.Text);
   if not l_Field.IsFieldEmpty then
    aList.Add(l_Field.Text);
  finally
   l_Field := nil;
  end;//try..finally
 end;//for l_Index
end;

{ TqaReqAttribute }

function TqaReqAttribute.FieldLogicOperation(
  const aValue: IevEditorFieldWithTree): TLogicOperation;
begin
 Result := StateIndex2LogicState(aValue.LogicalState);
end;

procedure TqaReqAttribute.GetAttributesFromView(const aRoot : INodeBase);
var
 l_Index        : TLogicOperation;
 l_Iterator     : INodeIterator;
 l_NodeBase     : INodeBase;
 l_Cursor       : TCursor;
 l_FieldCount   : Integer;
 //* - Количество выбранных элементов. Для удаления лишних полей.
 l_Count        : Integer;
 l_EdFieldCount : Integer;

 procedure AddField(const aNodeBase  : INodeBase;
                    const aOperation : TLogicOperation);
 var
  l_Field   : IevEditorFieldWithTree;
  l_EdField : IevEditorControlField;
 begin
  // счетчик загруженных полей
  Inc(l_FieldCount);
  // используем существующее поле
  if (l_FieldCount <= f_EditorReq.FieldsCount) then  
   f_EditorReq.Fields[l_FieldCount - 1].QueryInterface(IevEditorFieldWithTree, l_Field)
  // новое поле 
  else
   begin
    l_EdField := f_EditorReq.AddField(nil);    
    Assert(Assigned(l_EdField), caFieldNotAdded);
    try
     l_EdField.QueryInterface(IevEditorFieldWithTree, l_Field);
    finally
     l_EdField := nil;
    end;
   end;
  try
   Assert(Assigned(l_Field), caFieldNotInitialized);
   // покажем значение
   LoadField(l_Field, aOperation, aNodeBase);
   f_EditorReq.SetFocus(l_Field, True);
   f_EditorReq.UpdateState(l_Field, nil);
  finally
   l_Field := nil;
  end;
 end;

begin
 l_EdFieldCount := f_EditorReq.FieldsCount - 1;
 l_FieldCount := 0;
 // не удаляем значения, используем существующие поля ввода
 l_Cursor := Screen.Cursor;
 Screen.Cursor := crHourGlass;
 try
  f_MgrSearch.StartGettingFromView;
  try
   // первая операция
   l_Index := Low(TLogicOperation);
   // пройдем по списку итераторов
   while True do
   begin
    if l_Index <> loNone then
    begin
     // итератор
     l_Iterator := GetOperationIterator(Root, l_Index);
     try
      // узлы
      l_Iterator.GetNext(l_NodeBase);
      while Assigned(l_NodeBase) do
      begin
       try
        // создадим поле ввода
        AddField(l_NodeBase, l_Index);
       finally
        l_NodeBase := nil;
       end;
       l_Iterator.GetNext(l_NodeBase);
      end;//while Assigned(l_NodeBase) do
     finally
      l_Iterator := nil;
     end;//try..finally
    end;
    if l_Index < High(TLogicOperation) then
     Inc(l_Index)
    else
     Break;
   end;//while l_Index < Pred(aParams.Count) do
   // удалим "лишние поля"
   if l_FieldCount > 0 then
    for l_Count := l_EdFieldCount downto l_FieldCount do
     f_EditorReq.DeleteField(nil)
   else
    ReqClear;
   EditorReq.UpdateState(EditorReq.FirstField, nil);
   EditorReq.UpdateState(EditorReq.LastField, nil);
  finally
   f_MgrSearch.FinishGettingFromView;
  end;//try..finally
  DoOperateChanged;
  // установим фокус в последнем элементе
  f_EditorReq.SetFocus(f_EditorReq.LastField);
 finally
  Screen.Cursor := l_Cursor;
 end;//Screen.Cursor := crHourGlass;
end;

procedure TqaReqAttribute.LoadField(const aValue: IevEditorFieldWithTree;
  aLogicOper: TLogicOperation; const aNode: INodeBase);
var
 l_State : Integer;
 l_Node  : Il3SimpleNode;
begin
 l_State := Ord(aLogicOper) - 1; //loNone - не учитываем
 l_Node := TnsINodeWrap.Make(aNode);
 try
  aValue.ShowNode(l_Node); 
  aValue.LogicalState := l_State;
 finally
  l_Node := nil;
 end; 
end;

procedure TqaReqAttribute.OpenSelectWindow;
begin  
 SetAttributesToView; 
 if DoShowTree(TagName, AdditionalFilter) then
  f_MgrSearch.FinishOpenTree(Root, Self);
end;

function TqaReqAttribute.Root: INodeBase;
begin
 Result := TnsAttributeTreeCacheNew.Instance.AttributeRoot[TagName];
end;

procedure TqaReqAttribute.SaveFieldToQuery(const aValue: IevEditorControlField);
var
 l_DictNode   : INodeBase;
 l_Node       : INodeBase;
 l_ComboField : IevEditorFieldWithTree;
begin   
 if Supports(aValue, IevEditorFieldWithTree, l_ComboField) then
 try
  if l_ComboField.IsFieldEmpty then
   l_ComboField.ClearText //Заточка для новой реакции на откатку, т.к. теперь
   //ядро не ждет никакой нотификации, то может получиться так, что текст
   //удален при нажатии "Ctrl + Z", а выбранный узел остался.
  else
  if evIsFieldSet(l_ComboField, false) then
  begin
   // Введено значение со звездочкой
   if l_ComboField.IsAsterisk then
    {$If not defined(Admin)}
    SaveContextNew(f_MgrSearch.Query, Get_TagName, aValue.Text)
    {$Else}
    Assert(false)
    {$IfEnd}
   // Выбрано конкретное значение
   else
   if aValue.Valid and Supports(l_ComboField.Value, INodeBase, l_DictNode) then
   begin
    try
     // !! обход бага в дереве, связанного с IQuery
     // убрать после правки.
     {$IFDEF NEW_TREE}
     SaveAttributeNew(f_MgrSearch.Query, Get_TagName, FieldLogicOperation(l_ComboField), l_DictNode);
     {$ELSE}
     l_Node := GetTwinNode(TnsAttributeTreeStruct.Make(Get_TagName, False), l_DictNode);
     if not Assigned(l_Node) then
      l_Node := l_DictNode;
     {$If not defined(Admin)}
     SaveAttributeNew(f_MgrSearch.Query, Get_TagName, FieldLogicOperation(l_ComboField), l_Node);
     {$Else}
     Assert(false);
     {$IfEnd}
     {$ENDIF NEW_TREE}
    finally
     l_DictNode := nil;
    end;//try..finally
   end;//if (aValue.IsValid) and ...
  end;//if evIsFieldSet(aValue) then
 finally
  l_ComboField := nil;
 end;//try..finally
end;

procedure TqaReqAttribute.SaveReq;
var
 l_Index    : Integer;
begin
 for l_Index := 0 to f_EditorReq.FieldsCount - 1 do
  SaveFieldToQuery(f_EditorReq.Fields[l_Index]);
end;

procedure TqaReqAttribute.SetAttributesToView;
var
 l_Index    : Integer;
 l_NodeBase : INodeBase;
 l_Count    : Integer;
 l_Field    : IevEditorFieldWithTree;
begin
 // Сбросим флаги
 DropAllOperations(Root);
 Root.SetAllFlag(FM_SELECTION, False); 
 l_Count := f_EditorReq.FieldsCount - 1;  
 // Установим флаги
 for l_Index := 0 to l_Count do
 begin
  if Supports(f_EditorReq.Fields[l_Index], IevEditorFieldWithTree, l_Field) then
   try
    if l_Field.IsFieldEmpty then
     l_Field.ClearText;
    if Supports(l_Field.Value, INodeBase, l_NodeBase) then
     try
      nsLogicOperationToFlags.SetLogicOperation(l_NodeBase,
        FieldLogicOperation(l_Field));
     finally
      l_NodeBase := nil;
     end;//try..finally
   finally
    l_Field := nil;
   end;//try..finally
 end;//for l_Index
end;

procedure TqaReqAttribute.AfterSetText(const aField: IevEditorControlField);
begin
 Modified := True;
 DoOperateChanged;
end;

function TqaReqAttribute.GetReqAsString(const aSeparator: Il3CString): Il3CString;
var
 i, l_Count        : Integer;
 l_Field           : IevEditorFieldWithTree;
 l_Str             : Il3CString;
 l_SpetialWasAdded : Boolean;
 l_SpetailLanguage : Boolean;
begin
 Result := nil;
 l_Count := f_EditorReq.FieldsCount - 1;
 l_SpetialWasAdded := False;
 l_SpetailLanguage := afw.Application.LocaleInfo.Language = afw_lngRussian;
 if (l_Count >= 0) then
  for i := 0 to l_Count do
  begin
   if Supports(f_EditorReq.Fields[i], IevEditorFieldWithTree, l_Field) then
   try
    if evIsFieldSet(l_Field, false) then
    begin
     if l_SpetailLanguage and
        (l3Same(TagName, AT_ANNO_KIND)) then //Для более короткого названия в мониторингах.
     begin
      l_Str := nsConvertAnnoKind(l_Field.Text);
      if not ((l3Same(l_Str, ccakRegionalLaw)) and
         l_SpetialWasAdded) then
      begin
       if not l3IsNil(Result) then
        Result := l3Cat([Result, aSeparator]);
       Result := l3Cat([Result, l_Str]);
      end;//not ((l3Same(l_Str.AsWStr, ccakRegionalLaw)) and
      if (l3Same(l_Str, ccakRegionalLaw)) then
       l_SpetialWasAdded := true;
     end//l_SpetailLanguage..
     else
     begin
      if not l3IsNil(Result) then
       Result := l3Cat([Result, aSeparator]);
      Result := l3Cat([Result, l_Field.Text]);
     end;//l_SpetailLanguage..
    end;//evIsFieldSet(l_Field)
   finally
    l_Field := nil;
   end;//try..finally
  end; //for i := 0 to ...*)
end;

function TqaReqAttribute.CanAdd: Boolean;
begin
 Result := IsAttrValid;
end;

function TqaReqAttribute.CanOpenTree: Boolean;
begin
 Result := True;
end;

procedure TqaReqAttribute.EnterPressed;
begin
 if not Multy then
  f_MgrSearch.ExecQuery
 else 
  OpenSelectWindow;
end;

procedure TqaReqAttribute.DoOperateChanged;
begin
 if not f_MgrSearch.GettingFromView then
  inherited DoOperateChanged;
end;

// start class TqaReqStr

function TqaReqStr.Get_Multy: Boolean;
begin
 Result := False;
end;

procedure TqaReqStr.Load;
var
 l_Context : Il3CString;
begin
 if LoadContextNew(f_MgrSearch.Query, Get_TagName, l_Context) then
  f_EditorReq.FirstField.Text := l_Context;
end;

{$IFDEF Monitorings}
procedure TqaReqStr.MakeFieldValue;

 function GetFieldValue: Il3CString;
 var
  i     : Integer;
  l_Req : IqaReq;
 begin
  for i := Low(cSrc) to High(cSrc) do
  begin
   l_Req := f_MgrSearch.FindAttr(nsCStr(cSrc[i]));
   try
    if (l_Req <> nil) then
    begin
     if (i > 0) and not l3IsNil(Result) then
      Result := l3Cat([l3Cat(Result, '. '), l_Req.GetReqAsString(nsCStr('. '))])
     else
      Result := l_Req.GetReqAsString(nsCStr('. '));
    end;//l_Req <> nil
   finally
    l_Req := nil;
   end;//try..finally
  end;//for i := 0 to ...
 end;

var
 l_Field : IevEditorControlField;
 l_Value : Tl3PCharLen;
begin
 if l3Same(TagName, cChangableReqName) then
 begin
  l_Field := f_EditorReq.FirstField;
  try
   l_Value := Tl3PCharLen(nsWStr(GetFieldValue));
   if not l3IsNil(l_Value) then
   begin
    with l_Field.Para do
    begin
     if l3Same(PCharLenA[k2_tiText], f_EditorReq.Para.PCharLenA[k2_tiDefaultText]) then
     begin
      PCharLenA[k2_tiText] := l_Value;
      Invalidate([nev_spExtent]);
      l_Field.Req.UpdateState(l_Field, nil);
     end;//l3Same..
    end;//with l_Field.Para
    f_EditorReq.Para.PCharLenA[k2_tiDefaultText] := l_Value;
   end;//not l3IsNil(l_Value)
  finally
   l_Field := nil;
  end;//try..finally
 end;//l3Same(TagName, cChangableReqName)
end;

procedure TqaReqStr.ReqClear;
begin
 if l3Same(TagName, cChangableReqName) then
  f_EditorReq.Para.PCharLenA[k2_tiDefaultText] := Tl3PCharLen(nsWStr(''));
 inherited ReqClear;
end;

{$ENDIF Monitorings}

// start class TqaReqDate

function TqaReqDate.BeforeGroupCollapse: Boolean;
begin
 Result := IsAttrValid;
end;

function TqaReqDate.CanOpenTree: Boolean;
begin
 Result := False;
end;

procedure TqaReqDate.CheckAttr;
var
 l_DateField: IevEditorCalendarField;
 l_Exception: EaqExceptionClass;
 l_Message: String;
 l_Control: IevEditorControlField;
begin
 inherited;
 if not CheckFromControl(l_Exception, l_Message, l_Control) then
 begin
  (l_Control as IevEditorCalendarField).ClearField;
  raise l_Exception.Create(l_Control, l_Message);
 end;
 if Supports(EditorReq.FirstField, IevEditorCalendarField, l_DateField) then
 begin
 // Удалим если введена не верная дата
  if not l_DateField.IsFieldEmpty and not l_DateField.GetOtherField.IsFieldEmpty then
   if Floor(l_DateField.aDate) > Floor(l_DateField.GetOtherField.aDate) then
    raise EqaInvalidValue.CreateFmt(l_DateField, vcmConstString(str_StartDateMoreEnd),
                                    [DateToStr(l_DateField.aDate), DateToStr(l_DateField.GetOtherField.aDate)]);
 end;
end;

function TqaReqDate.CheckFromControl(out aExceptionClass : EaqExceptionClass;
                                     out aMessage        : String;
                                     out aControl        : IevEditorControlField): Boolean;

 procedure CheckDate(const aDateField: IevEditorCalendarField);
 {* - проверяет правильность даты и выводит сообщение. }
 begin
  if not aDateField.IsBlank and not aDateField.Valid then
  begin
   Result := False;
   aExceptionClass := EqaInvalidValue;
   aMessage := Format(vcmConstString(str_InvalidDate), [nsEStr(aDateField.text)]);
   aControl := aDateField;
  end;
 end;

var
 l_DateField: IevEditorCalendarField;
begin
 Result := inherited CheckFromControl(aExceptionClass, aMessage, aControl);
 if Result and Supports(EditorReq.FirstField, IevEditorCalendarField, l_DateField) then
 begin
  CheckDate(l_DateField);
  if Result then
   CheckDate(l_DateField.GetOtherField);
 end;
end;

procedure TqaReqDate.EnterPressed;
begin
 HyperLinkClick;
end;

function TqaReqDate.GetHint4Button(
  const aValue: IevEditorControlButton): Il3CString;
begin
 Result := inherited GetHint4Button(aValue);
 if (aValue.GetButtonType = ev_btDelete) then
  Result := vcmCStr(str_HintBtnDeleteDate);
end;

function TqaReqDate.Get_EndDate: System.TDateTime;
var
 l_CalReq: IevDatesReq;
begin 
 if Supports(f_EditorReq, IevDatesReq, l_CalReq) then
  try
   Result := l_CalReq.EndDate;
  finally
   l_CalReq := nil;
  end
 else 
  Result := NullDate; 
end;

function TqaReqDate.Get_Multy: Boolean;
begin
 Result := True;
end;

function TqaReqDate.Get_StartDate: System.TDateTime;
var
 l_CalReq: IevDatesReq;
begin 
 if Supports(f_EditorReq, IevDatesReq, l_CalReq) then
  try
   Result := l_CalReq.StartDate;
  finally
   l_CalReq := nil;
  end
 else 
  Result := NullDate; 
end;

procedure TqaReqDate.HyperLinkClick;
begin
 f_MgrSearch.DateQuery(Self);
end;

procedure TqaReqDate.InitFields;
var
 l_Field : IevEditorControlField;
 l_CT    : Tl3PCharLen;
 l_Cal: IevEditorCalendarField;

 procedure lp_Init(const aField: IevEditorControlField);
 begin
  if (aField <> nil) then
  begin
   if l3IsNil(aField.Para.PCharLenA[k2_tiText]) then
    aField.Para.PCharLenA[k2_tiText] := l_CT
   else
   if not l3IsNil(l_CT) then
    aField.Para.PCharLenA[k2_tiText] := l_CT;
  end;//l_Field <> nil
 end;

begin
 inherited;
 if not f_EditorReq.Para.HasSubAtom(k2_tiDefaultText) then
 //Обновление масок текста (могут не соотвествовать региональным настройкам).
 begin
  l_CT := Tl3PCharLen(nsWStr(evMakeDateMaskText));
  l_Field := f_EditorReq.FirstField;
  if (l_Field <> nil) then
  begin
   lp_Init(l_Field);
   if Supports(l_Field, IevEditorCalendarField, l_Cal) then
    lp_Init(l_Cal.GetOtherField);
  end;//l_Field <> nil
  f_EditorReq.Para.PCharLenA[k2_tiDefaultText] := l_CT;
 end;//not f_EditorReq.Para.HasSubAtom(k2_tiDefaultText)
end;

procedure TqaReqDate.Load;
var
 l_StartDate : System.TDateTime;
 l_EndDate   : System.TDateTime;
begin
 {$If not defined(Admin)}
 LoadDateNew(f_MgrSearch.Query, Get_TagName, l_StartDate, l_EndDate);
 {$Else}
 Assert(false);
 {$IfEnd}
 if (l_StartDate <> NullDate) or (l_EndDate <> NullDate) then
 begin
  f_EditorReq.Group.Expanded := True;
  EndDate := l_EndDate;
  StartDate := l_StartDate;
 end;
 inherited;
end;

procedure TqaReqDate.OpenSelectWindow;
begin
 HyperLinkClick;
end;

procedure TqaReqDate.ReqClear;
begin
 f_EditorReq.FirstField.ClearText;
end;

procedure TqaReqDate.SaveReq;
begin
 {$If not defined(Admin)}
 Assert(f_EditorReq.FirstField.Enabled = f_EditorReq.LastField.Enabled);
 if f_EditorReq.FirstField.Enabled AND f_EditorReq.LastField.Enabled then
  SaveDateNewEx(f_MgrSearch.Query, Get_TagName, StartDate, EndDate);
 {$Else}
 Assert(false);
 {$IfEnd}
end;

procedure TqaReqDate.Set_EndDate(const Value: System.TDateTime);
var
 l_CalReq: IevDatesReq;
begin 
 if Supports(f_EditorReq, IevDatesReq, l_CalReq) then
  try
   l_CalReq.EndDate := Value;
  finally
   l_CalReq := nil;
  end;
end;

procedure TqaReqDate.Set_StartDate(const Value: System.TDateTime);
var
 l_CalReq: IevDatesReq;
begin
 if Supports(f_EditorReq, IevDatesReq, l_CalReq) then
  try
   l_CalReq.StartDate := Value;
  finally
   l_CalReq := nil;
  end;
end;

{ TqaEventReq }

procedure TqaEventReq.AfterSetText(const aField: IevEditorControlField);
begin

end;

function TqaEventReq.AnalysString(const aValue : Il3CString;
                                  out aRslt    : Il3CString): Boolean;
  {-}                                
begin
 Result := false;
end;

function TqaEventReq.CheckValue(const aField: IevEditorControlField): Boolean;
begin
 Result := IsAttrValid;
end;

procedure TqaEventReq.EnterPressed;
begin

end;

function TqaEventReq.GetHint(const aValue: IevEditorControl): Il3CString;
var
 l_Button  : IevEditorControlButton;
begin
 if Supports(aValue, IevEditorControlButton, l_Button) then
  try
   Result := GetHint4Button(l_Button);
  finally
   l_Button := nil;
  end
 else
  Result := nil;
end;

function TqaEventReq.pm_GetAdditionalFilter: TnsFilterType;
begin
 Result := GetAdditionalFilter(TagName, f_MgrSearch.QueryType);
end;

function TqaEventReq.GetHint4Button(const aValue: IevEditorControlButton): Il3CString;
var
 l_PictBTN : IevEditorStateButton;
begin
 case aValue.GetButtonType of
  ev_btLogical:
  begin
   if (l3BitCountF(EditorReq.Para.IntA[k2_tiOperations]) = 1)  then
    Result := vcmCStr(str_HintNotChangedOperation)
   else
    if Supports(aValue, IevEditorStateButton, l_PictBTN) then
     try
      case StateIndex2LogicState(l_PictBTN.GetStateIndex) of
        loOr  :
         Result := vcmCStr(str_HintOrOperation);
        loAnd :
         Result := vcmCStr(str_HintAndOperation);
        loNot :
         Result := vcmCStr(str_HintNotOperation);
       else
        Result := vcmCStr(str_HintChangeOperation);
      end;//case StateIndex2LogicState(l_PictBTN.GetStateIndex)
     finally
      l_PictBTN := nil;
     end;//try..finally
  end;//l3BitCountF(EditorReq.Para.IntA[k2_tiOperations]) = 1
  ev_btAdd    :
   Result := vcmCStr(str_HintBtnCreateAttr);
  ev_btDelete :
   Result := vcmCStr(str_HintBtnDeleteAttr);
 end;//case aValue.GetButtonType
end;

function TqaEventReq.GetImage(Index: Integer;
  var aImages: InevImageList): Integer;
{$IfNDef Admin}
var
 l_Node: Il3SimpleNode;
 l_ComboReq: IevComboReq;
{$EndIf Admin}
begin
 Result := -1;
 {$IfNDef Admin}
 aImages := Tl3ImageList.Make(nsSearchRes.SearchItemsImageList);
 if Supports(f_EditorReq, IevComboReq, l_ComboReq) then
 try
  l_Node := l_ComboReq.GetNode(Index);
  if l_Node <> nil then
  begin
   try
    // Папка
    if l_Node.HasChild then
     Result := siilFolderStart
    // Элемент
    else
     Result := siilSelectedElement;
   finally
    l_Node := nil;
   end;//try..finally
  end;//l_Node <> nil
 finally
  l_ComboReq := nil;
 end;//try..finally
 {$EndIf  Admin}
end;

procedure TqaEventReq.HyperLinkClick;
begin
 OpenSelectWindow;
end;

function TqaEventReq.StateIndex2LogicState(aValue: Integer): TLogicOperation;
  {-}
begin
 if aValue < 0 then
  Result := loNone
 else
  Result := TLogicOperation(aValue + 1)
end;

procedure TqaEventReq.TextChange;
  {-}
begin
 Modified := True;
end;

{ TqaReqNum }

procedure TqaReqNum.InitFields;
var
 l_Combo: IevEditorFieldWithTree;
begin
 inherited;
 if Supports(f_EditorReq.FirstField, IevEditorFieldWithTree, l_Combo) then
 try
  // Установим символ звездочки
  l_Combo.Asterisk := '*';
 finally
  l_Combo := nil;
 end;//try..finally
end;

{ TqaHistory }

procedure TqaHistory.Cleanup;
begin
 f_Filter := nil;
 f_Query := nil;
 f_DataReset := False;
 f_ConsultationSened := False;
 inherited;
end;

procedure TqaHistory.FinishDataUpdate;
begin
 inherited FinishDataUpdate;
 f_DataReset := True;
end;

function TqaHistory.GetConsultationSended: Boolean;
begin
 Result := f_ConsultationSened;
end;

function TqaHistory.GetDataReset: Boolean;
begin
 Result := f_DataReset;
end;

function TqaHistory.GetFilter: INode;
begin
 Result := f_Filter;
end;

function TqaHistory.GetQuery: IQuery;
begin
 Result := f_Query;
end;

procedure TqaHistory.pm_SetQuery(const aValue: IQuery);
begin
 if f_Query <> nil then
  f_Query := nil;
 f_Query := aValue;
end;

procedure TqaHistory.SetConsultationSended(const aValue: Boolean);
begin
 f_ConsultationSened := aValue;
end;

procedure TqaHistory.SetFilter(const aNode: INode);
begin
 f_Filter := aNode;
end;

{ TqaReqComboField }

procedure TqaReqComboField.CheckAttr;
var
 l_FirstDuplicate : IevEditorControlField;
 l_Exception      : EaqExceptionClass;
 l_Message        : string;
begin
 inherited;
 if not CheckFromControl(l_Exception, l_Message, l_FirstDuplicate) then
  raise l_Exception.Create(l_FirstDuplicate, l_Message);
end;

function TqaReqComboField.CheckFromControl(out aExceptionClass : EaqExceptionClass;
                                           out aMessage        : String;
                                           out aControl        : IevEditorControlField): Boolean;
var
 l_Index : Integer;
 l_SList : IvcmStrings;
 l_CheckEditor: IevEditorControlField;
 l_CheckValue: Il3CString;
begin
 Result := inherited CheckFromControl(aExceptionClass, aMessage, aControl);
 if Result then
 begin
  // Проверим уникальность значений
  l_SList := TvcmStringList.Make;
  try
   for l_Index := 0 to f_EditorReq.FieldsCount - 1 do
   begin
    l_CheckEditor := f_EditorReq.Fields[l_Index];
    l_CheckValue := l_CheckEditor.Text;
    l_CheckEditor.ErrorColor := not l3IsNil(l_CheckValue) and (l_SList.IndexOf(l_CheckValue) <> -1);
    if l_CheckEditor.ErrorColor then
    begin
     if aControl = nil then
      aControl := l_CheckEditor;
    end
    else
     l_SList.Add(l_CheckValue);
   end;//for l_Index := 0
  finally
   l_SList := nil;
  end;//try..finally
  if Assigned(aControl) then
  begin
   Result := False;
   aExceptionClass := EqaDuplicateValue;
   aMessage := Format(vcmConstString(str_DuplicateValue), [nsEStr(aControl.Text)]);
  end;//Assigned(aControl)
 end;//Result
end;

procedure TqaReqComboField.ReqClear;
var
 l_ComboReq  : IevComboReq;
 l_Req       : IevReq;
 l_TreeField : IevEditorFieldWithTree;
begin
 l_Req := f_EditorReq; 
 try 
  while l_Req.FieldsCount > 1 do
   l_Req.DeleteField(nil, nil, true);
                            // ^ http://mdp.garant.ru/pages/viewpage.action?pageId=96483355&focusedCommentId=109511365#comment-109511365
  if Supports(l_Req.LastField, IevEditorFieldWithTree, l_TreeField) then
   try 
    if evIsFieldSet(l_TreeField, True) then
    begin
     l_TreeField.ClearText;
     //l_Req.SetFocus(l_TreeField);     
    end;//evIsFieldSet(l_TreeField, True)
   finally
    l_TreeField := nil;
   end;
  if Supports(l_Req, IevComboReq, l_ComboReq) then
   try
    l_ComboReq.ClearLogicValue;         
   finally
    l_ComboReq := nil;
   end; 
 finally
  l_Req := nil;
 end; 
end;

// start class TqaCommonStrReq

procedure TqaCommonStrReq.TextChange;
begin
 Modified := True;
end;

procedure TqaCommonStrReq.ReqClear;
begin
 EditorReq.FirstField.ClearText;
end;

procedure TqaCommonStrReq.SaveReq;
var
 l_Value : Il3CString;
begin
 l_Value := nsContextUtils.CheckContext(f_EditorReq.FirstField.Text);
 {$If not defined(Admin)}
 SaveContextNew(f_MgrSearch.Query, Get_TagName, l_Value);
 {$ELse}
 Assert(false);
 {$IfEnd}
end;

procedure TqaCommonStrReq.Load;
var
 l_Context : Il3CString;
begin 
 if LoadContextNew(f_MgrSearch.Query, Get_TagName, l_Context) then
  f_EditorReq.FirstField.Text := l_Context;
end;

{ TqaDateReqDataHolder }

constructor TqaDateReqDataHolder.Create(const aReq: IqaDateReq);
var
 l_Req: IqaReq;
begin
 inherited Create;
 StartDate := aReq.StartDate;
 EndDate := aReq.EndDate;
 IsOk := False;
 if Supports(aReq, IqaReq, l_Req) then
  f_ReqCaption := l_Req.TagCaption;
end;

procedure TqaDateReqDataHolder.Cleanup;
  //override;
  {-}
begin
 f_ReqCaption := nil;
 inherited;
end;

function TqaDateReqDataHolder.Get_EndDate: System.TDateTime;
begin
 Result := f_EndDate;
end;

function TqaDateReqDataHolder.Get_IsOk: Boolean;
begin
 Result := f_IsOk;
end;

function TqaDateReqDataHolder.Get_ReqCaption: Il3CString;
begin
 Result := f_ReqCaption;
end;

function TqaDateReqDataHolder.Get_StartDate: System.TDateTime;
begin
 Result := f_StartDate;
end;

function TqaDateReqDataHolder.IsStartDateEmpty: Boolean;
begin
 Result := StartDate = NullDate;
end;

function TqaDateReqDataHolder.IsEndDateEmpty: Boolean;
begin
 Result := EndDate = NullDate;
end;

class function TqaDateReqDataHolder.Make(const aReq: IqaDateReq): IqaDateReqDataHolder;
var
 l_Inst: TqaDateReqDataHolder;
begin
 if Assigned(aReq) then
 begin
  l_Inst := Create(aReq);
  try
   Result := l_Inst;
  finally
   vcmFree(l_Inst)
  end;
 end
 else
  Result := nil;
end;

procedure TqaDateReqDataHolder.Set_EndDate(const Value: System.TDateTime);
begin
 F_EndDate := Value;
end;

procedure TqaDateReqDataHolder.Set_IsOk(const Value: Boolean);
begin
 f_IsOk := Value;
end;

procedure TqaDateReqDataHolder.Set_StartDate(const Value: System.TDateTime);
begin
 f_StartDate := Value;
end;

{ TqaReqPhone }

function TqaReqPhone.CanOpenTree: Boolean;
begin
 Result := False;
end;

function TqaReqPhone.Get_Code: Il3CString;
var
 l_PhoneReq: IevPhoneReq;
begin
 if Supports(f_EditorReq, IevPhoneReq, l_PhoneReq) then
  try
   Result := l_PhoneReq.Code;
  finally
   l_PhoneReq := nil;
  end//try..finally
 else
  Result := nil;
end;

function TqaReqPhone.Get_Multy: Boolean;
begin
 Result := True;
end;

function TqaReqPhone.Get_Number: Il3CString;
var
 l_PhoneReq: IevPhoneReq;
begin
 if Supports(f_EditorReq, IevPhoneReq, l_PhoneReq) then
  try
   Result := l_PhoneReq.Number;
  finally
   l_PhoneReq := nil;
  end//try..finally
 else
  Result := nil;
end;

procedure TqaReqPhone.Load;
var
 l_Code   : Il3CString;
 l_Number : Il3CString;
begin
 LoadPhone(f_MgrSearch.Query, nsWStr(Get_TagName), l_Code, l_Number);
 Code := l_Code;
 Number := l_Number;
 if not l3IsNil(l_Code) or not l3IsNil(l_Number) then
  f_EditorReq.Group.Expanded := True;
 inherited;
end;

procedure TqaReqPhone.ReqClear;
begin
 Code := nil;
 Number := nil;
end;

procedure TqaReqPhone.SaveReq;
begin
 {$If not defined(Admin)}
 SavePhone(f_MgrSearch.Query, Get_TagName, Code, Number);
 {$Else}
 Assert(false);
 {$IfEnd}
end;

procedure TqaReqPhone.Set_Code(const Value: Il3CString);
var
 l_PhoneReq: IevPhoneReq;
begin
 if Supports(f_EditorReq, IevPhoneReq, l_PhoneReq) then
  try
   l_PhoneReq.Code := Value;
  finally
   l_PhoneReq := nil;
  end;//try..finally
end;

procedure TqaReqPhone.Set_Number(const Value: Il3CString);
var
 l_PhoneReq: IevPhoneReq;
begin
 if Supports(f_EditorReq, IevPhoneReq, l_PhoneReq) then
  try
   l_PhoneReq.Number := Value;
  finally
   l_PhoneReq := nil;
  end;//try..finally
end;

{ TqaReqEMail }

procedure TqaReqEMail.CheckAttr;
var
 l_Exception : EaqExceptionClass;
 l_Message   : String;
 l_Control   : IevEditorControlField;
begin
 inherited;
 if not CheckFromControl(l_Exception, l_Message, l_Control) then
  raise l_Exception.Create(l_COntrol, l_Message);
end;

function TqaReqEMail.CheckFromControl(out aExceptionClass : EaqExceptionClass;
                                      out aMessage        : String;
                                      out aControl        : IevEditorControlField): Boolean;
var
 l_Emails: Tl3CStringArray;
 l_Correct: Boolean;
 I: Integer;
begin
 Result := inherited CheckFromControl(aExceptionClass, aMessage, aControl);
 l_Correct := False;
 l_Emails := l3Split(f_EditorReq.FirstField.Text, ',');
 for I := 0 to Length(l_Emails) - 1 do
 begin
  l_Correct := nsEmailVerify.Verify(l3Trim(l_Emails[I]));
  if not l_Correct then
   Break;
 end;
 if Result and IsSet(False) and not l_Correct then
 begin
  Result := False;
  aExceptionClass := EqaInvalidValue;
  aMessage := vcmConstString(str_WrongEMail);
  aControl := f_EditorReq.FirstField;
 end;
end;

{$If not Defined(Admin) AND not Defined(Monitorings)}
procedure TqaMgrSearch.Correct(const aCorrectedContext: Il3StringsEx;
  const aMistakesList: Il3StringsEx);

var
 l_ContextsIdx: Integer;

 function DoCorrectContext(const aReq: IqaReq): Boolean;

  function lp_HasErrorWords(const aContext: Il3CString): Boolean;
  var
   l_IDX: Integer;
  begin//lp_HasErrorWords
   Result := False;
   if Assigned(aMistakesList) then
    for l_IDX := 0 to aMistakesList.Count - 1 do
     if l3Pos(l3Upper(aContext), l3Upper(aMistakesList.ItemC[l_IDX])) > l3NotFound then
     begin
      Result := True;
      Exit;
     end;//l3Pos..
  end;//lp_HasErrorWords

 var
  l_Idx: Integer;
  l_Text  : Il3CString;
  l_Index : Integer;
  l_Para  : InevPara;
  l_DummyText : Il3CString;
 const
  l_Opt = [ev_soGlobal, ev_soUseInternalCursor, ev_soReplaceAll, ev_soNoProgress];
 begin//DoCorrectContext
  Result := true;
  if Supports(aReq, IqaMorphoReq) then
  begin
   for l_IDX := 0 to aReq.EditorReq.FieldsCount - 1 do
    if not aReq.EditorReq.Fields[l_IDX].IsFieldEmpty then
    begin
     if (l_ContextsIdx < aCorrectedContext.Count) then // http://mdp.garant.ru/pages/viewpage.action?pageId=326773154
     begin
      if not l3Same(aReq.EditorReq.Fields[l_IDX].Text, aCorrectedContext[l_ContextsIdx]) then
       aReq.EditorReq.Fields[l_IDX].Text := aCorrectedContext[l_ContextsIdx];
     end
     else
      aReq.EditorReq.Fields[l_IDX].Text := l3CStr(''); // http://mdp.garant.ru/pages/viewpage.action?pageId=326773154
     if (f_FirstErrorContextReq = nil) then
     begin
      if lp_HasErrorWords(aReq.EditorReq.Fields[l_IDX].Text) then
       f_FirstErrorContextReq := aReq.EditorReq.Fields[l_IDX];
     end;//f_FirstErrorContextReq = nil
     l_Para := aReq.EditorReq.Fields[l_IDX].Para;
     with l_Para.Attr[k2_tiSegments] do
      if IsValid then
      begin
       if rAtomEx([k2_tiChildren, k2_tiHandle, ev_slMistakes], @l_Index).IsValid then
        DeleteChild(l_Index);
      end;//IsValid
     if Assigned(aMistakesList) then
     begin
      for l_Index := 0 to Pred(aMistakesList.Count) do
      begin
       evReplaceInPara(l_Para,
                       TevStrictWordSearcher.Make(l3Str(aMistakesList[l_Index]), l_Opt),
                       TevStyleReplacer.MakeForStyleID(ev_saMistake, l_Opt));
      end;//for l_Index
     end;//l_Words <> nil
     Inc(l_ContextsIdx);
     if (l_ContextsIdx >= aCorrectedContext.Count) then
      Result := false;
    end;//not aReq.EditorReq.Fields[l_IDX].IsFieldEmpty
  end;//Supports(aReq, IqaMorphoReq)
 end;//DoCorrectContext

begin
 l_ContextsIdx := 0;
 IterateAttrsF(l3L2FA(@DoCorrectContext));
end;
{$IfEnd}

{$If not (defined(Monitorings) or defined(Admin))}
procedure TqaMgrSearch.CheckMorpho;
  {-}
var
 l_TotalContext: Il3StringsEx;

 function DoCollectContext(const aReq: IqaReq): Boolean;
 var
  l_Req: IqaMorphoReq;
  l_Context: Il3CString;
 begin
  Result := true;
  if Supports(aReq, IqaMorphoReq, l_Req) then
   l_Req.FillReqListAsString(l_TotalContext);
 end;

begin
 l_TotalContext := TvcmStringList.Make;
 IterateAttrsF(l3L2FA(@DoCollectContext));
 f_FirstErrorContextReq := nil;
 try
  {$If not (defined(Monitorings) or defined(Admin))}
  if bsUtils.bsCorrectMistakes(l_TotalContext, QueryType in c_InpharmSearches, Self) and Assigned(f_FirstErrorContextReq) then
   raise EqaSilentAbort.Create(f_FirstErrorContextReq,'');
  {$Else}
  Assert(false);
  {$IfEnd}
 finally
  f_FirstErrorContextReq := nil;
 end;
end;
{$IfEnd}

procedure TqaMgrSearch.ClearContextMistakes;

 function DoClearMistakes(const aReq: IqaReq): Boolean;
 var
  l_Idx: Integer;
  l_Index : Integer;
  l_Para  : InevPara;
 begin
  Result := true;
  if Supports(aReq, IqaMorphoReq) then
  begin
   for l_IDX := 0 to aReq.EditorReq.FieldsCount - 1 do
   begin
    l_Para := aReq.EditorReq.Fields[l_IDX].Para;
    with l_Para.Attr[k2_tiSegments] do
     if IsValid then
     begin
      if rAtomEx([k2_tiChildren, k2_tiHandle, ev_slMistakes], @l_Index).IsValid then
      begin
       DeleteChild(l_Index);
       evSegments_ClearSuper(l_Para, nil);
       // - по-хорошему это надо в ChildDeleted, но туда пока достучаться не можем
      end;//rAtomEx([k2_tiChildren, k2_tiHandle, ev_slMistakes], @l_Index).IsValid
     end;//IsValid
   end;  
  end;
 end;

begin
 IterateAttrsF(l3L2FA(@DoClearMistakes));
end;

{ TqaReqContext }

procedure TqaReqContext.CheckAttr;

 procedure CheckContext(const aComboBox : IevEditorControlField);
 var
  l_Pos        : Integer;
  l_ErrMessage : Il3CString;
 begin//CheckContext
  aComboBox.Text := nsContextUtils.CheckContext(aComboBox.Text);
  if not l3IsNil(aComboBox.Text) then
  begin
   {$If not defined(Admin)}
   l_Pos := CheckContext6x(aComboBox.Text, l_ErrMessage);
   {$Else}
   Assert(false);
   {$IfEnd}
   if (l_Pos >= 0) then
    raise EqaInvalidValue.Create(aComboBox, nsEStr(l_ErrMessage));
  end;//not l3IsNil(aComboBox.Text)
 end;//CheckContext

var
 l_Index : Integer;
 l_Req   : IevComboReq;
begin
 inherited;
 if Supports(f_EditorReq, IevComboReq, l_Req) and l_Req.IsContext then
 begin
  (* Проверим значения в полях контекста. *)
  for l_Index := 0 to f_EditorReq.FieldsCount - 1 do
   CheckContext(f_EditorReq.Fields[l_Index]);
 end;//Supports(f_EditorReq, IevComboReq, l_Req) and l_Req.IsContext
end;

function TqaMgrSearch.GetPromptTreeFromAdapter: Il3SimpleTree;
begin
{ if QueryType in c_InpharmSearches then
  Result := nil
 else
  Result := BaseSearchPromptTree;}
 Result := nil; // К-104432064
end;

procedure TqaMgrSearch.NotifyContextWrong;
begin
 nsBeepWrongContext;
end;

end.
