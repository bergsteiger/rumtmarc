unit k2Base;
{* Базовые классы библиотеки K-2. }

{ Библиотека "K-2"        }
{ Автор: Люлин А.В. ©     }
{ Модуль: k2Base - }
{ Начат: 12.04.1998 11:28 }
{ $Id: k2Base.pas,v 1.771 2013/04/09 11:08:14 lulin Exp $ }

// $Log: k2Base.pas,v $
// Revision 1.771  2013/04/09 11:08:14  lulin
// - пытаемся отладиться под XE.
//
// Revision 1.770  2013/04/04 11:21:37  lulin
// - портируем.
//
// Revision 1.769  2012/11/01 09:42:54  lulin
// - забыл точку с запятой.
//
// Revision 1.768  2012/11/01 07:45:04  lulin
// - делаем возможность логирования процесса загрузки модулей.
//
// Revision 1.767  2012/10/26 17:36:46  lulin
// - вычищаем поддержку ветки редактора.
//
// Revision 1.766  2012/07/24 18:01:08  lulin
// {RequestLink:378540022}.
//
// Revision 1.765  2012/07/12 18:33:21  lulin
// {RequestLink:237994598}
//
// Revision 1.764  2012/01/30 14:06:03  lulin
// {RequestLink:332563400}
//
// Revision 1.763  2011/12/20 11:07:26  lulin
// - меняем тип параметра.
//
// Revision 1.762  2011/09/28 17:13:04  lulin
// {RequestLink:284165571}.
//
// Revision 1.761  2011/08/04 09:45:11  dinishev
// [$235058873]. Округление для маркеров.
//
// Revision 1.760  2011/07/26 13:22:36  lulin
// {RequestLink:275780190}.
//
// Revision 1.759  2011/07/07 19:54:50  lulin
// {RequestLink:228688745}.
//
// Revision 1.758  2011/05/23 15:33:31  lulin
// {RequestLink:266423791}.
//
// Revision 1.757  2011/05/18 17:45:49  lulin
// {RequestLink:266409354}.
//
// Revision 1.756  2011/05/17 14:55:12  lulin
// {RequestLink:266409354}.
//
// Revision 1.755  2010/11/25 14:16:28  lulin
// {RequestLink:238945411}.
// - по-другому обрабатываем флаги модифицированности.
//
// Revision 1.754  2010/11/24 20:16:32  lulin
// {RequestLink:238945411}.
//
// Revision 1.753  2010/11/03 16:20:04  lulin
// {RequestLink:238947629}.
// - правим ошибку клонирования свойства тега, которая приводила к кривизне схемы и зависанию.
//
// Revision 1.752.2.1  2010/11/03 15:52:04  lulin
// {RequestLink:238947629}.
// - определяем, что элемент олавления может иметь идентификатор.
// - правим ошибку клонирования свойства тега, которая приводила к кривизне схемы и зависанию.
//
// Revision 1.752  2010/06/17 12:45:19  lulin
// Отвалился тест [SHD:TextLoad] [SHD:LoadBigTableFromTextEVD] т.к. он содержит блоки в таблице. Из-за - {RequestLink:215548927}.
//
// Revision 1.751  2010/06/16 15:35:46  lulin
// {RequestLink:215548927}.
//
// Revision 1.750  2010/06/15 14:09:36  lulin
// {RequestLink:215548927}.
// - настраиваем инфраструктуру.
//
// Revision 1.749  2010/04/19 12:22:51  lulin
// {RequestLink:140286381}.
// - используем итератор.
//
// Revision 1.748  2010/04/14 10:31:20  lulin
// {RequestLink:203129522}.
//
// Revision 1.747  2010/04/12 14:53:52  lulin
// {RequestLink:203129570}.
// - убираем ненужный тип подитеративной функции.
//
// Revision 1.746  2010/04/12 14:16:31  lulin
// {RequestLink:203129570}.
//
// Revision 1.745  2010/04/09 16:02:39  lulin
// {RequestLink:201493388}.
//
// Revision 1.744  2010/03/30 17:50:29  lulin
// {RequestLink:198672902}.
// - учимся обрабатывать вложенные вызовы итераторов.
//
// Revision 1.743  2010/02/24 18:37:30  lulin
// - перепутал условие.
//
// Revision 1.742  2010/02/24 18:15:45  lulin
// - избавляемся от ненужного и вредного параметра, доставшегося в наследство от ошибок молодости.
//
// Revision 1.741  2009/12/22 11:58:34  lulin
// {RequestLink:174719000}.
//
// Revision 1.740  2009/12/15 10:56:32  lulin
// - не дёргаем дурацкий динамический метод.
//
// Revision 1.739  2009/07/28 10:24:49  voba
// - bug fix от Шуры
//
// Revision 1.738  2009/07/27 07:15:03  lulin
// Недоделки по {RequestLink:141264340}. №44.
//
// Revision 1.737  2009/07/24 13:06:39  lulin
// - bug fix: не собиралось тестовое приложение в ветке.
//
// Revision 1.736  2009/07/23 19:31:17  lulin
// - bug fix: не работал Немезис.
//
// Revision 1.735  2009/07/23 18:22:02  lulin
// - вычищаем ненужный враппер тега.
//
// Revision 1.734  2009/07/23 17:28:54  lulin
// - убираем ненужный запрос интерфейса.
// - правим наследование у SomeDataContainer.
//
// Revision 1.733  2009/07/23 13:42:34  lulin
// - переносим процессор операций туда куда надо.
//
// Revision 1.732  2009/07/22 18:04:56  lulin
// - не пишем статистику по тегам.
//
// Revision 1.731  2009/07/22 17:46:40  lulin
// - bug fix: не работало тестовое приложение в ветке.
//
// Revision 1.730  2009/07/22 17:16:40  lulin
// - оптимизируем использование счётчика ссылок и преобразование к интерфейсам при установке атрибутов тегов.
//
// Revision 1.729  2009/07/22 14:05:27  lulin
// - bug fix: не собиралось и не работало тестовое приложение в ветке.
//
// Revision 1.728  2009/07/22 12:29:56  lulin
// - пытаемся оптимизировать установку атомарных тегов.
//
// Revision 1.727  2009/07/21 18:23:16  lulin
// - подготавливаемся к уменьшению преобразования типов при записи атрибутов.
//
// Revision 1.726  2009/07/21 16:38:39  lulin
// - убираем ненужное создание нулевого объекта.
//
// Revision 1.725  2009/07/21 16:23:37  lulin
// - убран ненужный параметр.
//
// Revision 1.724  2009/07/21 16:00:05  lulin
// - учитываем, что строка теперь имеет другой корень наследования.
//
// Revision 1.723  2009/07/21 15:10:16  lulin
// - bug fix: не собирался и не работал Архивариус в ветке.
//
// Revision 1.722  2009/07/21 14:36:10  lulin
// - убираем поддержку IUnknown со строк.
//
// Revision 1.721  2009/07/21 13:10:09  lulin
// - вставляем Assert на непонятную функциональность.
//
// Revision 1.720  2009/07/20 14:13:44  lulin
// - разрешаем конфликт имён.
//
// Revision 1.719  2009/07/20 12:49:39  lulin
// - подготавливаемся к переносу изменений в ветку.
//
// Revision 1.718  2009/07/17 13:47:23  lulin
// - bug fix: неправильно обрабатывали удаление дочерних тегов.
//
// Revision 1.717  2009/07/17 12:42:02  lulin
// {RequestLink:141264340}. №7, 32, 33.
//
// Revision 1.716  2009/07/16 10:43:38  lulin
// - в тесте выводим статистику по тегам.
//
// Revision 1.715  2009/07/15 15:12:25  lulin
// - удалено ненужное свойство списков параграфов.
//
// Revision 1.714  2009/07/15 10:20:44  lulin
// - bug fix: неправильно писались атрибуты в виде "стилей".
//
// Revision 1.713  2009/07/10 15:04:49  lulin
// - избавляемся от лишнего дёрганья счётчиков ссылок.
//
// Revision 1.712  2009/07/09 14:54:29  lulin
// {RequestLink:140837386}. №3.
//
// Revision 1.711  2009/07/08 12:27:11  lulin
// - bug fix: не собирался Эверест в ветке.
//
// Revision 1.710  2009/07/07 14:18:01  lulin
// - реализуем определение имени описателей в базовых объектах.
//
// Revision 1.709  2009/07/07 12:58:15  lulin
// - избавляемся от ненужной виртуальности.
//
// Revision 1.708  2009/07/07 11:46:20  lulin
// - избавляемся от ненужной виртуальности.
//
// Revision 1.707  2009/07/07 10:48:27  lulin
// - вычищаем ненужный интерфейс.
//
// Revision 1.706  2009/07/07 09:54:04  lulin
// - bug fix: не собирался Эверест в ветке.
//
// Revision 1.705  2009/07/07 09:23:57  lulin
// - вычищаем ненужный интерфейс.
//
// Revision 1.704  2009/07/07 08:58:27  lulin
// - вычищаем ненужное.
//
// Revision 1.703  2009/07/06 16:57:40  lulin
// - вычищаем ненужное.
//
// Revision 1.702  2009/07/06 16:28:47  lulin
// - вычищаем ненужное.
//
// Revision 1.701  2009/07/06 15:46:29  lulin
// - возвращаемся от интерфейсов к объектам.
//
// Revision 1.700  2009/07/06 13:32:12  lulin
// - возвращаемся от интерфейсов к объектам.
//
// Revision 1.699  2009/07/06 11:13:24  lulin
// - переносим примеси в более базовый пакет.
//
// Revision 1.698  2009/07/03 17:05:31  lulin
// - шаг к переходу от интерфейсов к объектам.
//
// Revision 1.697  2009/07/03 16:24:13  lulin
// - шаг к переходу от интерфейсов к объектам.
//
// Revision 1.696  2009/07/01 15:26:10  lulin
// - убрана ненужная функциональность.
//
// Revision 1.695  2009/06/29 14:35:18  lulin
// - убираем рассылку лишних нотификаций.
//
// Revision 1.694  2009/06/29 05:59:11  lulin
// - не рассылаем никому ненужную нотификацию.
//
// Revision 1.693  2009/06/24 15:53:23  lulin
// {RequestLink:140286381}.
//
// Revision 1.692  2009/04/14 18:12:01  lulin
// [$143396720]. Подготовительная работа.
//
// Revision 1.691  2009/04/07 16:09:48  lulin
// [$140837386]. №13.
//
// Revision 1.690  2009/04/07 15:11:49  lulin
// [$140837386]. №13. Чистка кода.
//
// Revision 1.689  2009/03/25 16:11:19  voba
// - не компилялось
//
// Revision 1.688  2009/03/24 18:42:58  lulin
// - убраны ненужные свойства.
//
// Revision 1.687  2009/03/24 17:45:48  lulin
// [$137465982]. Избавляемся от ненужных промежуточных классов №2.
//
// Revision 1.686  2009/03/24 17:15:07  lulin
// [$137465982]. Избавляемся от ненужных промежуточных классов.
//
// Revision 1.685  2009/03/24 17:01:23  lulin
// [$137465982]. №5.
//
// Revision 1.684  2009/03/16 11:28:10  oman
// - fix: Не падаем на аварийном завершении (К-139436640)
//
// Revision 1.683  2009/03/11 12:08:36  lulin
// - <K>: 139429761. Гарантируем, что дети идут после всех тегов.
//
// Revision 1.682  2009/03/05 18:42:13  lulin
// - <K>: 137470629. Собираем Эверест в ветке.
//
// Revision 1.681  2009/03/05 17:23:58  lulin
// - <K>: 137470629. Для ветки тоже генерируем ссылки на теги.
//
// Revision 1.680  2009/03/05 17:04:37  lulin
// - <K>: 137470629. Чистка кода.
//
// Revision 1.679  2009/03/05 16:46:34  lulin
// - <K>: 137470629. Убран ненужный интерфейс.
//
// Revision 1.678  2009/03/05 16:20:42  lulin
// - <K>: 137470629. Убрана ненужная ссылка на тип по идентификатору.
//
// Revision 1.677  2009/03/05 15:43:23  lulin
// - <K>: 137470629. Убран ненужный метод.
//
// Revision 1.676  2009/03/05 09:45:01  lulin
// - <K>: 137470629. Генерируем ссылки на типы.
// - bg fix: перегенерировал, т.к. были ссылки на несуществующие модули.
//
// Revision 1.675  2009/03/04 19:01:59  lulin
// - <K>: 137470629. Удаляем ненужный тип.
//
// Revision 1.674  2009/03/04 17:38:13  lulin
// - <K>: 137470629. Удалён ненужный интерфейс.
//
// Revision 1.673  2009/03/04 17:20:04  lulin
// - <K>: 137470629. Избавляемся от ненужного использования интерфейса.
//
// Revision 1.672  2009/03/04 16:47:55  lulin
// - <K>: 137470629. Bug fix: не собирался Эверест в ветке.
//
// Revision 1.671  2009/03/04 13:33:11  lulin
// - <K>: 137470629. Генерируем идентификаторы типов с модели и убираем их из общей помойки.
//
// Revision 1.670  2009/03/03 12:46:15  lulin
// - <K>: 137465982. Отвязываемся от внутреннего определения дочерних типов.
//
// Revision 1.669  2009/03/03 09:40:50  lulin
// - <K>: 137465982. Выделяем метод для определения детей.
//
// Revision 1.668  2009/03/02 11:41:12  lulin
// - <K>: 137465982. Делаем генерацию свойств представляемых классами, так чтобы можно было отказаться от фиксированных идентификаторов.
//
// Revision 1.667  2009/02/27 19:05:06  lulin
// - <K>: 137465982. Добавляем в конструктор свойства необходимые параметры.
//
// Revision 1.666  2009/02/27 16:59:50  lulin
// - <K>: 137465982. Добавляем в конструктор дочернего свойства необходимые параметры.
//
// Revision 1.665  2009/02/27 16:52:49  lulin
// - <K>: 137465982. Используем контроль типов.
//
// Revision 1.663  2009/02/27 16:38:38  lulin
// - <K>: 137465982. Чистка кода.
//
// Revision 1.662  2009/02/27 14:23:00  lulin
// - <K>: 137465982. Делаем генерацию свойств перечислимых типов, так чтобы можно было отказаться от фиксированных идентификаторов.
//
// Revision 1.661  2009/02/27 13:35:48  oman
// - fix: Разруливаем дедлоки (К-135595449)
//
// Revision 1.660  2009/02/27 10:01:46  lulin
// - <K>: 137465982. Делаем генерацию свойств-массивов, так чтобы можно было отказаться от фиксированных идентификаторов.
//
// Revision 1.659  2009/02/27 07:14:58  lulin
// - <K>: 137465982. №26.
//
// Revision 1.658  2009/02/26 15:52:39  lulin
// - <K>: 137465982. №4.
//
// Revision 1.657  2009/02/26 15:11:52  lulin
// - <K>: 137465982. №3.
//
// Revision 1.656  2009/02/26 13:53:49  lulin
// - <K>: 137465982. Чистка кода..
//
// Revision 1.655  2009/02/26 13:30:33  lulin
// - <K>: 137465982. Чистка кода..
//
// Revision 1.654  2009/02/26 12:25:10  lulin
// - <K>: 137465982. №1
//
// Revision 1.653  2009/02/26 10:21:28  lulin
// - <K>: 137465982. №1
//
// Revision 1.652  2009/02/26 09:35:46  lulin
// - <K>: 137465982.
//
// Revision 1.651  2009/02/26 08:58:38  lulin
// - чистка кода.
//
// Revision 1.650  2009/02/26 08:25:34  lulin
// - чистка кода.
//
// Revision 1.649  2008/12/12 19:19:28  lulin
// - <K>: 129762414.
//
// Revision 1.648  2008/09/26 17:04:07  lulin
// - <K>: 119475439.
//
// Revision 1.647  2008/08/26 11:22:06  lulin
// - чистка кода.
//
// Revision 1.646  2008/07/04 10:27:44  lulin
// - <K>: 98828572.
//
// Revision 1.645  2008/06/25 14:47:59  lulin
// - сделана возможность использовать предопределённые значения для рамок.
//
// Revision 1.644  2008/06/24 13:07:54  lulin
// - определяем стили на модели.
//
// Revision 1.643  2008/06/19 09:20:09  lulin
// - bug fix: падала генерация схемы EVD.
//
// Revision 1.642  2008/06/18 11:00:58  lulin
// - bug fix: падал Эверест.
//
// Revision 1.641  2008/06/18 10:38:30  lulin
// - падали когда в nsTagNode в коде (k2.TypeTable _As _Ik2TypeTableEx)[aNode.GetType]  значение aNode.GetType было равно 0 - псевдонода оглавления.
//
// Revision 1.640  2008/06/18 10:07:39  lulin
// - не сохраняем ссылки на типы тегов внутри базовой таблицы тегов.
//
// Revision 1.639  2008/06/18 09:54:19  lulin
// - очищаем типы тегов в сгенерированном коде.
//
// Revision 1.638  2008/06/18 09:24:26  lulin
// - cleanup.
//
// Revision 1.637  2008/06/18 09:21:43  lulin
// - определяем функцию получения типа по ID.
//
// Revision 1.636  2008/06/18 08:54:59  lulin
// - избавляемся от ненужного использования интерфейса.
//
// Revision 1.635  2008/06/18 08:49:52  lulin
// - обеспечиваем автоматическое связывание с указанной таблицей тегов.
//
// Revision 1.634  2008/06/18 08:17:34  lulin
// - поддерживаем singleton для таблицы тегов на системном уровне.
//
// Revision 1.633  2008/06/17 21:19:57  lulin
// - рисуем схему EVD на модели.
//
// Revision 1.632  2008/06/17 20:44:48  lulin
// - рисуем схему EVD на модели.
//
// Revision 1.631  2008/06/10 19:38:31  lulin
// - генерируем функции для создания экземпляров тегов.
//
// Revision 1.630  2008/06/10 14:38:40  lulin
// - храним ссылки на типы в полях таблицы тегов.
//
// Revision 1.629  2008/06/10 14:00:36  lulin
// - таблицы тегов генерируем как классы.
//
// Revision 1.628  2008/06/09 15:29:58  lulin
// - рисуем схему EVD на модели.
//
// Revision 1.627  2008/06/09 14:03:31  lulin
// - рисуем схему EVD на модели.
//
// Revision 1.626  2008/06/09 06:11:01  lulin
// - bug fix: не собирался Архивариус.
//
// Revision 1.625  2008/06/07 15:37:11  lulin
// - используем сгенерированную таблицу тегов.
//
// Revision 1.624  2008/06/06 16:01:20  lulin
// - <K>: 93264011.
//
// Revision 1.623  2008/05/23 12:03:18  lulin
// - заплатка для старых SBS.
//
// Revision 1.622  2008/05/12 15:11:05  lulin
// - удалены ненужные интерфейсы.
//
// Revision 1.621  2008/04/16 12:26:35  lulin
// - cleanup.
//
// Revision 1.620  2008/04/15 12:25:06  dinishev
// Защищаемся от перегенерации
//
// Revision 1.619  2008/04/15 09:09:06  lulin
// - перекладываем исключение.
//
// Revision 1.618  2008/04/15 09:03:23  lulin
// - правим название директив - чтобы соответствовали смыслу.
//
// Revision 1.617  2008/04/15 08:25:45  dinishev
// Восстанавливаем старый редактор
//
// Revision 1.616  2008/02/21 19:24:16  lulin
// - упрощаем наследование.
//
// Revision 1.615  2008/02/21 16:04:28  lulin
// - упрощаем наследование.
//
// Revision 1.613  2008/02/21 13:48:21  lulin
// - cleanup.
//
// Revision 1.612  2008/02/21 10:55:13  lulin
// - упрощаем наследование.
//
// Revision 1.611  2008/02/20 19:01:27  lulin
// - удалён ненужный тип.
//
// Revision 1.610  2008/02/20 17:23:07  lulin
// - упрощаем строки.
//
// Revision 1.609  2008/02/20 12:39:14  lulin
// - определены методы сравнения тега.
//
// Revision 1.608  2008/02/19 11:05:58  lulin
// - восстановил всякие экзотические поиски в списках объектов.
//
// Revision 1.607  2008/02/18 17:04:26  lulin
// - подчистил логику списков, связанную с сортированностью и добавлением элемента.
//
// Revision 1.606  2008/02/14 17:09:12  lulin
// - cleanup.
//
// Revision 1.605  2008/02/14 09:40:41  lulin
// - удалён ненужный класс.
//
// Revision 1.604  2008/02/13 20:20:13  lulin
// - <TDN>: 73.
//
// Revision 1.603  2008/02/12 12:53:20  lulin
// - избавляемся от излишнего метода на базовом классе.
//
// Revision 1.602  2008/02/11 18:30:43  lulin
// - чистим ненужный код.
//
// Revision 1.601  2008/02/11 18:16:33  lulin
// - наводим красоту.
//
// Revision 1.600  2008/02/11 11:13:55  lulin
// - чистка списков.
//
// Revision 1.599  2008/02/08 17:59:19  lulin
// - теперь теги в списках храним как теги, а не как объекты.
//
// Revision 1.598  2008/02/08 17:06:20  lulin
// - класс _Tk2TagObject переехал на модель.
//
// Revision 1.597  2008/02/07 19:13:15  lulin
// - избавляемся от излишне универсальных методов базовых списков.
//
// Revision 1.596  2008/02/07 16:19:20  lulin
// - наводим порядок с наследованием и перекрытием методов.
//
// Revision 1.595  2008/02/06 15:37:08  lulin
// - каждому базовому объекту по собственному модулю.
//
// Revision 1.594  2008/02/06 09:55:29  lulin
// - глобальные объекты сделаны индексированным свойством.
//
// Revision 1.593  2008/02/05 18:20:39  lulin
// - удалено ненужное свойство строк.
//
// Revision 1.592  2008/02/05 09:58:09  lulin
// - выделяем базовые объекты в отдельные файлы и переносим их на модель.
//
// Revision 1.591  2008/02/01 15:14:52  lulin
// - избавляемся от излишней универсальности списков.
//
// Revision 1.590  2008/01/31 20:09:57  lulin
// - избавляемся от излишней универсальности списков.
//
// Revision 1.589  2007/12/24 15:25:30  lulin
// - удалены ненужные файлы.
//
// Revision 1.588  2007/12/05 14:15:14  lulin
// - восстановлена поддержка подписей в очень старых документах.
//
// Revision 1.587  2007/12/05 12:35:08  lulin
// - вычищен условный код, составлявший разницу ветки и Head'а.
//
// Revision 1.586  2007/09/21 12:10:47  lulin
// - bug fix: падали при сохранении документа, при отсутствии процессора.
//
// Revision 1.585  2007/09/17 18:26:14  lulin
// - вставлена диагностика того, что наследуемый тип тегов имеет такую же реализацию, как и родительский.
//
// Revision 1.584  2007/09/17 18:04:15  lulin
// - проверяем корректность определения таблицы тегов.
//
// Revision 1.583  2007/09/14 13:26:19  lulin
// - объединил с веткой B_Tag_Clean.
//
// Revision 1.582.2.25  2007/09/14 12:34:21  lulin
// - убрана дублирующаяся функциональность.
//
// Revision 1.582.2.24  2007/09/13 18:09:19  lulin
// - не спрашиваем интерфейс тега у объекта, который его заведомо не поддерживает.
//
// Revision 1.582.2.23  2007/09/13 17:51:45  lulin
// - упрощаем получение интерфейса у объекта - кешируем раз и навсегда информацию о смещении, которая вычисляется не очень уж просто.
//
// Revision 1.582.2.22  2007/09/13 17:18:32  lulin
// - удален, ставший ненужным фабричный метод.
//
// Revision 1.582.2.21  2007/09/13 16:38:59  lulin
// - проверку прозрачности переносим в другое место.
//
// Revision 1.582.2.20  2007/09/13 16:15:51  lulin
// - удален старый класс для атомарных тегов.
//
// Revision 1.582.2.19  2007/09/13 15:54:41  lulin
// - используем новый объект для атомарных тегов.
//
// Revision 1.582.2.18  2007/09/13 15:12:47  lulin
// - в первом приближении реализован атомарный тег.
//
// Revision 1.582.2.17  2007/09/13 13:21:19  lulin
// - добавлен новый модуль.
//
// Revision 1.582.2.16  2007/09/13 12:51:33  lulin
// - cleanup.
//
// Revision 1.582.2.15  2007/09/13 12:36:00  lulin
// - переименовано свойство.
//
// Revision 1.582.2.14  2007/09/13 12:00:04  lulin
// - убран ненужный метод.
//
// Revision 1.582.2.13  2007/09/13 11:53:31  lulin
// - убран ненужный метод.
//
// Revision 1.582.2.12  2007/09/12 20:23:52  lulin
// - возвращаем булевский результат, а не какой-то там код ошибки, который нафиг никому не нужен.
//
// Revision 1.582.2.11  2007/09/12 20:13:10  lulin
// - cleanup.
//
// Revision 1.582.2.10  2007/09/12 18:12:10  lulin
// - cleanup.
//
// Revision 1.582.2.9  2007/09/12 18:06:03  lulin
// - cleanup.
//
// Revision 1.582.2.8  2007/09/12 17:56:17  lulin
// - убрана ненужная функциональность.
//
// Revision 1.582.2.7  2007/09/12 17:51:50  lulin
// - cleanup.
//
// Revision 1.582.2.6  2007/09/12 17:19:06  lulin
// - убран ненужный параметр.
//
// Revision 1.582.2.5  2007/09/12 17:08:18  lulin
// - cleanup.
//
// Revision 1.582.2.4  2007/09/12 17:02:07  lulin
// - убран ненужный параметр по-умолчанию.
//
// Revision 1.582.2.3  2007/09/12 16:38:31  lulin
// - переименовано свойство.
//
// Revision 1.582.2.2  2007/09/12 16:14:12  lulin
// - убран ненужный параметр по-умолчанию.
//
// Revision 1.582.2.1  2007/09/12 15:23:11  lulin
// - избавляемся от метода, дублирующего функциональность получения атрибута.
//
// Revision 1.582  2007/09/11 18:50:04  lulin
// - удален ненужный параметр.
//
// Revision 1.581  2007/09/10 10:49:58  lulin
// - bug fix: не учитывали прозрачность.
//
// Revision 1.580  2007/09/10 10:20:59  lulin
// - падали с Assert (CQ OIT5-26635).
//
// Revision 1.579  2007/09/10 10:19:27  lulin
// - удален ненужный метод.
//
// Revision 1.578  2007/09/07 19:02:14  lulin
// - удален ненужный параметр.
//
// Revision 1.577  2007/09/07 18:50:54  lulin
// - удалены ненужные значения по-умолчанию.
//
// Revision 1.576  2007/09/07 14:17:08  lulin
// - вычищена функциональность, ненужная в ветке.
//
// Revision 1.575  2007/09/07 11:59:52  lulin
// - убрана ненужная нотификация.
//
// Revision 1.574  2007/09/07 10:48:07  lulin
// - оптимизируем преобразование атомарных тегов.
//
// Revision 1.573  2007/09/07 09:16:19  lulin
// - убран ненужный параметр.
//
// Revision 1.572  2007/09/07 09:07:25  lulin
// - cleanup.
//
// Revision 1.571  2007/09/07 08:51:28  lulin
// - cleanup.
//
// Revision 1.570  2007/09/07 08:27:33  lulin
// - теперь тегам можно устанавливать свойства в виде объектов.
//
// Revision 1.569  2007/09/06 15:21:28  lulin
// - переименовано свойство.
//
// Revision 1.568  2007/09/06 09:37:45  lulin
// - переименовано свойство.
//
// Revision 1.567  2007/09/04 18:06:22  lulin
// - cleanup.
//
// Revision 1.566  2007/09/04 17:27:43  lulin
// - убран ненужный параметр.
//
// Revision 1.565  2007/09/04 16:35:46  lulin
// - переименована структура данных.
//
// Revision 1.564  2007/09/04 16:29:06  lulin
// - cleanup.
//
// Revision 1.563  2007/09/04 15:54:20  lulin
// - убран ненужный параметр.
//
// Revision 1.562  2007/09/04 15:45:14  lulin
// - убран ненужный параметр.
//
// Revision 1.561  2007/09/04 14:24:58  lulin
// - убран ненужный параметр.
//
// Revision 1.560  2007/09/03 10:46:48  lulin
// - уменьшаем число параметров.
//
// Revision 1.559  2007/08/31 16:06:30  lulin
// - cleanup.
//
// Revision 1.558  2007/08/31 12:08:48  lulin
// - cleanup.
//
// Revision 1.557  2007/08/30 12:27:37  lulin
// - вычищены ненужные исключения.
//
// Revision 1.556  2007/08/30 12:19:07  lulin
// - cleanup.
//
// Revision 1.555  2007/08/30 11:45:02  lulin
// - удален ненужный модуль.
//
// Revision 1.554  2007/08/29 12:22:46  lulin
// - cleanup.
//
// Revision 1.553  2007/08/21 11:39:50  lulin
// - избавляемся от предупреждений компилятора.
//
// Revision 1.552  2007/08/14 15:56:47  lulin
// - описатели типов выделяем в блочной памяти.
//
// Revision 1.551  2007/08/13 17:41:20  lulin
// - вычищена ненужная функциональность по построению дерева тегов.
//
// Revision 1.550  2007/08/13 13:49:47  lulin
// - ведем себя как Null-объект, если Self = nil.
//
// Revision 1.549  2007/08/10 15:05:29  lulin
// - избавляемся от излишнего использования интерфейсов, т.к. переносимость может быть достигнута другими методами.
//
// Revision 1.548  2007/08/10 14:44:45  lulin
// - cleanup.
//
// Revision 1.547  2007/08/10 13:09:45  lulin
// - избавляемся от излишнего использования интерфейсов, т.к. переносимость может быть достигнута другими методами.
//
// Revision 1.546  2007/08/10 08:46:24  lulin
// - cleanup.
//
// Revision 1.545  2007/08/10 08:30:14  lulin
// - избавляемся от излишнего использования интерфейсов, т.к. переносимость может быть достигнута другими методами.
//
// Revision 1.544  2007/08/09 18:59:31  lulin
// - cleanup.
//
// Revision 1.543  2007/08/09 17:17:13  lulin
// - bug fix: не собирался Архивариус.
//
// Revision 1.542  2007/08/09 16:44:45  lulin
// - bug fix: не собирался Эверест.
//
// Revision 1.541  2007/08/09 14:55:27  lulin
// - избавляемся от излишнего использования интерфейсов.
//
// Revision 1.540  2007/08/09 12:38:17  lulin
// - убираем замороченную логику с присвоением таблицы тегов.
//
// Revision 1.539  2007/08/09 11:19:27  lulin
// - cleanup.
//
// Revision 1.538  2007/08/09 10:36:28  lulin
// - стараемся поменьше дергать счетчик ссылок свойств тегов при чтении EVD.
//
// Revision 1.537  2007/08/09 09:17:55  lulin
// - cleanup.
//
// Revision 1.536  2007/07/13 15:57:34  lulin
// - не сохраняем теги, которые непонятно как сохранять.
//
// Revision 1.535  2007/07/12 17:53:11  lulin
// - закончил описывать классы, реализующие теги.
//
// Revision 1.534  2007/07/12 17:32:07  lulin
// - генерируем теги определенные через простые классы.
//
// Revision 1.533  2007/07/09 08:18:09  lulin
// - упрощаем код для генерации.
//
// Revision 1.532  2007/07/06 08:32:22  lulin
// - упрощаем код для генерации.
//
// Revision 1.531  2007/07/05 15:02:40  lulin
// - упрощаем код для генерации.
//
// Revision 1.530  2007/07/05 11:36:20  lulin
// - упрощаем код для генерации.
//
// Revision 1.529  2007/05/24 11:37:38  lulin
// - new behavior: в тегах возможна комплексная сортировка, пока не более 4-х полей. Адреса гиперссылок теперь проверяются на дубликаты.
//
// Revision 1.528  2007/05/24 09:35:52  lulin
// - bug fix: не падаем, если хотим получить несуществующее свойство.
//
// Revision 1.527  2007/05/24 09:24:20  lulin
// - по-другому идентифицируем комплексную сортировку.
//
// Revision 1.526  2007/03/16 14:47:29  lulin
// - cleanup.
//
// Revision 1.525  2007/02/20 13:01:13  lulin
// - bug fix: не собирались утилиты от Арчи.
//
// Revision 1.524  2007/02/16 15:36:07  lulin
// - cleanup.
//
// Revision 1.523  2007/01/30 15:24:21  lulin
// - текст ноды - теперь более простого типа.
//
// Revision 1.522  2006/12/25 10:20:27  lulin
// - параметры строки теперь получаем одним вызовом, а не тремя.
//
// Revision 1.521  2006/11/03 11:00:44  lulin
// - объединил с веткой 6.4.
//
// Revision 1.520  2006/10/20 14:54:33  dinishev
// Bug fix: при выключении директивы _k2NeedChildSpy переставало компилироваться
//
// Revision 1.519  2006/10/02 11:11:35  lulin
// - cleanup.
//
// Revision 1.518  2006/10/02 10:35:15  lulin
// - контроллируем, что временные теги нельзя сохранять.
//
// Revision 1.517  2006/07/21 11:40:31  lulin
// - имя метода убрано из комментариев - чтобы не находилось контекстным поиском.
//
// Revision 1.516  2006/07/21 11:36:39  lulin
// - имя метода убрано из комментариев - чтобы не находилось контекстным поиском.
//
// Revision 1.515  2006/06/28 11:33:02  voba
// - bug fix от Шуры
//
// Revision 1.514  2006/06/27 12:18:40  lulin
// - избавляемся от шаманства с типом свойства, отвечающего за сохраняемость атрибута.
//
// Revision 1.513  2006/05/02 11:16:24  lulin
// - вытерта лишняя процедура сортировки.
//
// Revision 1.512  2006/05/02 08:47:45  lulin
// - вычищено значение по-умолчанию.
//
// Revision 1.511  2006/05/02 07:01:16  lulin
// - сделан метод установки порядка тегов.
//
// Revision 1.510  2006/04/24 12:58:44  lulin
// - выпиливаем из списков общую функциональность.
//
// Revision 1.509  2006/04/20 13:35:36  voba
// -  change in Tl3_CustomString - вместо pm_GetSt теперь перекрываем DoGetSt
//
// Revision 1.508  2006/04/11 17:55:28  lulin
// - оптимизируем при помощи вынесения строк (по следам того как Вован наиграл в фильтрах 20% производительности).
//
// Revision 1.507  2006/04/11 16:35:36  lulin
// - оптимизируем при помощи вынесения строк (по следам того как Вован наиграл в фильтрах 20% производительности).
//
// Revision 1.506  2006/01/30 09:49:49  lulin
// - убран ненужный параметр.
//
// Revision 1.505  2006/01/18 15:27:24  lulin
// - new behavior: сделана возможность ограничивать количество дочерних тегов.
//
// Revision 1.504  2006/01/18 10:38:20  lulin
// - bug fix: не компилировалось тестовое приложение.
//
// Revision 1.503  2006/01/17 15:10:40  lulin
// - выделен метод установки атрибута тега.
//
// Revision 1.502  2006/01/16 17:56:41  lulin
// - cleanup.
//
// Revision 1.501  2006/01/16 16:41:43  lulin
// - сделана возможность работать со строками без теговых оберток (почему-то на производительность не повлияло).
//
// Revision 1.500  2006/01/16 11:31:08  lulin
// - убран метод удаления параграфа, т.к. для этих целей полностью подходит метод удаления тега.
//
// Revision 1.499  2006/01/13 12:59:10  lulin
// - bug fix: в Undo-буфер попадала лишняя запись (CQ OIT5-19077).
//
// Revision 1.498  2006/01/11 15:30:10  lulin
// - сделано взведение флага Modified для словарных атрибутов документа.
//
// Revision 1.497  2005/12/28 12:54:28  lulin
// - bug fix: не компилировалось.
//
// Revision 1.496  2005/12/26 13:26:54  lulin
// - bug fix: не всегда отображалось изменение комментариев (CQ OIT5-18865).
//
// Revision 1.495  2005/12/14 09:42:10  lulin
// - убрал лишний параметр, из-за которого не компилировался HEAD.
//
// Revision 1.494  2005/12/09 15:44:17  lulin
// - bug fix: слишком поздно корректировали стиль параграфов в комментарии (CQ OIT5-18487).
//
// Revision 1.493  2005/12/02 22:03:51  lulin
// - запрос валидности операции посылается теперь через базовые объекты, а не шаманскими методами.
//
// Revision 1.492  2005/12/02 18:23:36  lulin
// - обрабока нотфификации об удалении/добавлении параграфа практически полностью перенесена на процессор.
//
// Revision 1.491  2005/12/02 13:31:23  lulin
// - установкой/сбрасыванием родительского тега управляем в базовых методах.
//
// Revision 1.490  2005/12/02 12:36:51  lulin
// - выделен шаблон для тегов, которые имеют владельца.
//
// Revision 1.489  2005/11/21 11:02:51  lulin
// - bug fix: при уходе документа в историю не сохранялись комментарии.
//
// Revision 1.488  2005/11/07 12:30:25  lulin
// - bug fix: не форматировались напрогруженные, но отображаемые параграфы.
//
// Revision 1.487  2005/11/04 10:04:04  lulin
// - optimization: избавился от необходимости расчета AbsIndex при листании по странице вниз.
//
// Revision 1.486  2005/11/03 16:33:49  lulin
// - optimization: при переформатировании документа итерируем только непрогруженные параграфы.
//
// Revision 1.485  2005/10/18 07:19:45  lulin
// - new behavior: теперь методы вставки и добавления дочерних тегов могут подменять вставляемые теги.
//
// Revision 1.484  2005/09/06 14:52:36  lulin
// - bug fix: не редактировались названия словарных статей.
//
// Revision 1.483  2005/08/31 13:02:49  lulin
// - спрятаны методы, которые не нужны в ветке.
//
// Revision 1.482  2005/08/29 15:03:07  lulin
// - cleanup.
//
// Revision 1.481  2005/08/29 14:43:20  lulin
// - new behavior: при вставке нескольких текстовых параграфов вставляем несколько контролов.
//
// Revision 1.480  2005/08/24 06:10:26  mmorozov
// change: изжит Tk2Bool вместо него используется Tl3Bool;
//
// Revision 1.479  2005/08/23 07:19:10  mmorozov
// change: названия перечислимого типа Tk2Bool, который стал Tl3Bool;
//
// Revision 1.478  2005/07/19 09:54:35  lulin
// - приводим родителя к контейнеру документа более дешевым способом.
//
// Revision 1.477  2005/07/04 14:45:57  lulin
// - оптимизация - приводим Tl3Stream к IStream без использования _Supports.
//
// Revision 1.476  2005/07/04 12:20:47  lulin
// - попытка открутить тип реализации и базовый тип.
// - bug fix: для Tl3Stream не было подсчета ссылок.
// - bug fix: IUnknown не приводился к IStream, даже если такое было возможно.
//
// Revision 1.475  2005/06/30 13:39:24  lulin
// - оптимизирован метод _Tk2Type._InheritsFrom - в результате ГК стал грузится вместо 1.8 - 1.5 сек.
//
// Revision 1.474  2005/06/29 15:15:53  lulin
// - записываем названия типов.
//
// Revision 1.473  2005/06/29 08:33:14  lulin
// - запил для скорости - не сообщаем об изменении AllChildrenCount.
//
// Revision 1.472  2005/04/28 15:04:09  lulin
// - переложил ветку B_Tag_Box в HEAD.
//
// Revision 1.471  2005/04/22 12:08:34  demon
// - fix: был AV при попытке выделения строки таблицы (в операцию _Tk2ObjectTag._rLong добавлена проверка l_Prop <> nil).
//
// Revision 1.470.2.29  2005/04/27 07:15:23  lulin
// - bug fix: криво описывался тип дочерних тегов - в результате например не ставились ссылки.
//
// Revision 1.470.2.28  2005/04/26 16:07:10  lulin
// - уменьшаем число лишних вызовов.
//
// Revision 1.470.2.27  2005/04/26 14:30:54  lulin
// - ускоряем l3Free и _l3Use.
//
// Revision 1.470.2.26  2005/04/25 15:43:26  lulin
// - попроще получаем ссылку.
//
// Revision 1.470.2.25  2005/04/25 14:27:32  lulin
// - изменена стратегия приведения.
//
// Revision 1.470.2.24  2005/04/25 13:07:42  lulin
// - избавился от Assert'а.
//
// Revision 1.470.2.23  2005/04/25 11:21:00  lulin
// - борьба с остающимся объектом (пока неудачно).
//
// Revision 1.470.2.22  2005/04/25 08:22:44  lulin
// - cleanup: убрал сообщение о присваивании тега с обертки.
//
// Revision 1.470.2.21  2005/04/23 16:33:07  lulin
// - удален ненужный метод.
//
// Revision 1.470.2.20  2005/04/23 16:23:02  lulin
// - remove prop: _Ik2Tag.AttrWP.
//
// Revision 1.470.2.19  2005/04/23 16:07:35  lulin
// - удален временный интерфейс Ik2TagBox.
//
// Revision 1.470.2.18  2005/04/23 15:19:25  lulin
// - remove method: _Ik2Tag._SetSubAtom - как сложный и ведущий к неоптимальному коду.
//
// Revision 1.470.2.17  2005/04/23 13:28:39  lulin
// - new define: k2TagUseDefaultValue.
//
// Revision 1.470.2.16  2005/04/23 12:44:12  lulin
// - cleanup.
//
// Revision 1.470.2.15  2005/04/23 11:54:36  lulin
// - уменьшено количество преобразований. Чуть чуть выиграл время.
//
// Revision 1.470.2.14  2005/04/23 10:38:00  lulin
// - избавился от динамического преобразования типов.
//
// Revision 1.470.2.13  2005/04/23 09:42:49  lulin
// - уменьшено количество изменений счетчиков ссылок интерфейсов.
//
// Revision 1.470.2.12  2005/04/22 15:31:56  lulin
// - bug fix: восстановлена работоспособность параграфов с контролами.
//
// Revision 1.470.2.11  2005/04/22 15:23:23  lulin
// - вернул работоспособность параграфов с картинками и формул.
//
// Revision 1.470.2.10  2005/04/22 14:46:50  lulin
// - вернул работоспособность параграфов с картинками.
//
// Revision 1.470.2.9  2005/04/22 12:47:56  lulin
// - вернулся от интерфейсов к объектам.
//
// Revision 1.470.2.8  2005/04/22 12:14:29  lulin
// - remove interface: Ik2PropertyBag.
//
// Revision 1.470.2.7  2005/04/22 10:47:20  lulin
// - cleanup: убрано ненужное и непонятное свойство.
//
// Revision 1.470.2.6  2005/04/22 10:40:30  lulin
// - cleanup: убраны ненужные параметры.
//
// Revision 1.470.2.5  2005/04/22 09:04:37  lulin
// - cleanup: убраны ненужные параметры.
//
// Revision 1.470.2.4  2005/04/21 17:28:16  lulin
// - cleanup.
//
// Revision 1.470.2.3  2005/04/21 16:30:19  lulin
// - избавился от лишних оберточных классов.
//
// Revision 1.470.2.2  2005/04/21 15:36:42  lulin
// - окончательно избавился от необходимости обертки.
//
// Revision 1.470.2.1  2005/04/21 14:47:02  lulin
// - избавляемся от обертки над тегами - теперь объекты посредством шаблонов сами реализуют интерфейс _Ik2Tag.
//
// Revision 1.470  2005/04/21 05:11:48  lulin
// - используем _Box (пока из-за постоянных преобразований туда и обратно - по скорости стало только хуже).
//
// Revision 1.469  2005/04/20 17:40:57  lulin
// - избавился от промежуточного интерфейса Ik2TagBoxQT.
//
// Revision 1.468  2005/04/20 13:38:45  lulin
// - new method: Ik2TagBox._InheritsFrom.
//
// Revision 1.467  2005/04/20 13:17:57  lulin
// - подготовительная работа для возможности не преобразовывать целые числа в теги.
//
// Revision 1.466  2005/04/19 18:23:16  lulin
// - подготовительная работа для возможности не преобразовывать целые числа в теги.
//
// Revision 1.465  2005/04/19 18:11:09  lulin
// - не делаем лишние действия для тегов, которые про это все равно не знают.
//
// Revision 1.464  2005/04/19 18:02:14  lulin
// - выделен метод _DeleteMapped.
//
// Revision 1.463  2005/04/19 17:55:22  lulin
// - выделен дублирующийся код.
//
// Revision 1.462  2005/04/19 17:22:05  lulin
// - небольшая оптимизация.
//
// Revision 1.461  2005/04/19 16:57:30  lulin
// - new interface: IevSimpleView.
//
// Revision 1.460  2005/04/19 13:55:29  lulin
// - оптимальнее "перетасовал" код :-(.
//
// Revision 1.459  2005/04/19 13:25:14  lulin
// - оптимальнее "перетасовал" код :-(.
//
// Revision 1.458  2005/04/19 12:22:19  lulin
// - убраны лишние преобразования.
//
// Revision 1.457  2005/04/19 08:48:24  lulin
// - убран лишний запрос интерфейса вверх к родителю.
//
// Revision 1.456  2005/04/19 07:14:52  lulin
// - небольшая оптимизация.
//
// Revision 1.455  2005/04/18 17:18:29  lulin
// - используем _Box, а не _Ik2Tag (пока выигрыша в производительности не дало).
//
// Revision 1.454  2005/04/18 09:51:44  lulin
// - кешируем целочисленные теги.
//
// Revision 1.453  2005/04/15 09:19:59  lulin
// - убран лишний вызов.
//
// Revision 1.452  2005/04/15 08:59:57  lulin
// - теперь держим ссылку на тег, а не собственно тег.
//
// Revision 1.451  2005/04/12 09:53:09  lulin
// - объединил с веткой - в попытках починить List Index Out Of Bounds.
//
// Revision 1.450.2.6  2005/04/10 11:15:47  lulin
// - отключил k2CacheChild для ветки.
//
// Revision 1.450.2.5  2005/04/10 11:08:35  lulin
// - new define: k2CacheChild.
//
// Revision 1.450.2.3  2005/04/10 10:58:32  lulin
// - new define: k2CacheInner.
//
// Revision 1.450.2.2  2005/04/08 12:00:38  lulin
// - _Processor стал обязательным параметром.
//
// Revision 1.450.2.1  2005/04/08 11:42:11  lulin
// - теперь инструменты получают нотификацию об удалении тегов.
//
// Revision 1.450  2005/04/07 16:20:43  lulin
// - new method: Ik2TagBoxQT._MakeInterface.
//
// Revision 1.449  2005/04/07 14:35:35  lulin
// - remove proc: evGetTopPara.
//
// Revision 1.448  2005/04/06 14:34:04  lulin
// - bug fix: отдавали не тот интерфейс, который нас просили.
//
// Revision 1.447  2005/04/06 12:19:53  lulin
// - bug fix: не сохранялись картинки.
//
// Revision 1.446  2005/04/06 08:47:20  lulin
// - связываем инструменты в цепочки для более быстрого получения интересующего инструмента.
//
// Revision 1.445  2005/04/05 16:07:07  lulin
// - new behavior: теперь иструменты имеют возможность получать нотификацию об изменении атрибутов.
//
// Revision 1.444  2005/04/04 07:19:06  lulin
// - cleanup.
//
// Revision 1.443  2005/04/04 06:44:07  lulin
// - в связи с появлением механизма событий и фасада библиотеки K-2, удалены глобальные "заплатки" связанные с созданием/уничтожением таблицы тегов.
//
// Revision 1.442  2005/04/01 16:18:42  lulin
// - new behavior: теперь рассылаем всем объектам извещение о том, что таблица тегов сейчас уничтожится.
//
// Revision 1.441  2005/03/31 14:47:00  lulin
// - new behavior: используем InevParaList.InsertPara вместо evDir_InsertPara.
//
// Revision 1.440  2005/03/31 11:03:30  lulin
// - добавлен параметр - _Processor.
//
// Revision 1.439  2005/03/30 17:39:31  lulin
// - исправлен префикс у типов.
//
// Revision 1.438  2005/03/30 16:09:22  lulin
// - не сохраняем блоки в (старый) кеш ибо незачем.
//
// Revision 1.437  2005/03/30 15:56:30  lulin
// - TevLocation теперь наследуется от Tk2Tool - базового класса для инструментов тегов.
//
// Revision 1.436  2005/03/30 15:12:24  lulin
// - в _QueryTool теперь подаем тег для которого надо сделать инструмент.
//
// Revision 1.435  2005/03/30 14:56:11  lulin
// - спрятан старый интерфейс.
//
// Revision 1.434  2005/03/30 13:31:46  lulin
// - bug fix: иногда целые числа попадали в слот объектов.
//
// Revision 1.433  2005/03/30 09:44:36  lulin
// - bug fix: неправильно работала функция _FindChild - в Undo буфер в итоге клались записи невалидной структуры.
//
// Revision 1.432  2005/03/30 09:17:31  lulin
// - bug fix: не добавлялись дети по индексу.
//
// Revision 1.431  2005/03/29 14:29:08  lulin
// - bug fix: не сохраняем тег в Generator = nil.
//
// Revision 1.430  2005/03/29 12:40:24  lulin
// - new method: _Ik2Tag._FindChild.
//
// Revision 1.429  2005/03/29 08:48:00  lulin
// - bug fix: пытались присвоить _ReadOnly-свойства в методе _Assign - в результате exception - в результате невозможно было вставить колонку таблицы.
//
// Revision 1.428  2005/03/28 17:45:17  lulin
// - избавился от шаманства при присваивании параметров сортировки детей тега.
//
// Revision 1.427  2005/03/28 16:59:44  lulin
// - пореже дергаем QueryInterface по всей цепочке родителей.
//
// Revision 1.426  2005/03/28 14:30:09  lulin
// - от класса генераторов переходим к интерфейсу.
//
// Revision 1.425  2005/03/28 11:32:28  lulin
// - интерфейсы переехали в "правильный" модуль.
//
// Revision 1.424  2005/03/28 06:37:16  lulin
// - remove object: Tk2AtomW.
//
// Revision 1.423  2005/03/25 18:29:35  lulin
// - избавляемся от метода Tk2AtomW.sClass.
//
// Revision 1.422  2005/03/25 17:53:24  lulin
// - cleanup.
//
// Revision 1.421  2005/03/25 17:09:17  lulin
// - избавляемся от метода Tk2AtomW.sLong.
//
// Revision 1.420  2005/03/25 12:12:17  lulin
// - используем _Ik2Type вместо _Tk2Type.
//
// Revision 1.419  2005/03/25 11:20:37  lulin
// - cleanup.
//
// Revision 1.417  2005/03/25 10:28:47  lulin
// - cleanup.
//
// Revision 1.416  2005/03/24 18:39:30  lulin
// - remove object: Tk2AtomR.
//
// Revision 1.415  2005/03/24 16:15:30  lulin
// - bug fix: при запросе атрибутов - прозрачность трактовалась как отсутствие атрибута - в итоге например неправильно выливались в NSRC ссылки в комментариях.
//
// Revision 1.414  2005/03/24 15:25:54  lulin
// - удалены ненужные методы.
//
// Revision 1.413  2005/03/24 14:10:40  lulin
// - удалены ненужные методы.
//
// Revision 1.412  2005/03/24 13:30:53  lulin
// - удалена функция преобразования Tk2AtomR к Ik2TagBox.
//
// Revision 1.411  2005/03/24 13:14:43  lulin
// - уделена ненужная функция преобразования Tk2AtomR к _Ik2Tag.
//
// Revision 1.410  2005/03/24 12:18:02  lulin
// - удален ненужный _Make.
//
// Revision 1.409  2005/03/24 12:08:21  lulin
// - remove method: Ik2TagBox.Tag.
// - new method: Ik2TagBox._Target.
//
// Revision 1.408  2005/03/23 15:48:13  lulin
// - cleanup.
//
// Revision 1.407  2005/03/23 15:37:07  lulin
// - удалено ненужное исключение.
//
// Revision 1.406  2005/03/23 15:29:20  lulin
// - итератор по свойствам внутри тега приобрел нормальный вид, а не какой-то шаманский.
//
// Revision 1.405  2005/03/23 12:09:22  lulin
// - bug fix: не учитывались прозрачные значения.
//
// Revision 1.404  2005/03/23 12:00:53  lulin
// - cleanup.
//
// Revision 1.403  2005/03/23 11:16:32  lulin
// - удалено ненужное исключение.
//
// Revision 1.402  2005/03/23 10:23:51  lulin
// - bug fix: был AV при попытке освобождения прозрачного свойства, которое в нормальных условиях представляется объектом.
//
// Revision 1.401  2005/03/23 09:52:01  lulin
// - new prop: _Ik2Tag.BoolA.
//
// Revision 1.400  2005/03/23 08:55:23  lulin
// - bug fix: не компилировалось.
//
// Revision 1.399  2005/03/23 08:46:35  lulin
// - методы для установки свойств перенесены на _Ik2Tag.
//
// Revision 1.398  2005/03/22 17:03:07  lulin
// - спрятаны ненужные методы. Чуть подоптимизирована загрузка - ГК в Эвересте на 1 сек меньше.
//
// Revision 1.397  2005/03/22 15:45:30  lulin
// - убраны ненужные методы.
//
// Revision 1.396  2005/03/22 14:50:43  lulin
// - new method: _Ik2TypeTable.VariantToTag.
//
// Revision 1.395  2005/03/22 14:30:12  lulin
// - new method: _Ik2TypeTable.IUnknownToTag.
//
// Revision 1.394  2005/03/22 14:25:30  lulin
// - new method: _Ik2TypeTable.ObjectToTag.
//
// Revision 1.393  2005/03/22 14:18:15  lulin
// - new method: _Ik2TypeTable.StringToTag.
//
// Revision 1.392  2005/03/22 14:11:38  lulin
// - new method: _Ik2TypeTable.BoolToTag.
//
// Revision 1.391  2005/03/22 14:08:55  lulin
// - new method: _Ik2TypeTable.LongToTag.
//
// Revision 1.390  2005/03/22 13:40:16  lulin
// - new method: _Ik2Tag._IsStream.
//
// Revision 1.389  2005/03/22 13:35:51  lulin
// - используем честный итератор, вместо шаманского запроса интерфейса.
//
// Revision 1.388  2005/03/22 13:23:20  lulin
// - new class: Tk2StreamTag.
//
// Revision 1.387  2005/03/22 13:16:16  lulin
// - вместо _Tl3Base импользуем TObject.
//
// Revision 1.386  2005/03/22 13:07:15  lulin
// - bug fix: была возможность присвоить неправильный тип.
//
// Revision 1.385  2005/03/22 12:50:54  lulin
// - bug fix: для объектов = nil создавался ненулевой тег.
//
// Revision 1.384  2005/03/22 12:42:18  lulin
// - bug fix: установка стиля убивала гиперссылки.
//
// Revision 1.383  2005/03/22 10:38:03  lulin
// - cleanup.
//
// Revision 1.382  2005/03/22 10:15:43  lulin
// - оптимизация: при поиске слота для дочернего элемента сравниваем типы по ID, а не по имени.
//
// Revision 1.381  2005/03/22 10:02:15  lulin
// - оптимизирован поиск места размещения дочерних тегов.
//
// Revision 1.380  2005/03/22 09:47:58  lulin
// - убраны ненужные преобразования между Tk2AtomR и _Ik2Tag.
//
// Revision 1.379  2005/03/22 07:54:52  lulin
// - remove method: Tk2AtomR.AsIUnknown.
//
// Revision 1.378  2005/03/21 17:11:36  lulin
// - new method: _Ik2Type._IsOrd.
//
// Revision 1.377  2005/03/21 16:45:04  lulin
// - new method: _Ik2BaseDef._IsNull.
//
// Revision 1.376  2005/03/21 16:28:21  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.375  2005/03/21 13:43:04  lulin
// - убраны ненужные методы.
//
// Revision 1.374  2005/03/21 12:25:27  lulin
// - bug fix: не компилировалось.
//
// Revision 1.373  2005/03/21 11:59:09  lulin
// - new proc: _k2NullArrayProp.
//
// Revision 1.372  2005/03/21 11:12:01  lulin
// - new procs: _k2NullDef, k2NullType.
//
// Revision 1.371  2005/03/21 10:05:05  lulin
// - new interface: _Ik2Type.
//
// Revision 1.370  2005/03/21 06:45:01  lulin
// - убраны ненужные методы.
//
// Revision 1.369  2005/03/19 16:40:04  lulin
// - спрятаны ненужные методы.
//
// Revision 1.368  2005/03/18 17:23:28  lulin
// - более правильно получаем вложенный тег.
//
// Revision 1.367  2005/03/18 17:15:52  lulin
// - в методе записи тега итерируем дочерние теги через методы интерфейса, а не через какое-то заднее крыльцо.
//
// Revision 1.366  2005/03/18 16:11:33  lulin
// - remove method: Tk2AtomR._Write.
//
// Revision 1.365  2005/03/18 15:12:25  lulin
// - с интерфейса убран ненужный и непонятный метод.
//
// Revision 1.364  2005/03/18 15:00:20  lulin
// - new interface: Ik2TagGenerator.
//
// Revision 1.363  2005/03/18 14:36:25  lulin
// - функция заменена на свойство.
//
// Revision 1.362  2005/03/18 14:14:25  lulin
// - функция заменена на свойство.
//
// Revision 1.361  2005/03/18 13:18:22  lulin
// - bug fix: пересоздаем обертку вокруг дочернего тега - если типы отличаются.
//
// Revision 1.360  2005/03/18 12:59:56  lulin
// - метод _IndexOfChild распилен по нескольким разным объектам.
//
// Revision 1.359  2005/03/18 12:05:47  lulin
// - дочерние теги закешированы.
//
// Revision 1.358  2005/03/17 17:57:07  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.357  2005/03/17 11:33:59  lulin
// - bug fix: не компилировалось.
//
// Revision 1.356  2005/03/17 10:29:56  lulin
// - cleanup.
//
// Revision 1.355  2005/03/16 17:36:07  lulin
// - cleanup.
//
// Revision 1.354  2005/03/16 17:24:02  lulin
// - cleanup.
//
// Revision 1.353  2005/03/16 17:04:26  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.352  2005/03/16 16:05:13  lulin
// - bug fix: контроллируем, что описатель свойства правильный.
//
// Revision 1.351  2005/03/16 15:57:04  lulin
// - заготовка для Assert'ов.
//
// Revision 1.350  2005/03/16 14:07:10  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.349  2005/03/16 12:17:02  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.348  2005/03/16 10:20:26  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.347  2005/03/16 09:50:12  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.346  2005/03/16 09:20:39  lulin
// - переходим к _Ik2Tag.
//
// Revision 1.345  2005/03/16 08:20:05  lulin
// - декларация _Ik2Tag перенесена повыше.
//
// Revision 1.344  2005/03/15 16:09:22  lulin
// - cleanup.
//
// Revision 1.343  2005/03/15 11:18:23  lulin
// - cleanup.
//
// Revision 1.342  2005/03/15 10:30:28  lulin
// - от Tk2AtomR переходим к _Ik2Tag.
//
// Revision 1.341  2005/03/15 08:11:04  lulin
// - спрятаны ненужные методы.
//
// Revision 1.340  2005/03/15 08:01:41  lulin
// - выделен метод: Tk2ListTag.DoIterateChildren.
//
// Revision 1.339  2005/03/15 07:52:37  lulin
// - от Tk2AtomR переходим к _Ik2Tag.
//
// Revision 1.338  2005/03/11 16:26:47  lulin
// - от Tk2AtomR переходим к _Ik2Tag.
//
// Revision 1.337  2005/03/11 15:21:21  lulin
// - добавлен Assert.
//
// Revision 1.336  2005/03/11 15:15:12  lulin
// - bug fix: не изменялся тип наследования на прозрачный (CQ OIT5-12630).
//
// Revision 1.335  2005/03/10 11:35:17  lulin
// - от Tk2AtomR переходим к _Ik2Tag.
//
// Revision 1.334  2005/03/10 10:30:57  lulin
// - в Ik2Value._IsSame теперь передается Ik2Value, а не _Ik2Tag.
//
// Revision 1.333  2005/03/10 10:21:57  lulin
// - new prop: _Ik2Tag._Attr.
//
// Revision 1.332  2005/03/10 10:13:16  lulin
// - remove method: Tk2AtomR._SetSubAtom.
//
// Revision 1.331  2005/03/10 09:58:49  lulin
// - remove method: Tk2AtomR.DeleteChildren.
// - new method: _Ik2Tag.DeleteChildren.
//
// Revision 1.330  2005/03/10 09:32:20  lulin
// - optimization: избегаем цикла, при доступе к описанию атрибутов типа _Tk2Type.
//
// Revision 1.329  2005/03/10 09:16:03  lulin
// - optimization: избегаем цикла, при подсчете числа атрибутов типа _Tk2Type.
//
// Revision 1.328  2005/03/09 19:06:09  lulin
// - от Tk2AtomR переходим к _Ik2Tag.
//
// Revision 1.327  2005/03/09 18:50:28  lulin
// - от Tk2AtomR переходим к _Ik2Tag.
//
// Revision 1.326  2005/03/09 18:40:24  lulin
// - remove method: Tk2AtomR._DeleteChild.
// - new method: _Ik2Tag._DeleteChild.
//
// Revision 1.325  2005/03/09 17:29:09  lulin
// - от Tk2AtomR переходим к Ik2TagWrap.
//
// Revision 1.324  2005/03/09 17:11:55  lulin
// - remove method: Tk2AtomR._ChildAdded.
//
// Revision 1.323  2005/03/09 17:05:22  lulin
// - remove method: Tk2AtomR._InsertChild.
// - new method: _Ik2Tag._InsertChild.
//
// Revision 1.322  2005/03/09 15:43:14  lulin
// - remove method: Tk2AtomR._AssignCloneParams.
// - new class: Tk2TT - утилитные функции для работы с тегами (структурами документа) не инкапсулированные самими тегами (в частности туда перенесен метод _AssignCloneParams).
//
// Revision 1.321  2005/03/09 15:05:17  lulin
// - от Tk2AtomR переходим к Ik2TagWrap.
//
// Revision 1.320  2005/03/09 14:28:55  lulin
// - от Tk2AtomR переходим к Ik2TagWrap.
//
// Revision 1.319  2005/03/09 14:16:07  lulin
// - убран отладочный код.
//
// Revision 1.318  2005/03/09 13:47:16  lulin
// - bug fix: проеб со счетчиком ссылок на объекты внутри документа, в результате которого в частности "разъезжался" текст (CQ OIT5-12595).
//
// Revision 1.317  2005/03/09 12:10:54  lulin
// - от Tk2AtomR переходим к Ik2TagWrap.
//
// Revision 1.316  2005/03/05 11:27:58  lulin
// - bug fix: Abstract Method Call при вызове редактора стилей.
//
// Revision 1.315  2005/03/04 19:43:35  lulin
// - remove method: Tk2AtomR._Assign.
//
// Revision 1.314  2005/03/04 18:52:42  lulin
// - bug fix: после перехода на _MakeTag неправильно использовался метод _Assign.
//
// Revision 1.313  2005/03/04 16:43:18  lulin
// - remove method: Tk2AtomR.New.
//
// Revision 1.312  2005/03/04 15:49:10  lulin
// - спрятана процедура _Tk2Type.New.
//
// Revision 1.311  2005/03/04 14:15:56  lulin
// - удален ненужный тип.
//
// Revision 1.310  2005/03/04 14:14:28  lulin
// - спрятаны методы, которые не должны интересовать пользователя.
//
// Revision 1.309  2005/03/04 13:59:25  lulin
// - remove method: Tk2AtomR._AddChild.
//
// Revision 1.308  2005/02/22 12:50:30  lulin
// - new interface: _Ik2TagBoxContainer.
//
// Revision 1.307  2005/02/02 09:54:23  lulin
// - bug fix: не совсем корректно обрабатывались флаги записи тега - в результате не печатались параграфы preformatted.
//
// Revision 1.306  2005/01/24 11:43:20  lulin
// - new behavior: при освобождении заглушки очищаем указатель на нее.
//
// Revision 1.305  2004/11/17 11:30:33  lulin
// - new behavior: закрываем/открываем комментарий пользователя с клавиатуры.
//
// Revision 1.304  2004/11/16 11:25:01  lulin
// - bug fix: при переходе от классов к интерфейсам сломался маппинг свойств в таблице тегов - в результате свойства смапированныей например на стиль параграфа не очищались.
//
// Revision 1.303  2004/11/15 13:53:58  lulin
// - remove method: Tk2AtomR.AssignSubAtomEx.
// - new method: Tk2AtomR._AssignCloneParams.
//
// Revision 1.302  2004/11/15 13:40:48  lulin
// - теперь для типа параграфа можно определять ParamsForClone - список атрибутов, которые нужно присваивать при клонировании параграфа.
//
// Revision 1.301  2004/11/10 14:21:06  lulin
// - optimization: за счет выкидывания поддержки ненужного интерфейса уменьшаем размер каждого параграфа на 4 байта.
//
// Revision 1.300  2004/11/09 17:06:27  lulin
// - переходим от классов к интерфейсам.
//
// Revision 1.299  2004/11/09 15:36:03  lulin
// - bug fix: не компилировалось.
//
// Revision 1.298  2004/11/09 14:07:19  lulin
// - переходим от классов к интерфейсам.
//
// Revision 1.297  2004/11/09 13:37:59  lulin
// - переходим от классов к интерфейсам.
//
// Revision 1.296  2004/11/09 12:35:36  lulin
// - bug fix: не компилировалось.
//
// Revision 1.295  2004/11/09 12:23:06  lulin
// - переходим от классов к интерфейсам.
//
// Revision 1.294  2004/11/09 11:07:32  lulin
// - new interfaces: _Ik2Property, _Ik2ArrayProperty.
//
// Revision 1.293  2004/11/05 16:32:05  lulin
// - cleanup.
//
// Revision 1.292  2004/11/05 16:10:01  lulin
// - cleanup.
//
// Revision 1.291  2004/11/04 17:43:46  lulin
// - new interface: _Ik2TypeTable.
//
// Revision 1.290  2004/11/02 14:52:14  lulin
// - new behavior: не пытаемся присваивать _ReadOnly-свойства.
//
// Revision 1.289  2004/10/29 15:33:05  lulin
// - new behavior: уменьшаем диапазон форматируемых строк внутри таблиц с ячейчами, объединенными по-вертикали.
//
// Revision 1.288  2004/10/29 13:05:24  lulin
// - new methods: Tk2AtomR._IterateChildrenBack(_F).
//
// Revision 1.287  2004/10/12 13:28:10  lulin
// - bug fix: отъехала прозрачность стилей сегментов.
//
// Revision 1.286  2004/10/11 08:14:29  lulin
// - new class: TevDocumentsCache.
//
// Revision 1.285  2004/10/06 15:23:09  lulin
// - bug fix: из клипборда текст вставлялся не как комментарии (CQ OIT5-10087).
//
// Revision 1.284  2004/09/28 17:22:11  lulin
// - в первом приближении сделал кеш документов. Пока без вымещения покументов на диск.
//
// Revision 1.283  2004/09/27 10:59:13  lulin
// - вместо AV выкидываем исключение о ненайденном свойстве.
//
// Revision 1.282  2004/09/21 12:04:25  lulin
// - Release заменил на Cleanup.
//
// Revision 1.281  2004/07/12 13:10:56  law
// - bug fix: был Range Check при доступе к _ReadOnly свойствам.
//
// Revision 1.280  2004/07/09 09:18:12  law
// - bug fix: неправильно переформатировались параграфы при включенном фоновом форматировании.
//
// Revision 1.279  2004/07/07 13:26:29  law
// - optimiztaion: _Tk2Type._GetPropByOffset - стараемся обходится без итератора.
//
// Revision 1.278  2004/07/05 14:55:57  law
// - optimization.
//
// Revision 1.277  2004/07/05 14:45:48  law
// - new interface: Ik2Value.
//
// Revision 1.276  2004/07/05 14:22:03  law
// - remove class: Tk2StructObjectTag.
//
// Revision 1.275  2004/07/05 14:07:53  law
// - укорочены имена методов.
//
// Revision 1.274  2004/07/05 13:46:32  law
// - new method: _Ik2Tag.rBoolAtom.
//
// Revision 1.273  2004/07/05 13:01:44  law
// - bug fix.
//
// Revision 1.272  2004/07/05 12:50:37  law
// - bug fix.
//
// Revision 1.271  2004/07/05 12:35:08  law
// - вернул старые названия методов _rAtom и wAtom.
//
// Revision 1.270  2004/07/05 11:21:12  law
// - bug fix.
//
// Revision 1.269  2004/07/05 10:17:03  law
// no message
//
// Revision 1.268  2004/07/02 15:19:23  law
// - замена Tk2AtomR -> _Ik2Tag.
//
// Revision 1.267  2004/07/02 13:13:15  law
// - оптимизирована работа тегами.
//
// Revision 1.266  2004/07/02 12:21:11  law
// - оптимизирована работа тегами.
//
// Revision 1.265  2004/07/02 10:57:51  law
// - замена Tk2AtomR -> _Ik2Tag.
//
// Revision 1.264  2004/07/02 10:21:10  law
// - вставлен Assert.
//
// Revision 1.263  2004/07/02 10:17:01  law
// - оптимизирован перебор детей.
//
// Revision 1.262  2004/07/01 17:41:51  law
// - new behavior: Formatter'ы переведены с Tk2AtomR на _Ik2Tag.
//
// Revision 1.261  2004/07/01 16:29:30  law
// - bug fix.
//
// Revision 1.260  2004/07/01 16:24:48  law
// - bug fix.
//
// Revision 1.259  2004/07/01 16:15:22  law
// - bug fix.
//
// Revision 1.258  2004/07/01 16:06:03  law
// - оптимизированы _pm_GetChild и _pm_GetChildrenCount.
//
// Revision 1.257  2004/07/01 15:34:35  law
// - new methods: _Ik2Tag._IterateChildren, _IterateChildrenF.
//
// Revision 1.256  2004/07/01 15:05:25  law
// - new class: Tk2ListTag.
//
// Revision 1.255  2004/07/01 14:59:41  law
// - new prop: _Ik2Tag.ChildrenCount.
//
// Revision 1.254  2004/07/01 14:31:19  law
// - new method: _Tk2ObjectTag._SetSubAtom.
//
// Revision 1.253  2004/07/01 13:58:21  law
// - new method: _Ik2Tag.wAtom.
//
// Revision 1.252  2004/07/01 10:21:04  law
// - new method: _Ik2Tag._AddChild.
//
// Revision 1.251  2004/06/30 15:57:03  law
// - new prop: _Ik2Tag.Child.
//
// Revision 1.250  2004/06/30 15:40:55  law
// - cleanup.
//
// Revision 1.249  2004/06/30 15:36:11  law
// - new method version: _Ik2Tag.rAttr.
//
// Revision 1.248  2004/06/30 14:49:25  law
// - new method: _Ik2Tag.rAttr.
//
// Revision 1.247  2004/06/30 14:23:05  law
// - new methods: _Ik2Tag.AsLong, AsString.
//
// Revision 1.246  2004/06/30 14:00:18  law
// - перетасованы реализации методов.
//
// Revision 1.245  2004/06/30 13:52:43  law
// - new method: _Tk2ValuedTag.GetValue.
//
// Revision 1.244  2004/06/30 13:34:54  law
// - bug fix: _Tk2TransparentTag._IsSame не учитывала _f_Type.
//
// Revision 1.243  2004/06/30 13:32:47  law
// - реализация метода _IsSame перенесена на _Tk2ValuedTag.
//
// Revision 1.242  2004/06/30 13:25:59  law
// - класс _Tk2TagBase теперь не поддерживает непосредственно Ik2TagBox, а только _Ik2Tag.
//
// Revision 1.241  2004/06/30 13:09:36  law
// - new class: Tk2StructObjectTag.
//
// Revision 1.240  2004/06/30 12:53:17  law
// - new class: _Tk2TypedTag.
//
// Revision 1.239  2004/06/30 12:48:43  law
// - new class: _Tk2ValuedTag.
//
// Revision 1.238  2004/06/30 12:33:15  law
// - изменены сигнатуры методов.
//
// Revision 1.237  2004/06/30 12:14:59  law
// - bug fix: бесконечная рекурсия в Tk2*Tag.COMQueryInterface.
//
// Revision 1.236  2004/06/30 10:48:45  law
// - изменен тип параметра Parent у методов IevVisualShapedTag._ParentToClient, _ClientToParent с IUnknown на _Ik2Tag.
//
// Revision 1.235  2004/06/30 09:35:23  law
// - new class: _Tk2IUnknownTag.
//
// Revision 1.234  2004/06/30 09:30:10  law
// - new class: _Tk2StringTag.
//
// Revision 1.233  2004/06/30 09:13:39  law
// - new method: _Ik2Tag._IsOrd.
//
// Revision 1.232  2004/06/30 09:09:29  law
// - new class: _Tk2TransparentTag.
//
// Revision 1.231  2004/06/30 08:15:23  law
// - new behavior: транслируем запрос интерфейса от _Tk2Tag к Ik2TagWrap.
//
// Revision 1.230  2004/06/30 08:01:28  law
// - new class: _Tk2TagBase.
//
// Revision 1.229  2004/06/29 17:01:13  law
// - new class: _Tk2ObjectTag.
//
// Revision 1.228  2004/06/29 16:44:26  law
// - new class: _Tk2OrdTag.
//
// Revision 1.227  2004/06/29 16:29:30  law
// - new method: _Ik2Tag._IsSame.
//
// Revision 1.226  2004/06/29 16:22:29  law
// - new method: _Ik2Tag.Owner.
//
// Revision 1.225  2004/06/29 16:01:37  law
// - bug fix: зацикливание в получении документа в evNode.
//
// Revision 1.224  2004/06/29 15:47:07  law
// - new methods: _Ik2Tag._IsNull, IsValid.
//
// Revision 1.223  2004/06/29 15:36:21  law
// - new method: _Ik2Tag._Clone.
//
// Revision 1.222  2004/06/29 15:13:46  law
// - new interface: _Ik2Tag.
//
// Revision 1.221  2004/06/29 14:58:13  law
// - new interface: Ik2TagBox.
//
// Revision 1.220  2004/06/29 14:26:52  law
// - избавляемся от метода Tk2AtomR._Set.
//
// Revision 1.219  2004/06/28 16:22:41  law
// - подоптимизирована _IsNull.
//
// Revision 1.217  2004/06/28 13:46:36  law
// - remove unit: k2IntfStub.
//
// Revision 1.216  2004/06/28 13:42:07  law
// - remove proc: k2MakeInterface.
//
// Revision 1.215  2004/06/28 13:34:49  law
// - remove class: Il3Pointer.
//
// Revision 1.214  2004/06/28 12:06:17  law
// - remove class: Il3Unknown.
//
// Revision 1.213  2004/06/25 10:53:21  law
// - optimization.
//
// Revision 1.212  2004/06/25 07:23:42  law
// - optimization.
//
// Revision 1.211  2004/06/23 16:22:39  law
// - оптимизирован доступ к дочерним тегам.
//
// Revision 1.210  2004/06/18 16:28:09  law
// - Tk2AtomR.QueryInterface оптимизирована по скорости.
//
// Revision 1.209  2004/06/17 15:58:59  law
// - свойство Empty переместилось с класса _Tl3Base на класс _Tl3SomeDataContainer.
//
// Revision 1.208  2004/06/17 13:57:48  law
// - bug fix: курсоры не владели параграфами - соответственно были потенциальные ошибки, когда параграфы умирали, а курсоры нет.
// - bug fix: в результате переделок механизма поиска перестал работать поиск в выборке.
//
// Revision 1.207  2004/06/10 16:26:39  law
// - продолжаем оптимизировать загрузку документа кусками.
//
// Revision 1.206  2004/06/10 11:03:22  law
// - свойство _Tl3CustomString.Len сделано статическим.
//
// Revision 1.205  2004/06/08 10:28:09  law
// - change: сделана возможность присваивать теги не целиком, а только то, что "приехало" (для догрузки параграфов).
//
// Revision 1.204  2004/06/04 15:51:55  law
// - интерфейс _Il3StringList сделан наследником от _Il3List.
//
// Revision 1.203  2004/06/04 14:49:44  law
// - new param: theIndex: PLong = nil, в методах Tk2AtomR._rAtom и Tk2AtomR._cAtomEx.
//
// Revision 1.202  2004/06/04 09:25:40  narry
// - bug fix
//
// Revision 1.201  2004/06/03 17:15:47  law
// - new interface: Ik2Base.
//
// Revision 1.200  2004/06/03 15:59:54  law
// - убрал прямое обращение к _Tl3PVList (т.к. для оптимизации предполагается, что в теле документа не всегда он может хранится).
//
// Revision 1.199  2004/06/03 14:59:40  law
// - убрал прямое обращение к _Tl3PVList (т.к. для оптимизации предполагается, что в теле документа не всегда он может хранится).
//
// Revision 1.198  2004/06/03 12:42:42  law
// - new interface: _Il3PointerList.
//
// Revision 1.197  2004/06/03 11:00:45  law
// - используем _Il3List и _Il3ListIterator вместо _Tl3PVList.
//
// Revision 1.196  2004/06/03 09:53:50  law
// - начал использовать _Il3ListIterator вместо _Tl3PVList.
//
// Revision 1.195  2004/06/02 08:30:27  law
// - удален конструктор Tl3VList.MakePersistentSorted - пользуйтесь _Tl3ObjectRefList.MakeSorted.
//
// Revision 1.194  2004/06/01 16:51:27  law
// - удален конструктор Tl3VList.MakePersistent - пользуйтесь _Tl3ObjectRefList.
//
// Revision 1.193  2004/05/31 11:44:36  law
// - new class: _Tl3PVList - список с виртуальными методами распределения/освобождения памяти.
//
// Revision 1.192  2004/05/25 13:08:52  law
// - change: Tk2AtomR.ArrayProp - теперь property, а не функция.
// - bug fix: при вставке из буфера вставлялись "левые" элементы оглавления.
//
// Revision 1.191  2004/05/14 14:49:04  law
// - исправлены префиксы у констант.
//
// Revision 1.190  2004/05/14 14:08:57  law
// - change: TevVariant переименован в Tk2Variant и переехал в k2Types.
//
// Revision 1.189  2004/05/07 12:21:05  law
// - bug fix: при наследовании не сохранялась сортировка тегов.
//
// Revision 1.188  2004/04/12 13:29:32  law
// - new: добавлен тип документов "словарная статья", их свойство ShortName теперь представляется не строкой, а массивом строк.
//
// Revision 1.187  2004/04/09 11:06:27  law
// - new class: Tl3CVList.
//
// Revision 1.186  2004/03/24 16:50:00  law
// - new behavior: сделана возможность иметь дубликаты в сортированном списке тегов.
// - new behavior: списку ActiveIntervals у документа разрешено иметь дубликаты.
//
// Revision 1.185  2004/03/03 18:04:02  law
// - rename unit: l3Tree2 -> l3Tree.
//
// Revision 1.184  2004/02/27 12:50:58  law
// - bug fix: опять-таки пропадали "синие человечки".
//
// Revision 1.183  2003/12/11 16:26:52  law
// - rename: все упоминания ChildsCount переименованы в AllChildrenCount.
//
// Revision 1.182  2003/11/11 12:35:23  law
// - new behavior: защитил редактор/TextSource от "переходных" процессов.
//
// Revision 1.181  2003/11/10 16:18:38  law
// - cleanup.
//
// Revision 1.180  2003/10/17 12:03:55  law
// - change: часть функций заменены на свойства (property).
//
// Revision 1.179  2003/10/09 15:24:58  law
// - new behavior: оптимизирован процесс форматирования.
//
// Revision 1.178  2003/09/23 08:37:59  law
// - new prop: IevHyperlink.Hint.
// - rename proc: ev_plAssignNil -> l3AssignNil.
//
// Revision 1.177  2003/07/07 12:30:13  demon
// - bug fix: была странная ситуация - когда документ пустой и его просили очиститься, то он поднимал Exception - EListError.
//
// Revision 1.176  2003/05/16 15:42:29  law
// - bug fix: невозможно было добавить непосредственно к текстовому параграфу сегмент типа k2_idTextSegment.
//
// Revision 1.175  2003/05/14 13:17:14  law
// - change _format: текстовому параграфу добавлен массив позиций табуляции.
//
// Revision 1.174  2003/05/12 09:20:23  law
// - rename proc: ev_plIsNil -> l3IsNil.
//
// Revision 1.173  2003/03/31 12:53:20  voba
// no message
//
// Revision 1.172  2003/03/06 09:38:52  law
// - bug fix.
//
// Revision 1.171  2003/03/06 09:23:29  law
// - new behavior: добавлена возможность описывать пользовательские имена атомов тегов.
//
// Revision 1.170  2003/03/06 08:54:49  law
// - new behavior: добавлена возможность описывать пользовательские имена типов тегов.
//
// Revision 1.169  2003/03/06 08:35:40  law
// - rename method: MultiInheriteType -> _InheriteType.
//
// Revision 1.168  2003/03/05 09:56:29  law
// - new method: _Tk2TypeTable._IterateTypesF.
//
// Revision 1.167  2003/03/05 09:29:28  law
// - new method: _Tk2Type._IteratePropertiesF.
//
// Revision 1.166  2003/02/10 16:06:20  law
// - cleanup: удалена процедура l3NodeActionL2FA - надо вместо нее использовать l3L2NA.
//
// Revision 1.165  2003/02/03 13:56:47  law
// - new behavior: сделана возможность определять массивы тегов, изменение которых взводило бы флаг Modified.
//
// Revision 1.164  2003/02/03 13:31:42  law
// - bug fix: не взводим флаг Modified в режиме IOProcess.
//
// Revision 1.163  2003/02/03 12:49:56  law
// - new behavior: сделана возможность определять теги, изменение которых взводило бы флаг Modified.
//
// Revision 1.162  2002/12/26 15:11:34  law
// - new dll: собрана более легкая версия dll-печати.
//
// Revision 1.161  2002/12/26 14:35:25  law
// - new dll: собрана более легкая версия dll-печати.
//
// Revision 1.160  2002/12/17 12:20:44  law
// - new unit: k2Unknown.
//
// Revision 1.159  2002/12/17 10:32:59  law
// - cleanup.
//
// Revision 1.158  2002/12/15 13:38:08  law
// - new behaivor: вчерновую прикрутил рисование формул.
//
// Revision 1.157  2002/11/29 16:33:38  law
// - new behavior: сделана синхронизация меток с деревом.
//
// Revision 1.156  2002/11/19 15:32:47  law
// - rename method: Tk2AtomR._rAtom -> _rAtom.
//
// Revision 1.155  2002/11/19 15:09:11  law
// - new behavior: обрабатываем параметр AssignTransparent.
//
// Revision 1.154  2002/11/19 13:52:41  law
// - change: Tk2AtomR._Assign - теперь функция.
//
// Revision 1.153  2002/11/11 11:29:39  law
// - bug fix: к текстовому параграфу не добавлялись гиперссылки.
//
// Revision 1.152  2002/11/05 17:13:09  law
// - cleanup.
//
// Revision 1.151  2002/11/01 18:49:55  law
// - new prop: _Tk2ChildrenProperty._OnValidateChild.
//
// Revision 1.150  2002/09/23 12:18:20  law
// - new prop: _Tk2ChildrenProperty._DefaultChildType.
//
// Revision 1.149  2002/09/19 14:08:53  law
// - new method: _Tk2Type._QueryTool.
// - comments.
//
// Revision 1.148  2002/09/18 07:08:03  law
// - new units: k2StackGenerator, _k2Ver.
// - new behavior: Tk2CustomReader теперь наследуется от Tk2CustomStackGenerator и соответственно наследует его поведение.
//
// Revision 1.147  2002/09/09 13:25:06  law
// - cleanup.
//
// Revision 1.146  2002/07/12 12:38:23  law
// - new method version: _InheritsFrom.
//
// Revision 1.145  2002/07/10 11:24:52  law
// - rename method: _HasSubAtom -> _HasSubAtom.
//
// Revision 1.144  2002/07/08 15:37:42  law
// - new behavior: не записываем несохраняемые дочерние теги.
//
// Revision 1.143  2002/07/08 12:09:57  law
// - default param: Context.
//
// Revision 1.142  2002/01/29 16:18:49  law
// - bug fix: Range Check Error при записывании размера маски.
//
// Revision 1.141  2002/01/08 07:58:02  law
// - cleanup.
//
// Revision 1.140  2001/12/27 15:32:25  law
// - rename proc: l3GetStrLen -> l3StrLen.
//
// Revision 1.139  2001/12/27 15:03:31  law
// - new constructors: добавлены два конструктора _Tl3String._Make.
//
// Revision 1.138  2001/09/28 12:24:48  narry
// - bug fix: AV после выхода после поиска по листу.
//
// Revision 1.137  2001/09/25 08:04:00  law
// - comments: xHelpGen.
//
// Revision 1.136  2001/09/21 09:58:55  law
// - cleanup.
//
// Revision 1.135  2001/08/31 08:50:07  law
// - cleanup: первые шаги к кроссплатформенности.
//
// Revision 1.134  2001/08/31 07:16:23  law
// - cleanup: убраны ненужные ссылки на Windows.
//
// Revision 1.133  2001/08/30 16:34:22  law
// - new version: портировал на Delphi 6.
//
// Revision 1.132  2001/08/29 08:53:39  law
// - comments: xHelpGen.
//
// Revision 1.131  2001/08/28 08:50:37  law
// - comments: xHelpGen.
//
// Revision 1.130  2001/08/02 11:43:19  law
// - cleanup & comments.
//
// Revision 1.129  2001/07/17 14:59:02  law
// - bug fix: в соответствии с задачей №722.
//
// Revision 1.128  2001/06/05 15:13:21  law
// - new method: IevDocumentPart.Merge.
//
// Revision 1.127  2001/05/31 08:04:56  law
// - cleanup: убрана запись компонент.
//
// Revision 1.126  2001/04/18 13:25:23  law
// - comments: добавлены комментарии для xHelpGen.
//
// Revision 1.125  2001/04/16 14:42:35  law
// - bug fix: попытка вызова Tk2AtomR_rAtom при (IsValid <> true) приводила к AV.
//
// Revision 1.124  2001/04/09 10:11:16  law
// - new behavior: оптимизирован алгоритм изменения флага переформатирования параграфа.
//
// Revision 1.123  2001/03/21 12:23:24  law
// - bug fix: AV получении атома у пустого тега.
//
// Revision 1.122  2001/03/15 14:52:23  law
// - cleaning & coments.
//
// Revision 1.121  2001/03/13 18:44:34  law
// - some cleaning, tuning & comments.
//
// Revision 1.120  2001/03/11 10:25:17  law
// - процедура ListError переименована в _k2ListError и объявлена в интерфейсной секции.
//
// Revision 1.119  2001/03/05 14:08:18  law
// - поменялся порядок у методов _IterateChildren...
//
// Revision 1.118  2001/02/28 17:50:26  law
// - изменены параметры метода AssignSubAtomEx.
//
// Revision 1.117  2001/02/28 16:30:01  law
// - отсечение пересекающихся сегментов.
//
// Revision 1.116  2001/02/28 13:15:02  law
// - расширен интерфейс Ik2PropertyBag.
//
// Revision 1.115  2001/02/28 10:12:40  law
// - процедуры _Write и WriteEx объединены в одну - _Write.
//
// Revision 1.114  2001/02/20 10:23:52  law
// - some tuning
//
// Revision 1.113  2001/01/31 10:37:31  law
// - оптимизировано использование QueryInterface.
//
// Revision 1.112  2001/01/04 14:58:51  voba
// - bug fix: установка стиля по умолчанию.
//
// Revision 1.111  2000/12/19 12:53:09  law
// - удалены ненужные ссылки на k2Context.
//
// Revision 1.110  2000/12/15 15:18:58  law
// - вставлены директивы Log.
//

{$Include k2Define.inc }

interface

uses
  TypInfo,
  Classes,

  l3Types,
  l3Struct,
  l3IID,
  l3Msg,
  l3CBase,
  l3Base,
  l3Interfaces,
  l3InternalInterfaces,
  l3Const,
  l3BitArr,
  l3Dict,
  l3Tree_TLB,
  l3ProtoObject,
  l3CacheableBase,
  l3PrimString,
  l3DataContainerWithoutIUnknown,
  l3DataContainerWithoutIUnknownList,
  l3SimpleObject,

  k2BaseTypes,
  k2Types,
  k2Tags,
  k2Except,
  k2Interfaces,
  k2ChildrenPathList,
  k2Prim,
  k2BaseStruct,
  k2TypeModelPart,

  k2AtomWrapPrim
  ;

type
  Tk2Type = class;
  Pk2Type = ^Tk2Type;

  Rk2InterfaceFactory = class of Tk2InterfaceFactory;

  Tk2CustomProperty = class;

  Wk2Atom = class(Tk2AtomWrapPrim, Ik2Listner)
   {* Инструмент для реализации операций с тегами. }
    protected
    // internal fields
      AtomType : Tk2Type;
    protected
    // interface methods
      // Ik2Listner
      procedure Fire(const anEvent : Tk2Event;
                     const anOp    : Ik2Op);
        {* - сообщение о том, что что-то произошло. }
      procedure DoFire(const anEvent : Tk2Event;
                       const anOp    : Ik2Op);
        virtual;
        {* - сообщение о том, что что-то произошло. }
    public
    // public methods
      constructor Create;
        {-}
      function  New(aType: Tk2Type): Ik2Tag;
        virtual;
        {-создает атом данного типа}
      function  PreGetAtomData(const AE : Ik2Tag;
                               aProp    : Tk2CustomProperty;
                               out Data : Long): Bool;
        virtual;
        {-}
      function  GetAtomData(const AE : Ik2Tag;
                            aProp    : Tk2CustomProperty;
                            out Data : Long): Bool;
        virtual;
        {-}
      function  AsLong(const A: Ik2Tag): Long;
        virtual;
        {-}
      function  AsString(const A: Ik2Tag): AnsiString;
        virtual;
        {-}
      function  AsBool(const A: Ik2Tag): Bool;
        virtual;
        {-}
      function  IntToTag(aValue: Long): Ik2Tag;
        virtual;
        {-}
      function  BoolToTag(Value: Bool): Ik2Tag;
        virtual;
        {-}
      function  StrToTag(const aValue: AnsiString): Ik2Tag;
        virtual;
        {-}
      function  ObjToTag(aValue: TObject): Ik2Tag;
        virtual;
        {-}
      procedure ForceStore(const aTag : Ik2Tag);
        virtual;
        {-}
      function  MarkModified(const aTag : Ik2Tag): Boolean;
        virtual;
        {-}
      procedure Cleanup;
        override;
        {-}
  end;//Wk2Atom
  Rk2Atom = class of Wk2Atom;

  Tk2BeforeChangePropProc = function(const V       : Tk2Values;
                                     const aProp   : Tk2CustomProperty;
                                     const Context : Ik2Op): Bool;
  Tk2AfterChangePropProc = procedure(const V       : Tk2Values;
                                     const aProp   : Tk2CustomProperty;
                                     const Context : Ik2Op);
  Tk2StoredPropProc = function(const P       : Ik2Tag;
                               const Value   : Ik2Tag;
                               const aProp   : Tk2CustomProperty;
                               const Context : Ik2Op): Bool;
  Tk2StoredChildProc = function(const P       : Ik2Tag;
                                const Child   : Ik2Tag;
                                const aProp   : Tk2CustomProperty;
                                const Context : Ik2Op): Bool;
  Tk2GetChildTypeForParentProc = procedure(const aParent : Ik2Tag;
                                            var theType  : Tk2Type);
  Tk2ValidateChildProc = procedure(const aParent : Ik2Tag;
                                   var aChild    : Ik2Tag;
                                   var aValid    : Boolean);

  Ek2ParamNotDefined = class(Ek2Warning);

  Tk2ToolPrim = class;

  Tk2InterfaceList = packed object
    private
    // internal fields
      f_I : Tl3ObjectHash;
    public
    // public methods
      function SetItem(const ID: Tl3IID; Item: Tl3SimpleObject): PObject;
        {-}
      function GetItemP(const ID: Tl3IID): PObject;
        {-}
      function GetItem(const ID: Tl3IID): Tl3SimpleObject;
        {-}
      procedure Clear;
        {-}
  end;//Tk2InterfaceList

  Tk2ToolPrim = class(Tl3CBase)
    protected
    // internal methods
      procedure SetTag(const aTag: Ik2Tag);
       {-}
      procedure DoSetTag(const aTag: Ik2Tag);
       virtual;
       abstract;
      class function StoreToOldCache: Boolean;
        virtual;
        {-}
      class function IsCacheable: Bool;
        override;
        {-}
      procedure AfterFree;
        override;
        {-}
      procedure SetTagQT(const aTag: Ik2Tag);
        virtual;
        abstract;
        {-}
  end;//Tk2ToolPrim

  Tk2InterfaceCache = packed object(Tk2InterfaceList)
    public
    {public methods}
      function  GetInterface(const ID: Tl3IID): Tk2ToolPrim;
        {-}
      procedure SetInterface(const ID: Tl3IID; Item: Tk2ToolPrim);
        {-}
      procedure IterateInterfaces(const ID: Tl3IID; Action: Tl3IteratorAction);
        {-}
  end;//Tk2InterfaceCache

  Tk2InterfaceFactory = class(Tl3SimpleObject, Ik2InterfaceFactory)
   {* Фабрика "старых" интерфейсов. Для поддержки старого кода, без настоящих интерфейсов. }
    private
    // internal fields
      f_Interfaces : Tk2InterfaceCache;
    protected
    // internal methods
      procedure Cleanup;
        override;
        {-}
    public
    // public methods
      function  LoadTool(const ID: Tl3IID): Tk2ToolPrim;
        {* - загрузить инструмент. }
      function  StoreTool(const ID: Tl3IID; I: Tk2ToolPrim): Bool;
        {* - сохранить инструмент. }
      function  QueryTool(const aTag : Ik2Tag;
                          const ID   : Tl3IID;
                          out I      : Tk2ToolPrim): Bool;
        virtual;
        {* - запросить новый инструмент. }
      procedure IterateCursors(Action: Ik2InterfaceFactory_IterateCursors_Action);
        {-}
      procedure IterateCursorsF(Action: Ik2InterfaceFactory_IterateCursors_Action);
        {-}
    public
    // public properties
      property Interfaces: Tk2InterfaceCache
        read f_Interfaces;
        {-}
  end;//Tk2InterfaceFactory

  Tk2Base = k2Prim.Tk2Base;

  Tk2CustomPropertyPrim = k2Prim.Tk2CustomPropertyPrim;

  Tk2CustomProperty = class(Tk2CustomPropertyPrim)
   {* Базовый класс для описания свойства тега. }
    protected
      f_Weight       : Long;
      {$IfDef k2NeedUserInfo}
      f_UserName     : AnsiString;
      {$EndIf k2NeedUserInfo}
    protected
      f_BeforeChange : Tk2BeforeChangePropProc;
      f_AfterChange  : Tk2AfterChangePropProc;
      f_Stored       : Long;
    protected
    // property methods
      function  GetIsProp: Boolean;
        override;
        {-}
      function pm_GetTagType: Tk2TypePrim;
        override;
        {-}
      function  pm_GetEmptyMapping: Long;
        override;
      procedure pm_SetEmptyMapping(Value: Long);
        virtual;
        {-}
      procedure pm_SetStoredProc(Value: Tk2StoredPropProc);
        {-}
      procedure pm_SetStored(Value: Boolean);
        {-}
      function  pm_GetDefaultValue: Long;
        override;
        {-}
      function  pm_GetReadOnly: Bool;
        override;
      procedure pm_SetReadOnly(Value: Bool);
        virtual;
        {-}
      procedure pm_SetTagIndex(Value: Long);
        {-}
      function  pm_GetOrderKey: Tl3OrderKey;
      procedure pm_SetOrderKey(const Value: Tl3OrderKey);
        {-}
      function  pm_GetIsArray: Bool;
        virtual;
        {-}
      function  pm_GetMappingTarget: Long;
        override;
      procedure pm_SetMappingTarget(aValue: Long);
        virtual;
        {-}
    protected
    // internal methods
    public
    // public methods
      constructor Create(aParentType     : Tk2Type;
                         anID            : Integer;
                         const aUserName : AnsiString);
        reintroduce;
        {* - создает описатель свойства. }
      function Clone(aParentType: Tk2Type): Pointer;
        {* Создайт копию свойства. }
      procedure AssignString(P: Tl3PrimString);
        override;
        {-}
      function  IsThisArray(out theProp: Tk2ArrayPropertyPrim): Boolean;
        virtual;
        {-}
      function  DoBeforeChange(var V         : Tk2Values;
                               const Context : Ik2Op): Bool;
        {-}
      procedure DoAfterChange(var V         : Tk2Values;
                              const Context : Ik2Op);
        {-}
      function  GetStored(const P       : Ik2Tag;
                          const Value   : Ik2Tag;
                          const Context : Ik2Op): Bool;
        {-}
      procedure pm_SetDefaultValue(Value: Long);
        virtual;
        {-}
    public
    // public properties
      property EmptyMapping: Long
        read pm_GetEmptyMapping
        write pm_SetEmptyMapping;
        {-}
      property DefaultValue: Long
        read pm_GetDefaultValue
        write pm_SetDefaultValue;
        {* - значение по умолчанию. }
      property OrderKey: Tl3OrderKey
        read pm_GetOrderKey
        write pm_SetOrderKey;
        {-}
      property IsArray: Bool
        read pm_GetIsArray;
        {* - скалярное или векторное свойство? }
      {$IfDef k2NeedUserInfo}
      property UserName: AnsiString
        read f_UserName;
        {* - название свойства для пользователя. }
      {$EndIf k2NeedUserInfo}
      property MappingTarget: Long
        read pm_GetMappingTarget
        write pm_SetMappingTarget;
        {-}
    public
    // public procedures
      property BeforeChange: Tk2BeforeChangePropProc
        read f_BeforeChange
        write f_BeforeChange;
        {-}
      property AfterChange: Tk2AfterChangePropProc
        read f_AfterChange
        write f_AfterChange;
        {-}
      property StoredProc: Tk2StoredPropProc
        write pm_SetStoredProc;
        {-}
      property Stored: Boolean
        write pm_SetStored;
        {-}
      property ReadOnly: Bool
        read pm_GetReadOnly
        write pm_SetReadOnly;
        {* - "только для чтения"? }
  end;//Tk2CustomProperty
  Pk2CustomProperty = ^Tk2CustomProperty;
  Tk2Prop = Tk2CustomProperty;

  Tk2Property = class(Tk2CustomProperty)
   {* Описание свойства тега. }
    private
    // property fields
      f_EmptyMapping  : Long;
      f_DefaultValue  : Long;
      f_MappingTarget : Long;
      f_ReadOnly      : Bool;
    protected
    // property methods
      function  pm_GetEmptyMapping: Long;
        override;
      procedure pm_SetEmptyMapping(Value: Long);
        override;
        {-}
      function  pm_GetReadOnly: Bool;
        override;
      procedure pm_SetReadOnly(Value: Bool);
        override;
        {-}
      function  pm_GetDefaultValue: Long;
        override;
        {-}
      function  pm_GetMappingTarget: Long;
        override;
        {-}
      procedure pm_SetMappingTarget(aValue: Long);
        override;
        {-}
      procedure InitFields;
        override;
        {-}
    public
    // public methods
      constructor Create(aParentType     : Tk2Type;
                         anID            : Integer;
                         anAtomType      : Tk2Type;
                         const aUserName : AnsiString);
        reintroduce;
        {-}
      procedure pm_SetDefaultValue(Value: Long);
        override;
        {-}
  end;//Tk2Property

  Tk2ChildrenProperty = class(Tk2CustomProperty)
    private
    // property fields
      f_ChildType               : Tk2Type;
      f_DefaultChildType        : Tk2Type;
      f_StoredChild             : Long;
      f_SortIndex               : Long;
      f_Duplicates              : Tl3Duplicates;
      f_OnValidateChild         : Tk2ValidateChildProc;
      f_OnGetChildTypeForParent : Tk2GetChildTypeForParentProc;
      f_MaxChildrenCount        : Integer;
    protected
    // property methods
      procedure pm_SetChildType(Value: Tk2Type);
        {-}
      procedure pm_SetDefaultChildType(Value: Tk2Type);
        {-}
      function  pm_GetStoredChildProc: Tk2StoredChildProc;
      procedure pm_SetStoredChildProc(Value: Tk2StoredChildProc);
        {-}
      function  pm_GetIsArray: Bool;
        override;
        {-}
    protected
    // internal methods
      procedure Cleanup;
        override;
        {-}
    public
    // public methods
      constructor Create(aParentType     : Tk2Type;
                         aChildType      : Tk2Type;
                         aAtomType       : Tk2Type;
                         const aUserName : AnsiString);
        reintroduce;
        {-}
      procedure DoAfterChildAdded(const anAtom   : Ik2Tag;
                                  const aChild   : Ik2Tag;
                                  const anOpPack : Ik2Op;
                                  anIndex        : Long;
                                  aTotal         : Integer);
        {-}
      function  IsThisArray(out theProp: Tk2ArrayPropertyPrim): Boolean;
        override;
        {-}
      function  ValidateChild(const aParent : Ik2Tag;
                              var aChild    : Ik2Tag;
                              const Context : Ik2Op;
                              anIndex       : Integer): Bool;
        {-}
      procedure AssignString(P: Tl3PrimString);
        override;
        {-}
(*      function  DeleteChild(const aParent : Ik2Tag;
                            Index         : Long;
                            const anAtom  : Ik2Tag;
                            const Context : Ik2Op): Boolean;
        {-}*)
      function  GetStoredChild(const P       : Ik2Tag;
                               const Value   : Ik2Tag;
                               const Context : Ik2Op): Bool;
        {-}
      function  GetChildTypeForParent(const aList: Ik2Tag): Tk2Type;
        {-}
      procedure SetSortTags(const aTag : array of Integer);
        {-}
    public
    // public properties
      property MaxChildrenCount: Integer
        read f_MaxChildrenCount
        write f_MaxChildrenCount;
        {-}
      property ChildType: Tk2Type
        read f_ChildType
        write pm_SetChildType;
        {-}
      property DefaultChildType: Tk2Type
        read f_DefaultChildType
        write pm_SetDefaultChildType;
        {-}
      property StoredChild: Long
        read f_StoredChild
        write f_StoredChild;
        {-}
      property StoredChildProc: Tk2StoredChildProc
        read pm_GetStoredChildProc
        write pm_SetStoredChildProc;
        {-}
      property SortIndex: Long
        read f_SortIndex
        write f_SortIndex;
        {-}
      property Duplicates: Tl3Duplicates
        read f_Duplicates
        write f_Duplicates;
        {-}
      property OnValidateChild : Tk2ValidateChildProc
        read f_OnValidateChild
        write f_OnValidateChild;
        {-}
      property OnGetChildTypeForParent: Tk2GetChildTypeForParentProc
        read f_OnGetChildTypeForParent
        write f_OnGetChildTypeForParent;
        {-}  
  end;//Tk2ChildrenProperty

  Tk2ArrayProperty = Tk2ChildrenProperty;
  Tk2TypeTable = class;

  Tk2TypePrim = k2Prim.Tk2TypePrim;

  Tk2Type = class(Tk2TypeModelPart)
   {* Описание типа тега. }
    private
    // internal fields
      f_TagsByOffset     : array of Tk2CustomProperty;
      f_Wrapper          : Wk2Atom;
      f_ParamsForClone   : TLongArray;
      f_InterfaceFactory : Tk2InterfaceFactory;
      f_IDIndex          : Long;
      f_ValueTable       : Tl3Dictionary;
      f_ChildrenPath     : Tk2ChildrenPathList;
      f_IsRawData        : Bool;
      f_ToolFactory      : Ik2TagToolFactory;
      f_ReadOnlyPropertyCount : Long;
      f_PropertyCount         : Long;
      {$IfDef k2NeedUserInfo}
      f_UserName              : AnsiString;
      {$EndIf k2NeedUserInfo}
      f_LastChildPath         : record
       rPath   : TLongArray;
       rTypeID : Integer;
      end;//f_LastChildPath
      f_Cache                 : array of Ik2Tag;
      f_IntfOffset            : Integer;
    protected
    // property methods
      function  pm_GetHasProperties: Boolean;
        {-}
      function  pm_GetHasProperty(Index: Long): Boolean;
        {-}
      function  pm_GetAtomClass: TClass;
      procedure pm_SetAtomClass(Value: TClass);
        {-}
      function  pm_GetMakeClass: TClass;
        {-}
      function  pm_GetArrayProp(TagIndex: Long): Tk2ChildrenProperty;
        {-}
      function  pm_GetPropertyCount: Long;
        {-}
      procedure pm_SetInterfaceFactoryType(Value: Rk2InterfaceFactory);
        {-}
      procedure pm_SetInterfaceFactory(Value: Tk2InterfaceFactory);
        {-}
      function  pm_GetWrapperType: Rk2Atom;
      procedure pm_SetWrapperType(Value: Rk2Atom);
        {-}
      procedure pm_SetValueTable(Value: Tl3Dictionary);
        {-}
    protected
    // internal methods
      procedure InheriteFrom(aType: Tk2Type);
        {-}
      procedure UndefineProperty(aTagIndex: Long);
        {-}
      procedure Cleanup;
        override;
        {-}
    public
    // public methods
      constructor Create(anOwner          : Tk2TypeTable;
                         const anUserName : AnsiString);
        reintroduce;
        virtual;
        {* - создает новый тип. }
      function  LoadTool(const ID: Tl3IID): Tk2ToolPrim;
        virtual;
        {-}
      function  StoreTool(const ID: Tl3IID; I: Tk2ToolPrim): Bool;
        virtual;
        {-}
      procedure Clear;
        override;
        {-}
      procedure Recalc;
        {-}
      function  DefineProperty(aTagIndex       : Long;
                               aPropType       : Tk2Type;
                               const aUserName : AnsiString = ''): Tk2Property;
        {* - определяет скалярное свойство типа тега. }
      procedure UndefineProperties(const aTags: array of Long);
        {-}
      function  DefineChildrenPrim(aChildType: Tk2Type;
                                   aListType: Tk2Type = nil): Tk2ChildrenProperty;
        {-}
      procedure DefineChildrenPath(aTagType: Tk2Type; const Path : array of Long);
        {-}
      function  FindChildPath(aTagType: Tk2TypePrim): TLongArray;
        {-}
      function  GetPropByOffset(anAtomIndex: Long): Tk2CustomProperty;
        {-}
      procedure IteratePropertiesF(anAction: Tl3IteratorAction);
        {-}
      procedure SetNeedMarkModified(const aProp : array of Long;
                                    aValue      : Boolean = true);
        {-}
      procedure SetNeedMarkModifiedAll(aValue: Boolean = true);
        {-}
      procedure SetNeedMarkModifiedAllExcept(aProp : Long);
        {-}
      procedure SetTagOrder(const aTag : array of Integer);
        {-}
    public
    // методы для работы с атомами данного типа
      function  DoMakeTag(aType: Tk2Type): Ik2Tag;
        virtual;
        {* - создает атом данного типа. }
      function  MakeTag: Ik2Tag;
        {* - создает атом данного типа. }
      procedure AddValue(const aValue: Ik2Tag);
        {-}
      function  IntToTag(aValue : Integer): Ik2Tag;
        {-}
      function  BoolToTag(aValue : Boolean): Ik2Tag;
        {-}
      function  PCharLenToTag(const aValue : Tl3PCharLen): Ik2Tag;
        {-}
      function  StrToTag(const aValue : AnsiString): Ik2Tag;
        {-}
      function  ObjToTag(aValue: TObject): Ik2Tag;
        {-}
      function  IUnknownToTag(const aValue : IUnknown): Ik2Tag;
        {-}
      function  TagFromIntRef(aRef : Integer): Ik2Tag;
        {-}    
      function  TransparentTag: Ik2Tag;
        {-}
    public
    // public properties
      property HasProperties: Boolean
        read pm_GetHasProperties;
        {* - определены ли свойства для данного типа. }
      property HasProperty[Index: Long]: Boolean
        read pm_GetHasProperty;
        {* - определено ли свойство Index? }
      property AtomClass: TClass
        read pm_GetAtomClass
        write pm_SetAtomClass;
        {-}
      property MakeClass: TClass
        read pm_GetMakeClass;
        {-}
      property ArrayProp[TagIndex: Long]: Tk2ChildrenProperty
        read pm_GetArrayProp;
        {-}
      property PropertyCount: Long
        read pm_GetPropertyCount;
        {* - количество свойст определенных у данного типа. }
      property IDIndex: Long
        read f_IDIndex
        write f_IDIndex;
        {-}
      property InterfaceFactory: Tk2InterfaceFactory
        read f_InterfaceFactory
        write pm_SetInterfaceFactory;
        {-}
      property InterfaceFactoryType: Rk2InterfaceFactory
        write pm_SetInterfaceFactoryType;
        {-}
      property WrapperType: Rk2Atom
        read pm_GetWrapperType
        write pm_SetWrapperType;
        {-}
      property ValueTable: Tl3Dictionary
        read f_ValueTable
        write pm_SetValueTable;
        {-}
      property IsRawData: Bool
        read f_IsRawData
        write f_IsRawData;
        {-}
      property ToolFactory: Ik2TagToolFactory
        read f_ToolFactory
        write f_ToolFactory;
        {-}
      property ReadOnlyPropertyCount: Long
        read f_ReadOnlyPropertyCount;
        {* - количество Read-only свойств. }
      property Properties: Tk2PropertyArray
        read f_Tags;
        {* - свойства типа. }
      {$IfDef k2NeedUserInfo}
      property UserName: AnsiString
        read f_UserName;
        {* - имя типа для пользователя. }    
      {$EndIf k2NeedUserInfo}
      property ParamsForClone: TLongArray
        read f_ParamsForClone
        write f_ParamsForClone;
        {* - параметры, которые копируются при клонировании. }
      property Wrapper: Wk2Atom                                 
        read f_Wrapper;
        {-}
  end;//Tk2Type

  Rk2Type = class of Tk2Type;

  Tk2TypeTable = class(Tk2TypeTablePrim)
   {* Таблица типов тегов. }
    protected
    // property methods
      function  pm_GetTypeByHandlePrim(H: Long): Tk2TypePrim; override;
      function  pm_GetTypeByHandle(H: Long): Tk2Type;
        virtual;
        {-}
    protected
    // internal methods
      procedure BeforeRelease;
        override;
    public
    // public methods
      function  ObjToTag(aValue : TObject): Ik2Tag;
        {-}
    public
    // public methods
      constructor Create;
        reintroduce;
        virtual;
        {-}
      class function GetInstance: Tk2TypeTable;
        {-}
      class procedure SetAsDefault;
        {-}
      class procedure CheckAndCleanupReferences;
        {-}
    protected
      function  DefineType(anID                : Long;
                             const aTagParents : array of Tk2Type;
                             const anUserName  : AnsiString = '';
                             aTypeRef          : Rk2Type = nil): Tk2Type;
        {* - определить тип со множественным наследованием. }
    public
    // public properties
      property TypeByHandle[H: Long]: Tk2Type
        read pm_GetTypeByHandle;
        default;
        {* - тип с идентификатором H. }
  end;//Tk2TypeTable

  _k2Int64Holder_Parent_ = Tl3CacheableBase;
  {$Include w:\common\components\rtl\Garant\K2\k2Int64Holder.imp.pas}
  Tk2TagBase = class(_k2Int64Holder_, Ik2Tag)
    private
    // internal fields
      f_Type : Tk2Type;
    private
    // interface methods
      // Ik2Tag
      function  Box: Ik2Tag;
        {* - ссылка на тег - для сохранения. }
      // Ik2Tag
      function  pm_GetChild(anIndex: Long): Ik2Tag;
        virtual;
        {-}
      function  pm_GetChildrenCount: Long;
        virtual;
        {-}
      procedure Set_ChildrenCapacity(aValue: Integer);
        {-}
      procedure pm_SetAttr(anIndex: Long; const aValue : Ik2Tag);
        {-}
      function  IntRef: Integer;
        virtual;
        {-}
      procedure SetIntRef(out aRef: Integer);
        virtual;
        {-}
      function  IsNull: Boolean;
        {-}
      function  IsValid: Boolean;
        {-}
      function  IsTransparent: Boolean;
        {-}
      function  IsOrd: Boolean;
        {-}
      function  IsStream(out theStream: IStream): Boolean;
        virtual;
        {-}
      function  InheritsFrom(const anIDs : array of Long): Bool;
        overload;
        {* - проверить наследование. }
      function  InheritsFrom(anAtomTypeID  : Long;
                             const Exclude : array of Long): Bool;
        overload;
        {* - проверить наследование. }
      function  InheritsFrom(ID: Long): Bool;
        overload;
        {* - проверяет наследование данного типа от типа с идентификатором ID. }
      function  Get_Owner: Ik2Tag;
        virtual;
      procedure Set_Owner(const aValue: Ik2Tag);
        virtual;
        {-}
      function  IsSame(const aTag: Ik2Tag): Bool;
        {* - проверяет эквивалентность двух хранилищ. }
      function  AsObject: TObject;
        virtual;
        {-}
      function  AsLong: Long;
        {-}
      function  AsBool: Bool;
        {* - преобразовать к Bool. }
      function  pm_GetAsString: AnsiString;
        {-}
      function  pm_GetAsPCharLen: Tl3PCharLen;
        {* - преобразовать к Tl3PCharLen. }
      function  AssignTag(const Source  : Ik2Tag;
                          AssignMode    : Tk2AssignModes = k2_amAll;
                          const Context : Ik2Op = nil): Bool;
        virtual;
        {-}
      function  HasSubAtom(anIndex: Long): Bool;
        virtual;
        {-}
      function  rLong(anIndex  : Long;
                      aDefault : Long): Long;
        virtual;
        {-}
      function  rBool(anIndex  : Long;
                      aDefault : Boolean): Boolean;
        virtual;
        {-}
      function  rOwnAtom(anIndex: Long): Ik2Tag;
        virtual;
        {-}
      function  pm_GetAttr(anIndex : Long): Ik2Tag;
        virtual;
        {-}
      function  rAtomEx(const Path : array of Long;
                        theIndex   : PLong = nil): Ik2Tag;
        virtual;
        {* - вернуть подтег. }
      procedure ForceStore;
        {-}
      procedure pm_SetAttrW(anIndex  : Integer;
                            const aContext : Ik2Op;
                            const aValue   : Ik2Tag);
        {* - изменить значение. }
      function  pm_GetBoolA(anIndex  : Integer): Boolean;
      procedure pm_SetBoolA(anIndex  : Integer;
                            aValue   : Boolean);
        {* - изменить значение. }
      function  pm_GetIntA(anIndex  : Integer): Integer;
      procedure pm_SetIntA(anIndex  : Integer;
                           aValue   : Integer);
        {* - изменить значение. }
      procedure pm_SetBoolW(anIndex  : Integer;
                             const aContext : Ik2Op;
                             aValue   : Boolean);
        {* - изменить значение. }
      procedure pm_SetIntW(anIndex        : Integer;
                            const aContext : Ik2Op;
                            aValue   : Integer);
        {* - изменить значение. }
      procedure pm_SetObjW(anIndex  : Integer;
                           const aContext : Ik2Op;
                           aValue         : TObject);
        {-}
      procedure SetIntWC(aProp    : Tk2CustomProperty;
                         const aContext : Ik2Op;
                         aValue         : Integer);
        virtual;                 
        {* - изменить значение. }
      function  pm_GetStrA(anIndex  : Integer): AnsiString;
      procedure pm_SetStrA(anIndex  : Integer;
                           const aValue   : AnsiString);
        {* - изменить значение. }
      function  pm_GetPCharLenA(anIndex      : Integer): Tl3PCharLen;  
      procedure pm_SetPCharLenA(anIndex      : Integer;
                                const aValue : Tl3PCharLen);
        {* - изменить значение. }
      procedure pm_SetStrW(anIndex  : Integer;
                            const aContext : Ik2Op;
                            const aValue   : AnsiString);
        {* - изменить значение. }
      procedure pm_SetPCharLenW(anIndex  : Integer;
                                 const aContext : Ik2Op;
                                 const aValue   : Tl3WString);
        {* - изменить значение. }
      procedure SetSubAtom(const aProp    : Tk2Prop;
                           const aSubAtom : Ik2Tag;
                           const Context  : Ik2Op);
        virtual;
        {-}
      procedure AssignCloneParams(const aSource : Ik2Tag;
                                  AssignMode    : Tk2AssignModes = k2_amAll;
                                  const Context : Ik2Op = nil);
        {-}
      procedure IterateProperties(Action : Ik2Tag_IterateProperties_Action;
                                  All    : Bool);
        {* - перебирает все существующие свойства. }
   {iterator} procedure IteratePropertiesF(anAction: Ik2Tag_IterateProperties_Action;
    anAll: Boolean
    {* Перебирать все возможные свойства или только РЕАЛЬНО заданные});
     {* перебирает все существующие свойства }
      function CompareWithInt(aValue: Integer;
                              anIndex: Integer): Integer;
        {* Сравнивает тег с целым. }
      function CompareWithTag(const aTag: Ik2Tag;
                              aSortIndex: Tl3SortIndex): Integer;
      function  cAtom(anIndex        : Long;
                      const aContext : Ik2Op = nil;
                      anAtomType: Tk2TypePrim = nil): Ik2Tag;
        {* - проверить существование подтега и создать его при необходимости. }
      function  cAtomEx(const aPath    : array of Long;
                        const aContext : Ik2Op;
                        theIndex       : PLong = nil): Ik2Tag;
        virtual;
        {* - проверить существование подтега и создать его при необходимости. }
      function  pm_GetTagType: Tk2TypePrim;
        {-}
      function  AddChild(var aChild     : Ik2Tag;
                         const aContext : Ik2Op = nil): Long;
        virtual;
        {* - добавить ребенка. }
      procedure InsertChild(anIndex        : Long;
                            var aChild     : Ik2Tag;
                            const aContext : Ik2Op = nil);
        virtual;
        abstract;
        {* - вставить ребенка. }
      function  IndexOfChild(const aChild: Ik2Tag): Integer;
        virtual;
        {-}
      procedure DeleteChildren(const Context: Ik2Op = nil);
        virtual;
        abstract;
        {* - удалить всех детей. }
      function  DeleteChild(Index         : Long;
                            const Context : Ik2Op;
                            out theChild  : Ik2Tag): Boolean;
        overload;
        virtual;
        abstract;
        {* - удалить ребенка. }
      function  DeleteChild(Index         : Long;
                            const Context : Ik2Op = nil): Boolean;
        overload;
        {* - удалить ребенка. }
      function  DeleteChild(const aChild  : Ik2Tag;
                            const Context : Ik2Op = nil): Boolean;
        overload;
        {* - удалить ребенка. }
      function  IterateChildren(Action : Ik2Tag_IterateChildrenF_Action;
                                aLo    : Tl3Index = l3MinIndex;
                                aHi    : Tl3Index = l3MaxIndex;
                                aLoadedOnly : Boolean = false): Long;
        virtual;
        {* - перебрать детей. }
      function  IterateChildrenF(Action : Ik2Tag_IterateChildrenF_Action;
                                 aLo    : Tl3Index = l3MinIndex;
                                 aHi    : Tl3Index = l3MaxIndex;
                                 aLoadedOnly : Boolean = false): Long;
        {* - перебрать детей с освобождением заглушки. }
      function  IterateChildrenBack(Action : Ik2Tag_IterateChildrenBack_Action;
                                    aHi    : Tl3Index = l3MaxIndex;
                                    aLo    : Tl3Index = l3MinIndex;
                                    aLoadedOnly : Boolean = false): Long;
        virtual;
        {* - перебрать детей. }
      function  IterateChildrenBackF(Action : Ik2Tag_IterateChildrenBack_Action;
                                     aHi    : Tl3Index = l3MaxIndex;
                                     aLo    : Tl3Index = l3MinIndex;
                                     aLoadedOnly : Boolean = false): Long;
        {* - перебрать детей с освобождением заглушки. }
      function  GetOwnInterface(const IID: TGUID; out Obj): Boolean;
        virtual;
        {* - возвращает интерфейс НЕПОСРЕДСТВЕННО поддерживаемый реализацией
             инструмента. }
      function  GetLinkedInterface(const IID: TGUID; out Obj): Boolean;
        {-}
      function  QT(const IID        : TGUID;
                   out Obj          ;
                   const aProcessor : Ik2Processor): Boolean;
        {* - созвращает инструмент для работы с данным тегом. }
      procedure Write(const G : Ik2TagGenerator;
                      Flags   : Tk2StorePropertyFlags = l3_spfAll;
                      Exclude : TByteSet = []);
        {* - записать тег в генератор. }
      procedure DoLoad;
        {-}
      function  MarkModified: Boolean;
        {-}
      procedure CheckSort(aProp: Tk2ArrayPropertyPrim);
        {-}
      function  FindChild(anAtom         : Integer;
                          aValue         : Integer;
                          const aContext : Ik2Op = nil;
                          aNeedCreate    : Boolean = false;
                          theIndex       : PLong = nil): Ik2Tag;
        virtual;
        {-}
      procedure ClearAtoms;
        {-}    
      function  GetValue: Long;
        virtual;
        abstract;
        {-}
      procedure SetValue(aValue: Long);
        virtual;
        abstract;
        {-}
    protected
    // internal methods
      procedure Cleanup;
        override;
        {-}
      function CloneTag: Ik2Tag;
        {-}
    public
    // public methods
      constructor Create(aValue      : Long;
                         const aType : Tk2Type);
        reintroduce;
        {-}
  end;//Tk2TagBase

  Tk2IUnknownTag = class(Tk2TagBase)
    private
    // internal fields
      f_IUnknown : IUnknown;
    protected
    // internal methods
      procedure SetIntRef(out aRef: Integer);
        override;
        {-}
      function  GetValue: Long;
        override;
      procedure SetValue(aValue: Long);
        override;
        {-}
      function COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
        override;
        {-}
  end;//Tk2IUnknownTag

  Tk2ObjectTag = class(Tk2TagBase)
    private
    // internal fields
      f_Object : TObject;
    protected
    // interface methods
      // Ik2Tag
      function pm_GetChild(anIndex: Long): Ik2Tag;
        override;
        {-}
      function pm_GetChildrenCount: Long;
        override;
        {* - количество детей. }
      function AsObject: TObject;
        override;
        {-}
      function rLong(anIndex  : Long;
                     aDefault : Long): Long;
        override;
        {-}
      function rBool(anIndex  : Long;
                     aDefault : Boolean): Boolean;
        override;
        {-}
      function  rOwnAtom(anIndex: Long): Ik2Tag;
        override;
        {-}
      function pm_GetAttr(anIndex : Long): Ik2Tag;
        override;
        {-}
      function rAtomEx(const aPath : array of Long;
                       theIndex    : PLong = nil): Ik2Tag;
        override;
        {* - вернуть подтег. }
      procedure SetSubAtom(const aProp    : Tk2Prop;
                           const aSubAtom : Ik2Tag;
                           const Context  : Ik2Op);
        override;
        {-}
      function cAtomEx(const aPath    : array of Long;
                       const aContext : Ik2Op;
                       theIndex       : PLong = nil): Ik2Tag;
        override;
        {* - проверить существование подтега и создать его при необходимости. }
      function AddChild(var aChild     : Ik2Tag;
                        const aContext : Ik2Op = nil): Long;
        override;
        {* - добавить ребенка. }
      procedure InsertChild(anIndex        : Long;
                            var aChild     : Ik2Tag;
                            const aContext : Ik2Op = nil);
        override;
        {* - вставить ребенка. }
      function IndexOfChild(const aChild: Ik2Tag): Integer;
        override;
        {-}
      procedure DeleteChildren(const Context: Ik2Op = nil);
        override;
        {* - удалить всех детей. }
      function  DeleteChild(Index         : Long;
                            const Context : Ik2Op;
                            out theChild  : Ik2Tag): Boolean;
        override;
        {* - удалить ребенка. }
      function  IterateChildren(Action : Ik2Tag_IterateChildrenF_Action;
                                aLo    : Tl3Index = l3MinIndex;
                                aHi    : Tl3Index = l3MaxIndex;
                                aLoadedOnly : Boolean = false): Long;
        override;
        {* - перебрать детей. }
      function  IterateChildrenBack(Action : Ik2Tag_IterateChildrenBack_Action;
                                    aHi    : Tl3Index = l3MaxIndex;
                                    aLo    : Tl3Index = l3MinIndex;
                                    aLoadedOnly : Boolean = false): Long;
        override;
        {* - перебрать детей. }
      (*procedure Write(const G       : Ik2TagGenerator;
                      Flags         : Tk2StorePropertyFlags = l3_spfAll;
                      const Exclude : TByteSet = []);
        override;
        {* - записать тег в генератор. }*)
      function  FindChild(anAtom         : Integer;
                          aValue         : Integer;
                          const aContext : Ik2Op = nil;
                          aNeedCreate    : Boolean = false;
                          theIndex       : PLong = nil): Ik2Tag;
        override;
        {-}
      function  AssignTag(const Source  : Ik2Tag;
                          AssignMode    : Tk2AssignModes = k2_amAll;
                          const Context : Ik2Op = nil): Bool;
        override;
        {-}
      procedure SetIntRef(out aRef: Integer);
        override;
        {-}
    protected
    // internal methods
      function  GetOwnInterface(const IID: TGUID; out Obj): Boolean;
        override;
        {-}
      function  GetAttrValue(const aProp  : Tk2CustomProperty;
                             out theValue : Long;
                             out theAttr  : Ik2Tag;
                             anOwnOnly    : Boolean): Boolean;
        virtual;                    
        {-}
      procedure DeleteMapped(aProp   : Tk2CustomProperty;
                             const Context : Ik2Op);
        virtual;                     
        {-}
      procedure SetAtom(const aProp    : Tk2Prop;
                        const NewValue : Ik2Tag;
                        const Context  : Ik2Op;
                        aDeleteMapped  : Bool);
        {-}
      procedure SetAtomPrim(aProp   : Tk2CustomProperty;
                            var V         : Tk2Values;
                            const Context : Ik2Op);
        virtual;
        {-}
      function  _cAttr(const aProp   : Tk2Prop;
                      const aContext : Ik2Op = nil): Ik2Tag;
        {* - проверить существование подтега и создать его при необходимости. }
      procedure ChildAdded(aProp    : Tk2ArrayProperty;
                           const aChild   : Ik2Tag;
                           anIndex        : Long;
                           aTotal         : Integer;
                           const anOpPack : Ik2Op);
        {* - нотификация о добавлении "ребенка". }
      function  CheckAttr(const aPath    : array of Long;
                          const aContext : Ik2Op;
                          DoCheck        : Bool;
                          theIndex       : PLong = nil): Ik2Tag;
        {-}
      function  GetValue: Long;
        override;
      procedure SetValue(aValue: Long);
        override;
        {-}
      function COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
        override;
        {-}
  end;//Tk2ObjectTag

  Tk2MemoryPoolTag = class(Tk2ObjectTag)
    protected
    // internal methods
      function  IsStream(out theStream: IStream): Boolean;
        override;
        {-}
      function  AssignTag(const Source  : Ik2Tag;
                          AssignMode    : Tk2AssignModes = k2_amAll;
                          const Context : Ik2Op = nil): Bool;
        override;
        {-}
      procedure SetValue(aValue: Long);
        override;
        {-}
      procedure SetIntRef(out aRef: Integer);
        override;
        {-}
  end;//Tk2MemoryPoolTag

  Tk2StreamTag = class(Tk2ObjectTag)
    protected
    // internal methods
      function  IsStream(out theStream: IStream): Boolean;
        override;
        {-}
(*      procedure SetValue(aValue: Long);
        override;
        {-}*)
        { TODO -oЛюлин А. В. -cНедоделка : Может быть здесь тоже надо сделать подсчет ссылок }
  end;//Tk2StreamTag

  Tk2L3StreamTag = class(Tk2StreamTag)
    protected
    // internal methods
      procedure SetValue(aValue: Long);
        override;
        {-}
      procedure SetIntRef(out aRef: Integer);
        override;
        {-}
      function  IsStream(out theStream: IStream): Boolean;
        override;
        {-}
  end;//Tk2L3StreamTag

  Tk2PersistentTag = class(Tk2ObjectTag)
    protected
    // internal methods
      function AssignTag(const Source  : Ik2Tag;
                         AssignMode    : Tk2AssignModes = k2_amAll;
                         const Context : Ik2Op = nil): Bool;
        override;
        {-}
  end;//Tk2PersistentTag

  Tk2L3ObjectTagPrim = class(Tk2PersistentTag)
    protected
    // internal methods
      function  IsStream(out theStream: IStream): Boolean;
        override;
        {-}
      procedure SetIntRef(out aRef: Integer);
        override;
        {-}
      function  Get_Owner: Ik2Tag;
        override;
      procedure Set_Owner(const aValue: Ik2Tag);
        override;
        {-}
      procedure SetValue(aValue: Long);
        override;
        {-}
  end;//Tk2L3ObjectTagPrim

  Tk2L3ObjectTag = class(Tk2L3ObjectTagPrim)
    protected
    // internal methods
      function GetAttrValue(const aProp  : Tk2CustomProperty;
                            out theValue : Long;
                            out theAttr  : Ik2Tag;
                            anOwnOnly    : Boolean): Boolean;
        override;
        {-}
      function  HasSubAtom(anIndex: Long): Bool;
        override;
        {-}
  end;//Tk2L3ObjectTag

  Tk2StringTag = class(Tk2PersistentTag)
    protected
    // internal methods
      function COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
        override;
        {-}
      function  IsStream(out theStream: IStream): Boolean;
        override;
        {-}
      procedure SetIntRef(out aRef: Integer);
        override;
        {-}
      function  Get_Owner: Ik2Tag;
        override;
      procedure Set_Owner(const aValue: Ik2Tag);
        override;
        {-}
      procedure SetValue(aValue: Long);
        override;
        {-}
      function GetAttrValue(const aProp  : Tk2CustomProperty;
                            out theValue : Long;
                            out theAttr  : Ik2Tag;
                            anOwnOnly    : Boolean): Boolean;
        override;
        {-}
      procedure SetAtomPrim(aProp   : Tk2CustomProperty;
                            var V         : Tk2Values;
                            const Context : Ik2Op);
        override;
        {-}
      function  HasSubAtom(anIndex: Long): Bool;
        override;
        {-}
  end;//Tk2StringTag

  Tk2ChildrenPath = class(Tl3ProtoObject)
    private
    // internal fields
      f_TagType : Tk2Type;
      f_Path    : TLongArray;
    public
    // public properties
      property TagType: Tk2Type
        read f_TagType
        write f_TagType;
        {-}
      property Path: TLongArray
        read f_Path
        write f_Path;
        {-}
  end;//Tk2ChildrenPath

procedure ConvertError(const N1, N2: AnsiString);
  {-}
function  k2L2TIA(Action: Pointer): Ik2Tag_IterateChildrenF_Action;
  {-}
procedure k2FreeTIA(var Stub: Ik2Tag_IterateChildrenF_Action);
  {-}
procedure k2ListError(anIndex: Long);
  {* - ошибка доступа к элементу списка }
function  k2NullTag: Ik2Tag;
  {-}
function  k2NullTagPlace: PIk2Tag;
  {-}

var
 g_InnerTypeID : Integer = Ord(High(Tk2TypeID)) + 1;
 {* Идентификатор следующео определяемого внутреннего типа. }

 g_DisableCheckDisabledChildren : Integer = 0;

implementation

uses
  SysUtils,
  {$IfDef Delphi6}
  RTLConsts,
  {$Else  Delphi6}
  Consts,
  {$EndIf Delphi6}
  Messages,

  l3Except,
  l3MinMax,
  l3Chars,
  l3String,
  l3Stream,
  l3InterfacesMisc,
  l3BaseStream,
  l3Memory,
  l3CObjectRefList,
  l3_CBaseRefList,
  l3_CBaseRefCacheableList,

  k2Const,
  k2Facade,
  k2InternalInterfaces,
  k2Strings,
  k2AtomicTag,
  k2TagList,
  k2Dictionary,
  k2PropSorter,
  k2NullTagImpl,

  k2Long_Const,
  k2Bool_Const,
  k2String_Const,
  k2l3Base_Const,
  k2Object_Const,
  k2IUnknown_Const,
  k2TransparentTag,

  l3Filer,

  k2SortTagsList
  {$IfOpt D+}
  ,
  k2SmallTagObject,
  k2ParentedTypedSmallLeafTag,
  k2ParentedTypedSmallListTag,
  k2DictRec
  {$EndIf}
  ;

type
  _Instance_R_ = Tk2TagBase;
  
{$Include w:\common\components\rtl\Garant\K2\k2Int64Holder.imp.pas}
  
var
 g_NullTagPlace : Pointer = nil;

procedure FreeNTP;
begin
 g_NullTagPlace := nil;
end;

function k2NullTagPlace: PIk2Tag;
  {-}

 procedure DoInit;
 var
  l_NT : Ik2Tag;  
 begin
  l_NT := k2NullTag;
  l3System.AddExitProc(FreeNTP);
  g_NullTagPlace := Pointer(l_NT);
 end;//g_NullTagPlace = nil

begin
 if (g_NullTagPlace = nil) then
  DoInit;
 Result := @g_NullTagPlace;
end;

function k2NullTag: Ik2Tag;
  {-}
begin
 Result := Tk2NullTagImpl.Make;
end;

function  k2L2TIA(Action: Pointer): Ik2Tag_IterateChildrenF_Action;
  register;
  {-}
asm
          jmp  l3LocalStub
end;{asm}

procedure k2FreeTIA(var Stub: Ik2Tag_IterateChildrenF_Action);
  register;
  {-}
asm
          jmp  l3FreeLocalStub
end;{asm}

procedure ConvertError(const N1, N2: AnsiString);
  {-}
begin
 raise Ek2ConversionError.CreateFmt(k2_errConvertError, [N1, N2]);
 {&Exception&}
end;

procedure k2ListError(anIndex: Long);
  {-ошибка доступа к элементу списка}
begin
 raise EListError.CreateFmt(SListIndexError, [anIndex])
end;

// start object Wk2Atom

constructor Wk2Atom.Create;
  //override;
  {-}
begin
 k2.AddListner(Self);
 inherited;
end;
  
procedure Wk2Atom.Cleanup;
  //override;
  {-}
begin
 inherited;
 k2.RemoveListner(Self);
end;

procedure Wk2Atom.Fire(const anEvent : Tk2Event;
                       const anOp    : Ik2Op);
  {* - сообщение о том, что что-то произошло. }
begin
 DoFire(anEvent, anOp);
end;

procedure Wk2Atom.DoFire(const anEvent : Tk2Event;
                         const anOp    : Ik2Op);
  //virtual;
  {* - сообщение о том, что что-то произошло. }
begin
end;

function Wk2Atom.New(aType: Tk2Type): Ik2Tag;
  {virtual;}
  {-создает атом данного типа}
begin
 Result := nil;
 Assert(false);
end;

function Wk2Atom.PreGetAtomData(const AE : Ik2Tag;
                                aProp    : Tk2CustomProperty;
                                out Data : Long): Bool;
  //virtual;
  {-}
begin
 Result := false;
 Data := 0;
end;

function Wk2Atom.GetAtomData(const AE : Ik2Tag;
                             aProp    : Tk2CustomProperty;
                             out Data : Long): Bool;
  {virtual;}
  {-}
begin
 Result := false;
 Data := 0;
end;

function Wk2Atom.AsLong(const A: Ik2Tag): Long;
  {virtual;}
  {-}
begin
 ConvertError(AtomType.AsString, 'Long');
 Result := 0;
end;

function Wk2Atom.AsString(const A: Ik2Tag): AnsiString;
  {virtual;}
  {-}
begin
 ConvertError(AtomType.AsString, 'AnsiString');
 Result := '';
end;

function Wk2Atom.AsBool(const A: Ik2Tag): Bool;
  {virtual;}
  {-}
begin
 ConvertError(AtomType.AsString, 'Bool');
 Result := false;
end;

function Wk2Atom.IntToTag(aValue: Long): Ik2Tag;
  //virtual;
  {-}
begin
 ConvertError('Long', AtomType.AsString);
 Result := nil;
end;

function Wk2Atom.BoolToTag(Value: Bool): Ik2Tag;
  //virtual;
  {-}
begin
 ConvertError('Bool', AtomType.AsString);
end;

function Wk2Atom.StrToTag(const aValue: AnsiString): Ik2Tag;
  //virtual;
  {-}
begin
 ConvertError('AnsiString', AtomType.AsString);
end;

function Wk2Atom.ObjToTag(aValue: TObject): Ik2Tag;
  //virtual;
  {-}
begin
 if (aValue = nil) then
  ConvertError(k2_strNil, AtomType.AsString)
 else
  ConvertError(aValue.ClassName, AtomType.AsString);
end;

procedure Wk2Atom.ForceStore(const aTag : Ik2Tag);
  //virtual;
  {-}
begin
end;

function Wk2Atom.MarkModified(const aTag : Ik2Tag): Boolean;
  //virtual;
  {-}
begin
 Result := false;
end;

// start class Tk2CustomProperty

constructor Tk2CustomProperty.Create(aParentType     : Tk2Type;
                                     anID            : Integer;
                                     const aUserName : AnsiString);
  {override;}
  {- P - адрес указателя куда будет положен Self}
begin
 pm_SetTagIndex(anID);
 inherited Create(aParentType);
 f_Stored := Ord(anID <= k2_tiChildren);
 {$IfDef k2NeedUserInfo}
 f_UserName := aUserName;
 {$EndIf k2NeedUserInfo}
end;

function Tk2CustomProperty.Clone(aParentType: Tk2Type): Pointer;
type
  Rk2CustomProperty = class of Tk2CustomProperty;
begin
 Result := Rk2CustomProperty(ClassType).Create(aParentType,
                                               Self.TagIndex,
                                               {$IfDef k2NeedUserInfo}
                                               Self.UserName
                                               {$Else  k2NeedUserInfo}
                                               ''
                                               {$EndIf k2NeedUserInfo}
                                               );
 Tk2CustomProperty(Result).AssignString(Self);
end;

function Tk2CustomProperty.GetIsProp: Boolean;
  //override;
  {-}
begin
 Result := true;
end;

function Tk2CustomProperty.pm_GetTagType: Tk2TypePrim;
  //override;
  {-}
begin
 Result := Tk2TypePrim(AtomType);
end;
  
function  Tk2CustomProperty.pm_GetEmptyMapping: Long;
  {virtual;}
  {-}
begin
 Result := k2_tiMask;
end;

procedure Tk2CustomProperty.pm_SetEmptyMapping(Value: Long);
  {virtual;}
  {-}
begin
end;

function Tk2CustomProperty.pm_GetDefaultValue: Long;
  {virtual;}
  {-}
begin
 Result := l3NilLong;
end;

function Tk2CustomProperty.pm_GetReadOnly: Bool;
  {virtual;}
  {-}
begin
 Result := false;
end;

procedure Tk2CustomProperty.pm_SetReadOnly(Value: Bool);
  {virtual;}
  {-}
begin
end;

procedure Tk2CustomProperty.pm_SetDefaultValue(Value: Long);
  {virtual;}
  {-}
begin
end;

procedure Tk2CustomProperty.pm_SetTagIndex(Value: Long);
  {-}
begin
 StringID := Value;
 AtomIndex := Value;
end;

function Tk2CustomProperty.pm_GetOrderKey: Tl3OrderKey;
  {-}
begin
 Result.Primary := AtomIndex;
 Result.Delta := f_Weight;
end;

procedure Tk2CustomProperty.pm_SetOrderKey(const Value: Tl3OrderKey);
  {-}
begin
 AtomIndex := Value.Primary;
 f_Weight := Value.Delta;
end;

function Tk2CustomProperty.pm_GetIsArray: Bool;
  {virtual;}
  {-}
begin
 Result := false;
end;

function Tk2CustomProperty.IsThisArray(out theProp: Tk2ArrayPropertyPrim): Boolean;
  //virtual;
  {-}
begin
 Result := false;
end;

function Tk2CustomProperty.pm_GetMappingTarget: Long;
  //virtual;
  {-}
begin
 Result := 0;
end;

procedure Tk2CustomProperty.pm_SetMappingTarget(aValue: Long);
  //virtual;
  {-}
begin
end;
  
procedure Tk2CustomProperty.pm_SetStoredProc(Value: Tk2StoredPropProc);
  {-}
begin
 Tk2StoredPropProc(f_Stored) := Value;
end;

procedure Tk2CustomProperty.pm_SetStored(Value: Boolean);
  {-}
begin
 if (f_Stored <> Ord(Value)) then
 begin
  Assert(not Value OR (TagIndex <= k2_tiChildren));
  f_Stored := Ord(Value);
 end;//f_Stored <> Value
end;

procedure Tk2CustomProperty.AssignString(P: Tl3PrimString);
  {override;}
  {-}
var
 l_Prop : Tk2CustomProperty absolute P;
begin
 if (P Is Tk2CustomProperty) then
 begin
  pm_SetTagIndex(l_Prop.TagIndex);
  AtomType := l_Prop.AtomType;
  DefaultValue := l_Prop.DefaultValue;
  BeforeChange := l_Prop.BeforeChange;
  AfterChange := l_Prop.AfterChange;
  Shared := l_Prop.Shared;
  f_Stored := l_Prop.f_Stored;
  ReadOnly := l_Prop.ReadOnly;
  NeedMarkModified := l_Prop.NeedMarkModified;
  {$IfDef k2NeedUserInfo}
  f_UserName := l_Prop.f_UserName;
  {$EndIf k2NeedUserInfo}
  OrderKey := l_Prop.OrderKey;
 end//P Is Tk2CustomProperty
 else
  inherited;
end;

function  Tk2CustomProperty.DoBeforeChange(var V         : Tk2Values;
                                           const Context : Ik2Op): Bool;
  {-}
begin
 if Assigned(f_BeforeChange) then
  Result := f_BeforeChange(V, Self, Context)
 else
  Result := true;
end;

procedure Tk2CustomProperty.DoAfterChange(var V         : Tk2Values;
                                          const Context : Ik2Op);
  {-}

 procedure SignalAfterChange;
 begin//
  if Assigned(f_AfterChange) then
  begin
   f_AfterChange(V, Self, Context)
  end;//Assigned(f_AfterChange)
 end;//SignalAfterChange

begin
 if (TagIndex = k2_tiAllChildrenCount) then
  Exit;
 if V.IsChanged then
 begin
  if (Context <> nil) AND not Context.InIOProcess then
   Context.Processor.NotifyPropChanged(Self, V, Context);
  //not OldValue.EQ(NewValue)
  SignalAfterChange;
 end;//V.IsChanged
end;

function Tk2CustomProperty.GetStored(const P       : Ik2Tag;
                                     const Value   : Ik2Tag;
                                     const Context : Ik2Op): Bool;
  {-}
begin
 if (ULongComp(f_Stored, High(Word)) > 0) then
  Result := Tk2StoredPropProc(f_Stored)(P, Value, Self, Context)
 else
  Result := Bool(f_Stored);
end;

// start class Tk2Property 

constructor Tk2Property.Create(aParentType     : Tk2Type;
                               anID            : Integer;
                               anAtomType      : Tk2Type;
                               const aUserName : AnsiString);
  {override;}
  {- P - адрес указателя куда будет положен Self}
begin
 inherited Create(aParentType, anID, aUserName);
 f_EmptyMapping := k2_tiMask;
 f_DefaultValue := l3NilLong;
 AtomType := anAtomType;
end;

procedure Tk2Property.InitFields;
  //override;
  {-}
begin
 inherited;
 f_EmptyMapping := k2_tiMask;
 f_DefaultValue := l3NilLong;
end;

function  Tk2Property.pm_GetEmptyMapping: Long;
  {override;}
  {-}
begin
 Result := f_EmptyMapping;
end;

procedure Tk2Property.pm_SetEmptyMapping(Value: Long);
  {override;}
  {-}
var
 l_Prop : Tk2CustomProperty;
begin
 if (f_EmptyMapping <> Value) then
 begin
  if (f_EmptyMapping <> k2_tiMask) then
  begin
   l_Prop := Tk2CustomProperty(Tk2TypePrim(ParentType).Prop[f_EmptyMapping]);
   if (l_Prop <> nil) then
    l_Prop.MappingTarget := l_Prop.MappingTarget - 1;
  end;//f_EmptyMapping <> k2_tiMask
  f_EmptyMapping := Value;
  if (Value <> k2_tiMask) then
  begin
   l_Prop := Tk2CustomProperty(Tk2TypePrim(ParentType).Prop[Value]);
   if (l_Prop <> nil) then
    l_Prop.MappingTarget := l_Prop.MappingTarget + 1;
  end;//Value <> k2_tiMask
 end;//f_EmptyMapping <> Value
end;

function Tk2Property.pm_GetReadOnly: Bool;
  {override;}
  {-}
begin
 Result := f_ReadOnly;
end;

procedure Tk2Property.pm_SetReadOnly(Value: Bool);
  {override;}
  {-}
begin
 if (f_ReadOnly <> Value) then
 begin
  f_ReadOnly := Value;
  if Value then
   Inc(Tk2Type(ParentType).f_ReadOnlyPropertyCount)
  else
   Dec(Tk2Type(ParentType).f_ReadOnlyPropertyCount);
 end;//f_ReadOnly <> Value
end;

function  Tk2Property.pm_GetDefaultValue: Long;
  {override;}
  {-}
begin
 Result := f_DefaultValue;
end;

function Tk2Property.pm_GetMappingTarget: Long;
  //override;
  {-}
begin
 Result := f_MappingTarget;
end;

procedure Tk2Property.pm_SetMappingTarget(aValue: Long);
  //override;
  {-}
begin
 f_MappingTarget := aValue;
end;

procedure Tk2Property.pm_SetDefaultValue(Value: Long);
  {override;}
  {-}
begin
 f_DefaultValue := Value;
end;

// start class Tk2ChildrenProperty 

constructor Tk2ChildrenProperty.Create(aParentType     : Tk2Type;
                                       aChildType      : Tk2Type;
                                       aAtomType       : Tk2Type;
                                       const aUserName : AnsiString);
  {override;}
  {- P - адрес указателя куда будет положен Self}
begin
 inherited Create(aParentType, k2_tiChildren, aUserName);
 f_StoredChild := Ord(true);
 f_SortIndex := k2_tiSelfID;
 f_Duplicates := l3_dupIgnore;
 f_MaxChildrenCount := High(f_MaxChildrenCount);
 ChildType := aChildType;
 AtomType := aAtomType;
end;

procedure Tk2ChildrenProperty.Cleanup;
  {override;}
  {-}
begin
 l3Free(f_ChildType);
 l3Free(f_DefaultChildType);
 inherited;
end;

procedure Tk2ChildrenProperty.AssignString(P: Tl3PrimString);
  {override;}
  {-}
var
 Prop : Tk2ChildrenProperty absolute P;
begin
 inherited;
 if (P Is Tk2ChildrenProperty) then
 begin
  pm_SetTagIndex(Prop.TagIndex);
  // - это чтобы перетереть OrderKey - чтобы дети были вседа ЗА тегами
  //   См. http://mdp.garant.ru/pages/viewpage.action?pageId=139429761 
  ChildType := Prop.ChildType;
  DefaultChildType := Prop.DefaultChildType;
  SortIndex := Prop.SortIndex;
  Duplicates := Prop.Duplicates;
  f_StoredChild := Prop.f_StoredChild;
  f_OnValidateChild := Prop.f_OnValidateChild;
  f_OnGetChildTypeForParent := Prop.f_OnGetChildTypeForParent;
  f_MaxChildrenCount := Prop.f_MaxChildrenCount;
 end;//P Is Tk2ChildrenProperty
end;

function Tk2ChildrenProperty.ValidateChild(const aParent : Ik2Tag;
                                           var aChild    : Ik2Tag;
                                           const Context : Ik2Op;
                                           anIndex       : Integer): Bool;
  {-}
begin
 if (ChildType = nil) then
  Result := false
 else
  Result := aChild.InheritsFrom(ChildType.ID);
 if (g_DisableCheckDisabledChildren <= 0) then
  if Result then
   if ParentType.IsDisabledChildTypeID(aChild.TagType.ID) then
    Result := false;
 if Assigned(f_OnValidateChild) then
  f_OnValidateChild(aParent, aChild, Result);
 if Result AND (Context <> nil) AND
    not Context.InUndo AND not Context.InIOProcess then
  Context.Processor.CheckInsert(aParent, IUnknown(aChild), anIndex);
end;

procedure Tk2ChildrenProperty.DoAfterChildAdded(const anAtom   : Ik2Tag;
                                                const aChild   : Ik2Tag;
                                                const anOpPack : Ik2Op;
                                                anIndex        : Long;
                                                aTotal         : Integer);
  {-}
begin
 aChild.Owner := anAtom;
 if (anIndex >= 0) AND (anOpPack <> nil) then
 begin
  if not anOpPack.InIOProcess then
   if NeedMarkModified then
    anOpPack.MarkModified(anAtom);
  if (anOpPack.Processor <> nil) then
   anOpPack.Processor.NotifyInsert(anAtom, Self, aChild, anIndex, anOpPack);
 end;//anIndex >= 0
end;

procedure Tk2ChildrenProperty.pm_SetChildType(Value: Tk2Type);
  {-}
begin
 if l3Set(f_ChildType, Value) then
  DefaultChildType := Value;
end;

procedure Tk2ChildrenProperty.pm_SetDefaultChildType(Value: Tk2Type);
  {-}
begin
 l3Set(f_DefaultChildType, Value);
end;

function Tk2ChildrenProperty.pm_GetStoredChildProc: Tk2StoredChildProc;
  {-}
begin
 Result := Tk2StoredChildProc(f_StoredChild);
end;

procedure Tk2ChildrenProperty.pm_SetStoredChildProc(Value: Tk2StoredChildProc);
  {-}
begin
 Tk2StoredChildProc(f_StoredChild) := Value;
end;

function Tk2ChildrenProperty.pm_GetIsArray: Bool;
  {override;}
  {-}
begin
 Result := true;
end;

function Tk2ChildrenProperty.IsThisArray(out theProp: Tk2ArrayPropertyPrim): Boolean;
  //override;
  {-}
begin
 Result := true;
 theProp := Self;
end;

function Tk2ChildrenProperty.GetStoredChild(const P       : Ik2Tag;
                                            const Value   : Ik2Tag;
                                            const Context : Ik2Op): Bool;
  {-}
begin
 if (ULongComp(f_StoredChild, High(Word)) > 0) then
  Result := Tk2StoredChildProc(f_StoredChild)(P, Value, Self, Context)
 else
  Result := Bool(f_StoredChild);
end;

function Tk2ChildrenProperty.GetChildTypeForParent(const aList: Ik2Tag): Tk2Type;
  {-}
var
 l_T : Tk2Type;
begin
 l_T := ChildType;
 if Assigned(f_OnGetChildTypeForParent) then
  f_OnGetChildTypeForParent(aList, l_T);
 Result := l_T; 
end;

procedure Tk2ChildrenProperty.SetSortTags(const aTag : array of Integer);
  {-}
var
 l_Index : Integer;
 l_A     : TLongArray;
 l_SI    : Integer;
begin
 if (High(aTag) = 0) AND (aTag[0] >= 0) then
  SortIndex := aTag[0]
 else
 if (High(aTag) > 0) then
 begin
  l_A := l3LongArray(aTag);
  l_Index := Tk2SortTagsList.Instance.IndexOf(l_A);
  if (l_Index >= 0) then
   l_SI := l_Index
  else
   l_SI := Tk2SortTagsList.Instance.Add(l_A);
  SortIndex := l_SI + k2_tiComplexBase;
 end;//High(aTag) > 0
end;

(*function  Tk2ChildrenProperty.DeleteChild(const aParent : Ik2Tag;
                                          Index         : Long;
                                          const anAtom  : Ik2Tag;
                                          const Context : Ik2Op): Boolean;
  {-}
var
 L        : Ik2Tag;
 l_Remove : Bool;
 l_List   : Tk2TagList;
 l_Child  : Ik2Tag;
begin
 L := aParent.Attr[Self.TagIndex];
 if L.IsValid then
 begin
  Result := true;
  l_List := (L.AsObject As Tk2TagList);
  l_Remove := not anAtom.IsNull;
  if l_Remove then
   l_Child := anAtom
  else
   l_Child := l_List[Index];
  l_Child.Owner := nil;
  if l_Remove then
  begin
   if not l_List.Sorted then
    l_Remove := false;
  end;//l_Remove
  k2.SignalEvent(Self, k2_eidChildrenDeleted, aParent, Context, Index, 1, l_List.Count - 1);
  if (Context <> nil) AND not Context.InIOProcess then
  begin
   if not Context.InIOProcess then
    if NeedMarkModified then
     Context.MarkModified(aParent);
    Context.Processor.NotifyDelete(aParent, Self, l_Child, Index, Context);
  end;//Context <> nil
  if l_Remove then
   l_List.Remove(anAtom)
  else
   l_List.Delete(Index);
 end//L.IsValid
 else
 begin
  Result := false;
  k2ListError(Index);
 end;//L.IsValid
end;*)

// start class Tk2Type

var
  k2TypeBuffers : Pl3MemoryChain = nil;

constructor Tk2Type.Create(anOwner          : Tk2TypeTable;
                           const anUserName : AnsiString);
  {override;}
  {- P - адрес указателя куда будет положен Self}
begin
 WrapperType := Wk2Atom;
 f_Tags.Init(Succ(Ord(High(Tk2TagID))), k2TypeBuffers);
 inherited Create{(anOwner)};
 TypeTable := anOwner;
 {$IfDef k2NeedUserInfo}
 f_UserName := anUserName;    
 {$EndIf k2NeedUserInfo}
 f_PropertyCount := -1;
 f_LastChildPath.rTypeID := -1;
 f_IDIndex := k2_tiSelfID;
end;

procedure Tk2Type.Cleanup;
  {override;}
  {-}
begin
 Finalize(f_Cache);
 f_TagsByOffset := nil;
 Clear;
 ToolFactory := nil;
 l3Free(f_Wrapper);
 inherited;
end;

function __FreeProp1(P: Pointer; BitNum: Long): Bool; far;
begin
 if (BitNum <> k2_tiMask) then
  l3Free(Pk2CustomProperty(P)^);
 Result := true;
end;

function __FreeProp2(Prop: Pointer): Bool; far;
begin
 l3Free(Prop^);
 Result := true;
end;

procedure Tk2Type.Clear;
  {override;}
  {-}
begin
 l3Free(f_InterfaceFactory);
 l3Free(f_ValueTable);
 l3Free(f_ChildrenPath);
 f_Tags.Clear(__FreeProp1, k2TypeBuffers);
 inherited;
end;

procedure Tk2Type.SetNeedMarkModified(const aProp : array of Long;
                                      aValue      : Boolean = true);
  {-}
var
 l_Prop  : Tk2CustomProperty;
 l_Index : Integer;
begin
 for l_Index := Low(aProp) to High(aProp) do
 begin
  l_Prop := Tk2CustomProperty(Prop[aProp[l_Index]]);
  if (l_Prop <> nil) then
   l_Prop.NeedMarkModified := aValue;
 end;//for l_Index
end;
  
procedure Tk2Type.SetNeedMarkModifiedAll(aValue: Boolean = true);
  {-}

 function DoProp(aProp: Pk2CustomProperty; Index: Long): Bool;
 begin//DoProp
  Result := true;
  aProp^.NeedMarkModified := aValue;
 end;//DoProp

begin
 IteratePropertiesF(l3L2IA(@DoProp));
end;
  
procedure Tk2Type.SetNeedMarkModifiedAllExcept(aProp : Long);
  {-}
begin
 SetNeedMarkModifiedAll;
 SetNeedMarkModified([aProp], false);
end;
  
procedure Tk2Type.SetTagOrder(const aTag : array of Integer);
  {-}
var
 l_Key   : Tl3OrderKey;
 l_Index : Integer;
begin
 l_Key := Tk2CustomProperty(Prop[aTag[Low(aTag)]]).OrderKey.StrengthPred;
 for l_Index := Low(aTag) + 1 to High(aTag) do
 begin
  with Tk2CustomProperty(Prop[aTag[l_Index]]) do
  begin
   OrderKey := l_Key;
   l_Key := OrderKey.Succ;
  end;//with Prop[aTag[l_Index]]
 end;//for l_Index
end;

function Tk2Type.pm_GetHasProperties: Boolean;
  {virtual;}
  {-}
begin
 Result := (f_Tags.BitCount <> 0);
end;

function Tk2Type.pm_GetHasProperty(Index: Long): Boolean;
  {-}
begin
 Result := f_Tags.CheckItem(Index);
end;

function Tk2Type.pm_GetAtomClass: TClass;
  {-}
var
 AT : PTypeInfo;
begin
 AT := AtomType;
 if (AT^.Kind = tkClass) then
  Result := GetTypeData(AT)^.ClassType
 else
  Result := nil;
end;

procedure Tk2Type.pm_SetAtomClass(Value: TClass);
  {-}
begin
 if (Value = nil) then
  AtomType := nil
 else
 begin
  AtomType := Value.ClassInfo;
  Assert(AtomType <> nil);
 end;//Value = nil
end;

function Tk2Type.pm_GetMakeClass: TClass;
  {-}
var
 AT : PTypeInfo;
begin
 AT := MakeType;
 if (AT^.Kind = tkClass) then
  Result := GetTypeData(AT)^.ClassType
 else
  Result := nil;
end;

function Tk2Type.pm_GetArrayProp(TagIndex: Long): Tk2ChildrenProperty;
  {-}
begin
 if (TagIndex = k2_tiChildren) then
  Result := Tk2ChildrenProperty(Self.Prop[TagIndex])
 else
  Result := nil;
end;

function Tk2Type.pm_GetPropertyCount: Long;
  {-}
begin
 if (f_PropertyCount = -1) then
  f_PropertyCount := f_Tags.BitCount;
 Result := f_PropertyCount; 
end;

procedure Tk2Type.pm_SetInterfaceFactoryType(Value: Rk2InterfaceFactory);
  {-}
var
 _IF : Tk2InterfaceFactory;
begin
 _IF := Value.Create;
 try
  InterfaceFactory := _IF;
 finally
  l3Free(_IF);
 end;{try..finally}
end;

procedure Tk2Type.pm_SetInterfaceFactory(Value: Tk2InterfaceFactory);
  {-}
var
 l_Factory : Ik2TagToolFactory;
begin
 if l3Set(f_InterfaceFactory, Value) then begin
  if (Value <> nil) AND l3IOk(Value.QueryInterface(Ik2TagToolFactory, l_Factory)) then
   try
    ToolFactory := l_Factory;
   finally
    l_Factory := nil;
   end;{try..finally}
 end;{l3Set..}
end;

function  Tk2Type.pm_GetWrapperType: Rk2Atom;
begin
 Result := Rk2Atom(f_Wrapper.ClassType);
end;

procedure Tk2Type.pm_SetWrapperType(Value: Rk2Atom);
  {-}
begin
 l3Free(f_Wrapper);
 f_Wrapper := Value.Create;
 f_Wrapper.AtomType := Self;
end;

procedure Tk2Type.pm_SetValueTable(Value: Tl3Dictionary);
  {-}
begin
 l3Set(f_ValueTable, Value);
end;

const
 cReadOnlyTagIndex = -2;
 
function Tk2Type.GetPropByOffset(anAtomIndex: Long): Tk2CustomProperty;
  {-}

 function SearchProp(aProp: Pk2CustomProperty; Index: Long): Bool; 
 begin//SearchProp
  if (aProp^.AtomIndex = anAtomIndex) then
  begin
   GetPropByOffset := aProp^;
   Result := false;
  end//(aProp^.AtomIndex = anAtomIndex)
  else
   Result := true;
 end;//SearchProp

var
 l_Len : Long;
begin
 Result := nil;
 if (anAtomIndex <> cReadOnlyTagIndex) then
 // - ReadOnly-свойства физически нигде не хранятся таким образом они не могут быть
 //   вычислены по смещению.
 begin
  l_Len := Length(f_TagsByOffset);
  if (anAtomIndex < l_Len) then
   Result := f_TagsByOffset[anAtomIndex];
  if (Result = nil) then
  begin
   IteratePropertiesF(l3L2IA(@SearchProp));
   if (Result <> nil) then
   begin
    if (l_Len <= anAtomIndex) then
     SetLength(f_TagsByOffset, Succ(anAtomIndex));
    f_TagsByOffset[anAtomIndex] := Result;
   end;//Result <> nil
  end;//Result <> nil
 end;//anAtomIndex <> cReadOnlyTagIndex
end;

procedure Tk2Type.IteratePropertiesF(anAction: Tl3IteratorAction);
  {-}
begin
 f_Tags.StoreF(anAction);
end;

type
  Tk2HackString = class(Tl3PrimString);

procedure Tk2Type.InheriteFrom(aType: Tk2Type);
  {-}

 function InheriteProperty(Prop: Pk2CustomProperty; BitNum: Long): Bool; far;

 var
  NewProp : Tk2CustomProperty;

 begin
  Result := true;
  NewProp := Prop^.Clone(Self);
  try
   Assert(Tk2HackString(NewProp).GetOwner = Self);
   f_Tags.SetItem(BitNum, __FreeProp2, NewProp);
  except
   l3Free(NewProp);
   raise;
  end;{try..except}
 end;

 function InheriteMapping(_Prop: Pk2CustomProperty; BitNum: Long): Bool; far;
 begin
  Tk2CustomProperty(Prop[BitNum]).EmptyMapping := _Prop^.EmptyMapping;
  Result := true;
 end;

var
 _IF : Tk2InterfaceFactory;
begin
 WrapperType := aType.WrapperType;
 _IF := aType.InterfaceFactory;
 if (_IF <> nil) then InterfaceFactory := _IF;
 aType.IteratePropertiesF(l3L2IA(@InheriteProperty));
 aType.IteratePropertiesF(l3L2IA(@InheriteMapping));
 AtomType := aType.AtomType;
 MakeType := aType.MakeType;
 TypeTable := aType.TypeTable;
 ValueTable := aType.ValueTable;
 l3Set(f_ChildrenPath, aType.f_ChildrenPath);
 IDIndex := aType.IDIndex;
 IsRawData := aType.IsRawData;
 ToolFactory := aType.ToolFactory;
 ParamsForClone := aType.ParamsForClone;
 DisabledChildTypeIDs := aType.DisabledChildTypeIDs;
end;

function Tk2Type.LoadTool(const ID: Tl3IID): Tk2ToolPrim;
  {override;}
  {-}
var
 _IF : Tk2InterfaceFactory;
begin
 _IF := InterfaceFactory;
 if (_IF = nil) then
  Result := nil
 else
  Result := _IF.LoadTool(ID);
end;

function Tk2Type.StoreTool(const ID: Tl3IID; I: Tk2ToolPrim): Bool;
  {override;}
  {-}
var
 _IF : Tk2InterfaceFactory;
begin
 _IF := InterfaceFactory;
 if (_IF = nil) then
  Result := false
 else
  Result := _IF.StoreTool(ID, I);
end;

{$IfDef nsTest}
 {.$Define k2OutTagStat}
{$EndIf nsTest}

{$IfDef k2OutTagStat}
var
 F : Tl3DOSFiler;

procedure FreeF;
begin
 F.Close;
 FreeAndNil(F);
end;
{$EndIf k2OutTagStat}

procedure Tk2Type.Recalc;
  {-}

var
 l_PL : Tk2PropSorter;

 function SortProperty(Prop: Pk2CustomProperty; Index: Long): Bool; 
 begin
  Result := true;
  l_PL.Add(Prop^);
 end;

var
 l_OrderKey : Tl3OrderKey;
const
 l_ReadOnlyKey : Tl3OrderKey = (Primary : cReadOnlyTagIndex; Delta : 0);

 function RecalcProperty(Prop: Pk2CustomProperty; Index: Long): Bool; 
 begin//RecalcProperty
  Result := true;
  if Prop^.ReadOnly then
   Prop^.OrderKey := l_ReadOnlyKey
  else
  begin
   Prop^.OrderKey := l_OrderKey;
   Inc(l_OrderKey.Primary);
  end;//Prop^.ReadOnly 
 end;//RecalcProperty

{$IfDef k2OutTagStat}
var
 l_IS : Integer;
 l_AC : AnsiString;
{$EndIf k2OutTagStat} 
begin
 {$IfDef k2OutTagStat}
 if (F = nil) then
 begin
  F := Tl3DOSFiler.Make('c:\1\types.csv', l3_fmWrite);
  l3System.AddExitProc(FreeF);
  F.Open;
 end;//F = nil
 {$EndIf k2OutTagStat}
 f_IsOrd := l3_bUnknown;
 Finalize(f_Cache);
 f_PropertyCount := -1;
 f_LastChildPath.rTypeID := -1;
 f_LastProperty.rProp := nil;
 f_LastProperty.rID := -1;
 l_PL := Tk2PropSorter.Make;
 try
  l_PL.Duplicates := l3_dupAccept;
  { сортируем свойства по весам: }
  IteratePropertiesF(l3L2IA(@SortProperty));
  { выставляем свойствам новые веса: }
  l_PL.Sorted := true;
  l_OrderKey.SetNull;
  l_PL.IterateAllF(l3L2IA(@RecalcProperty));
 finally
  l3Free(l_PL);
 end;//try..finally
 if (f_ChildrenPath <> nil) then
  f_ChildrenPath.Sort;
 {$IfDef k2OutTagStat}
 l_IS := 0;
 l_AC := '';
 if (AtomType <> nil) AND (AtomClass <> nil) then
 begin
  l_IS := AtomClass.InstanceSize;
  l_AC := AtomClass.ClassName;
 end;//AtomClass <> nil
 F.WriteLn(AsString + ', ' + IntToStr(PropertyCount - ReadOnlyPropertyCount) + ', ' + l_AC + ', ' + IntToStr(l_IS));
 {$EndIf k2OutTagStat}
 {$IfOpt D+}
 if (AtomType <> nil) then
  if (AtomClass <> nil) then
   if (AtomClass.InheritsFrom(Tk2SmallTagObject)) OR
      (AtomClass.InheritsFrom(Tk2ParentedTypedSmallLeafTag)) OR
      (AtomClass.InheritsFrom(Tk2ParentedTypedSmallListTag)) OR
      (AtomClass.InheritsFrom(Tk2DictRec)) then
    Assert(PropertyCount - ReadOnlyPropertyCount <= 32,
           Format('Тип %s имеет больше свойств %d чем может (32) AtomClass = %s',
                  [Self.AsString,
                   PropertyCount - ReadOnlyPropertyCount,
                   AtomClass.ClassName
                   ]));
 {$EndIf}                
end;

function __CheckPropExists(P: Pointer): Bool; 
begin
 raise Ek2PropertyAlreadyDefined.CreateFmt(k2_errPropExists,
                                           [Pk2CustomProperty(P)^.TagIndex,
                                            Tk2Type(Pk2CustomProperty(P)^.ParentType).AsString,
                                            Pk2CustomProperty(P)^.AsString]);
 {&Exception&}
end;

function Tk2Type.DefineProperty(aTagIndex       : Long;
                                aPropType       : Tk2Type;
                                const aUserName : AnsiString = ''): Tk2Property;
  {-}

begin
 Result := Tk2Property.Create(Self, aTagIndex, aPropType, aUserName);
 try
  f_Tags.SetItem(aTagIndex, __CheckPropExists, Result);
 except
  l3Free(Result);
  raise;
 end;//try..except
end;

procedure Tk2Type.UndefineProperty(aTagIndex: Long);
  {-}
var
 l_Prop : Tk2CustomProperty;

 function ClearEmptyMapping(aProp: Pk2CustomProperty; Index: Long): Bool; far;
 begin
  if (aProp^ <> l_Prop) then begin
   if (aProp^.EmptyMapping = aTagIndex) then
    aProp^.EmptyMapping := k2_tiMask;
  end;{aProp^ <> l_Prop}
  Result := (Tk2Property(l_Prop).f_MappingTarget > 0);
 end;

begin
 l_Prop := Tk2CustomProperty(Prop[aTagIndex]);
 if (l_Prop <> nil) then begin
  if (l_Prop Is Tk2Property) AND (Tk2Property(l_Prop).f_MappingTarget > 0) then begin
   IteratePropertiesF(l3L2IA(@ClearEmptyMapping));
  end;//(l_Prop Is Tk2Property) AND ..
  f_Tags.DeleteItem(aTagIndex, __FreeProp2);
 end;{l_Prop <> nil}
end;
  
procedure Tk2Type.UndefineProperties(const aTags: array of Long);
  {-}
var
 i : Long;  
begin
 for i := Low(aTags) to High(aTags) do
  UndefineProperty(aTags[i]);
end;

function __CheckChildrenExists(P: Pointer): Bool; far;
begin
 Result := true;
 l3Free(P^);
end;

function Tk2Type.DefineChildrenPrim(aChildType: Tk2Type;
                                    aListType: Tk2Type = nil): Tk2ChildrenProperty;
  {-}
begin
 Result := nil;
 try
  if (aListType = nil) then
   aListType := Self;
  Result := Tk2ChildrenProperty.Create(Self, aChildType, aListType, 'Дочерние теги');
  f_Tags.SetItem(k2_tiChildren, __CheckChildrenExists, Result);
  Self.Recalc;
 except
  l3Free(Result);
  raise;
 end;//try..except
end;

procedure Tk2Type.DefineChildrenPath(aTagType: Tk2Type; const Path : array of Long);
  {-}
var
 CA : Tk2ChildrenPathList;
 CP : Tk2ChildrenPath;
begin
 CA := f_ChildrenPath.Use;
 try
  if (CA = nil) then
  begin
   CA := Tk2ChildrenPathList.MakeSorted;
   l3Set(f_ChildrenPath, CA);
  end;//CA = nil
  CP := Tk2ChildrenPath.Create;
  try
   CP.TagType := aTagType;
   CP.Path := l3LongArray(Path);
   CA.Add(CP);
  finally
   l3Free(CP);
  end;{try..finally}
 finally
  l3Free(CA);
 end;{try..finally}
end;

function Tk2Type.FindChildPath(aTagType: Tk2TypePrim): TLongArray;
  {-}
var
 i  : Long;
 CP : Tk2ChildrenPathList;
begin
 if (f_LastChildPath.rTypeID = aTagType.ID) then
  Result := f_LastChildPath.rPath
 else
 begin
  CP := f_ChildrenPath;
  if CP.Empty then
   Result := nil
  else
  begin
   if CP.FindData(aTagType, i) then
    Result := Tk2ChildrenPath(CP[i]).Path
   else
    Result := nil;
  end;//CP.Empty
  f_LastChildPath.rTypeID := aTagType.ID;
  f_LastChildPath.rPath := Result;
 end;//f_LastChildPath.rTypeID = aTagType.ID
end;

function Tk2Type.DoMakeTag(aType: Tk2Type): Ik2Tag;
  //virtual;
  {* - создает атом данного типа. }
begin
 Result := f_Wrapper.New(aType);
end;

function Tk2Type.MakeTag: Ik2Tag;
  {* - создает атом данного типа. }
begin
 Result := DoMakeTag(Self);
 Assert(Result <> nil);
end;

procedure Tk2Type.AddValue(const aValue: Ik2Tag);
var
 l_VT : Tk2Dictionary;
begin
 if (ValueTable = nil) then
 begin
  l_VT := Tk2Dictionary.MakeSorted;
  try
   ValueTable := l_VT;
  finally
   l3Free(l_VT);
  end;//try..finally
 end;//ValueTable = nil
 {$IfOpt D+}
 ValueTable.Add(aValue.AsObject As Tl3PrimString);
 {$Else}
 ValueTable.Add(Tl3PrimString(aValue.AsObject));
 {$EndIf}
end;

function Tk2Type.IntToTag(aValue : Integer): Ik2Tag;
  {-}
begin
 if (aValue = k2_TransparentValue) then
  Result := TransparentTag
 else
 if (f_Wrapper = nil) then
 begin
  if IsOrd then
   Result := TagFromIntRef(aValue)
  else
   Result := k2NullTag;
 end//f_Wrapper = nil
 else
 begin
  if IsOrd then
   Result := TagFromIntRef(aValue)
  else
   Result := f_Wrapper.IntToTag(aValue);
 end;//f_Wrapper = nil
end;

function Tk2Type.BoolToTag(aValue : Boolean): Ik2Tag;
  {-}
begin
 if (f_Wrapper = nil) then
 begin
  if IsOrd then
   Result := TagFromIntRef(Ord(aValue))
  else
   Result := k2NullTag;
 end//f_Wrapper = nil
 else
 begin
  if IsOrd then
   Result := TagFromIntRef(Ord(aValue))
  else
   Result := f_Wrapper.BoolToTag(aValue);
 end;//f_Wrapper = nil
end;

function Tk2Type.PCharLenToTag(const aValue : Tl3PCharLen): Ik2Tag;
  {-}
var
 l_S : Tl3String;
begin
 if l3IsNil(aValue) then
  Result := k2NullTag
 else
 begin
  l_S := Tl3String.Make(aValue);
  try
   Result := ObjToTag(l_S);
  finally
   l3Free(l_S);
  end;//try..finally
 end;//l3IsNil(Value)
end;

function Tk2Type.StrToTag(const aValue : AnsiString): Ik2Tag;
  {-}
begin
 if (f_Wrapper = nil) then
 begin
  if IsOrd then
   Result := TagFromIntRef(StrToInt(aValue))
  else
   Result := k2NullTag;
 end//f_Wrapper = nil
 else
  Result := f_Wrapper.StrToTag(aValue);
end;

function Tk2Type.ObjToTag(aValue: TObject): Ik2Tag;
  {-}
begin
 Result := f_Wrapper.ObjToTag(aValue);
end;

function Tk2Type.IUnknownToTag(const aValue : IUnknown): Ik2Tag;
  {-}
begin
 if Supports(aValue, Ik2Tag, Result) then
  Exit;
 Assert(AtomType <> nil);
 Assert(AtomType.Kind = tkInterface);
 Result := TagFromIntRef(Long(aValue));
end;

function Tk2Type.TagFromIntRef(aRef : Integer): Ik2Tag;
  {-}
var
 l_Len : Integer;
 l_AT  : PTypeInfo;
 l_C   : TClass;
 l_IE  : PInterfaceEntry;
begin
 l_AT := AtomType;
 if (l_AT = nil) then
  Result := k2NullTag
 else
 begin
  if (aRef = k2_TransparentValue) then
   Result := TransparentTag
  else
  Case l_AT.Kind of
   tkInteger,
   tkEnumeration,
   tkChar:
   begin
    if (aRef >= 0) AND (aRef <= 1024) then
    begin
     l_Len := Length(f_Cache);
     if (aRef >= l_Len) then
     begin
      SetLength(f_Cache, Succ(aRef));
      Pointer(f_Cache[aRef]) := Pointer(Ik2Tag(Tk2AtomicTag.Create(aRef, Self)));
     end//aRef >= l_Len
     else
     if (f_Cache[aRef] = nil) then
      Pointer(f_Cache[aRef]) := Pointer(Ik2Tag(Tk2AtomicTag.Create(aRef, Self)));
     Result := f_Cache[aRef];
     Exit;
    end;//(aRef >= 0) AND (aRef <= 1024)
    Result := nil;
    Pointer(Result) := Pointer(Ik2Tag(Tk2AtomicTag.Create(aRef, Self)));
   end;//tkInteger..
   tkClass :
   begin
    if (aRef = 0) then
     Result := k2NullTag
    else
    begin
     l_C := GetTypeData(l_AT)^.ClassType;
     if (f_IntfOffset <> -1) then
      if (l_C = TObject(aRef).ClassType) then
      begin
       if (f_IntfOffset = 0) then
       begin
        l_IE := l_C.GetInterfaceEntry(Ik2Tag);
        if (l_IE = nil) then
         f_IntfOffset := -1
        else
        if (l_IE.IOffset = 0) then
         f_IntfOffset := -1
        else
        begin
         f_IntfOffset := l_IE.IOffset;
         Result := nil;
         Pointer(Result) := Pointer(aRef + f_IntfOffset);
         Result._AddRef;
         Exit;
        end;//l_IE.IOffset = 0
       end//f_IntfOffset = 0
       else
       begin
        Result := nil;
        Pointer(Result) := Pointer(aRef + f_IntfOffset);
        Result._AddRef;
        Exit;
       end;//f_IntfOffset = 0
      end;//l_C = TObject(aRef).ClassType
     if (f_IntfOffset <> -1) then
     begin
      if TObject(aRef).GetInterface(Ik2Tag, Result) then
       Exit
      else
       f_IntfOffset := -1;
     end;//f_IntfOffset <> -1
     Result := nil;
     if (TObject(aRef) Is Tl3CustomString) then
      Pointer(Result) := Pointer(Ik2Tag(Tk2StringTag.Create(aRef, Self)))
     else
     if (TObject(aRef) Is Tl3CBase) then
      Pointer(Result) := Pointer(Ik2Tag(Tk2L3ObjectTag.Create(aRef, Self)))
     else
     if (TObject(aRef) Is Tl3Stream) then
      Pointer(Result) := Pointer(Ik2Tag(Tk2L3StreamTag.Create(aRef, Self)))
     else
     if (TObject(aRef) Is TStream) then
      Pointer(Result) := Pointer(Ik2Tag(Tk2StreamTag.Create(aRef, Self)))
     else
     if (TObject(aRef) Is TPersistent) then
      Pointer(Result) := Pointer(Ik2Tag(Tk2PersistentTag.Create(aRef, Self)))
     else
     if (TObject(aRef) Is Tl3MemoryPoolPrim) then
      Pointer(Result) := Pointer(Ik2Tag(Tk2MemoryPoolTag.Create(aRef, Self)))
     else
      Pointer(Result) := Pointer(Ik2Tag(Tk2ObjectTag.Create(aRef, Self)));
    end;//aRef = 0
   end;//tkClass
   tkInterface :
    if (aRef = 0) then
     Result := k2NullTag
    else
    begin
     Result := nil;
     Pointer(Result) := Pointer(Ik2Tag(Tk2IUnknownTag.Create(aRef, Self)));
    end;//aRef = 0
   else
   begin
    Assert(false);
    Result := nil;
   end;//else
  end;//Case l_AT.Kind
 end;//l_AT = nil
end;

function Tk2Type.TransparentTag: Ik2Tag;
  {-}
begin
 Result := Tk2TransparentTag.Make(Self);
end;

// start class Tk2TypeTable

type
 Rk2TypeTable = class of Tk2TypeTable;
var
 g_StandardTypeTableClass : Rk2TypeTable = nil;
 g_StandardTypeTable : Tk2TypeTable = nil;

procedure _FreeSchema;
begin
 FreeAndNil(g_StandardTypeTable);
end;

constructor Tk2TypeTable.Create;
  //virtual;
  {-}
begin
 inherited Create;
 Assert(g_StandardTypeTable = nil, 'Пока не можем определять больше, чем одну EVD-схему');
 Tl3String.Create.Free;
 // - hack - для того чтобы кеш объектов добавился раньше, чем таблица типов
 g_StandardTypeTable := Self.Use;
 l3System.AddExitProc(_FreeSchema);
end;

class procedure Tk2TypeTable.CheckAndCleanupReferences;
  {-}
begin
 if g_StandardTypeTable <> nil then
  k2.SignalEvent(g_StandardTypeTable, k2_eidTypeTableWillBeDestroyed);
end;

class function Tk2TypeTable.GetInstance: Tk2TypeTable;
  {-}
begin
 if (g_StandardTypeTable = nil) then
 begin
  if (g_StandardTypeTableClass = nil) then
   raise Ek2Error.Create('Не определена EVD-схема');
  with l3System do
  begin
   EnterGlobalCS;
   try
    Result := g_StandardTypeTableClass.Create.Free;
   finally
    LeaveGlobalCS;
   end;//try..finally
  end;//with l3System
 end//g_StandardTypeTable = nil
 else
  Result := g_StandardTypeTable;
end;

class procedure Tk2TypeTable.SetAsDefault;
  {-}
begin
 if (g_StandardTypeTableClass <> nil) then
 begin
  if not Self.InheritsFrom(g_StandardTypeTableClass) then
   if g_StandardTypeTableClass.InheritsFrom(Self) then
    Exit
   else 
    raise Ek2Error.Create('Тип схемы ' + Self.ClassName + ' не совместим с ' + g_StandardTypeTableClass.ClassName);
 end;//g_StandardTypeTableClass <> nil
 g_StandardTypeTableClass := Self;
end;  

procedure Tk2TypeTable.BeforeRelease;
  //override;
begin
 k2.SignalEvent(Self, k2_eidTypeTableWillBeDestroyed);
 inherited;
end;

function Tk2TypeTable.DefineType(anID              : Long;
                                 const aTagParents : array of Tk2Type;
                                 const anUserName  : AnsiString = '';
                                 aTypeRef          : Rk2Type = nil): Tk2Type;
  {-}
type
  Rk2ParentedType = class of Tk2Type;
  Rk2MultiParentedType = class of Tk2Type;
var
 l_T0 : Tk2Type;
 l_T1 : Tk2Type;
 AT   : Tk2Type;
 i    : Long;
begin
 Case Length(aTagParents) of
  0:
  begin
   if (aTypeRef = nil) then
    l_T0 := Tk2Type.Create(Self, anUserName)
   else
    l_T0 := aTypeRef.Create(Self, anUserName);
   try
    l_T0.TypeTable := Self;
    l_T0.StringID := anID;
    Result := l_T0;
   except
    l3Free(l_T0);
    raise;
   end;//try..except
  end;//0
  1:
  begin
   if (aTypeRef = nil) then
   begin
    l_T1 := nil;
    Assert(false);
   end//aTypeRef = nil
   else
   begin
    l_T1 := Rk2ParentedType(aTypeRef).Create(Self, anUserName);
   end;//aTypeRef = nil
   try
    l_T1.StringID := anID;
    l_T1.InheriteFrom(aTagParents[0]);
    Result := l_T1;
   except
    l3Free(l_T1);
    raise;
   end;//try..except
  end;//1
  else
  begin
   if (aTypeRef = nil) then
   begin
    AT := nil;
    Assert(false);
   end//aTypeRef = nil
   else
   begin
    AT := Rk2MultiParentedType(aTypeRef).Create(Self, anUserName);
   end;//aTypeRef = nil
   try
    AT.StringID := anID;
    for i := High(aTagParents) downto Low(aTagParents) do
     AT.InheriteFrom(aTagParents[i]);
    Result := AT;
   except
    l3Free(AT);
    raise;
   end;//try..except
  end;//else
 end;//Case Length(aTagParents)  
end;

function Tk2TypeTable.ObjToTag(aValue : TObject): Ik2Tag;
  {-}
begin
 if (aValue = nil) then
  Result := k2NullTag
 else
 begin
  if not aValue.GetInterface(Ik2Tag, Result) then
(*   if (aValue Is Tl3CBase) then
    Result := Self[k2_idl3Base].TagFromIntRef(Long(aValue))
   else*)
    Result := Self[k2_idObject].TagFromIntRef(Long(aValue));
 end;//O = nil
end;

function Tk2TypeTable.pm_GetTypeByHandlePrim(H: Long): Tk2TypePrim;
begin
 Result := pm_GetTypeByHandle(H);
end;

function Tk2TypeTable.pm_GetTypeByHandle(H: Long): Tk2Type;
  {-}
begin
 Result := nil;
 {$IfDef Nemesis}
 {$IfNDef OutEVDSchema}
// Комментарим для избежания выброса этого исключения на аварийном завершении K-139436640
(*
 if (H > 0) then
  if not l3SystemDown then
   raise Ek2Error('Тип №' + IntToStr(H) + ' не определён');
*)
 {$EndIf  OutEVDSchema}
 {$EndIf Nemesis}
end;

// start class Tk2InterfaceFactory 

procedure Tk2InterfaceFactory.Cleanup;
  {override;}
  {-}
begin
 f_Interfaces.Clear;
 inherited;
end;

function Tk2InterfaceFactory.LoadTool(const ID: Tl3IID): Tk2ToolPrim;
  {override;}
  {-}
begin
 Result := f_Interfaces.GetInterface(ID);
end;

function Tk2InterfaceFactory.StoreTool(const ID: Tl3IID; I: Tk2ToolPrim): Bool;
  {override;}
  {-}
begin
 if I.StoreToOldCache then
 begin
  f_Interfaces.SetInterface(ID, I);
  Result := true;
 end//I.StoreToOldCache
 else
  Result := false;
end;

function Tk2InterfaceFactory.QueryTool(const aTag : Ik2Tag;
                                       const ID   : Tl3IID;
                                       out I      : Tk2ToolPrim): Bool;
  {override;}
  {-}
begin
 I := nil;
 Result := false;
end;

procedure Tk2InterfaceFactory.IterateCursors(Action: Ik2InterfaceFactory_IterateCursors_Action);
  {-}
const
  ev_iidCursor : Tl3IID = (IID: 0);
    {* - курсор объекта. }
begin
 f_Interfaces.IterateInterfaces(ev_iidCursor, Action);
end;

procedure Tk2InterfaceFactory.IterateCursorsF(Action: Ik2InterfaceFactory_IterateCursors_Action);
  {-}
begin
 try
  IterateCursors(Action);
 finally
  l3FreeIA(Tl3IteratorAction(Action));
 end;//try..finally
end;

// start object Tk2InterfaceList

function Tk2InterfaceList.SetItem(const ID: Tl3IID; Item: Tl3SimpleObject): PObject;
  {-}
begin
 Result := f_I.SetItem(ID.IID, Item);
end;

function Tk2InterfaceList.GetItemP(const ID: Tl3IID): PObject;
  {-}
begin
 Result := f_I.GetItemP(ID.IID);
end;

function Tk2InterfaceList.GetItem(const ID: Tl3IID): Tl3SimpleObject;
  {-}
begin
 PObject(Result) := GetItemP(ID);
 if (Result <> nil) then
  Result := Tl3SimpleObject(PObject(Result)^);
end;

procedure Tk2InterfaceList.Clear;
  {-}
begin
 f_I.Clear;
end;

// start class Tk2InterfaceCacheList 

type
  Tk2ToolCacheList = class(Tl3_CBaseRefList)
    public
    // public methods
      function  GetFree: Tl3CBase;
        {-}
  end;//Tk2ToolCacheList

function Tk2ToolCacheList.GetFree: Tl3CBase;
  {-}

type
 Pl3_CBase = ^Tl3CBase;

 function _GetFree(O: Pl3_CBase; Index: Long): Bool; 
 begin{_GetFree}
  if (O^.RefCount = 1) then
  begin
   GetFree := O^;
   Result := false;
  end//O^.RefCount = 1
  else
   Result := true;
 end;{_GetFree}

begin
 Result := nil;
 if not Empty then
  IterateAllF(l3L2IA(@_GetFree));
end;

// start object Tk2InterfaceCache

function Tk2InterfaceCache.GetInterface(const ID: Tl3IID): Tk2ToolPrim;
  {-}
begin
 Result := Tk2ToolPrim(Tk2ToolCacheList(GetItem(ID)).GetFree);
end;

procedure Tk2InterfaceCache.IterateInterfaces(const ID: Tl3IID; Action: Tl3IteratorAction);
  {-}
var
 i    : Long;
 Intf : Tl3CBase;
 L    : Tk2ToolCacheList;
 L1   : Tl3_CBaseRefCacheableList;
begin
 if Assigned(Action) then
 begin
  L := Tk2ToolCacheList(GetItem(ID));
  if not L.Empty then
  begin
   L1 := Tl3_CBaseRefCacheableList.Make;
   try
    for i := L.Lo to L.Hi do
    begin
     Intf := L.Items[i];
     if (Intf.RefCount > 1) then
      L1.Add(Intf);
    end;//for i
    L1.IterateAll(Action);
   finally
    l3Free(L1);
   end;//try..finally
  end;//not L.Empty
 end;//Assigned(Action)
end;

procedure Tk2InterfaceCache.SetInterface(const ID: Tl3IID; Item: Tk2ToolPrim);
  {-}
var
 L : Tk2ToolCacheList;
begin
 L := GetItem(ID).Use;
 try
  if (L = nil) then
  begin
   L := Tk2ToolCacheList.Make;
   SetItem(ID, L);
  end;//L = nil
  L.Add(Item);
 finally
  l3Free(L);
 end;//try..except
end;

// start class Tk2TagBase

function Tk2TagBase.Box: Ik2Tag;
  //virtual;
  {* - ссылка на тег - для сохранения. }
begin
 Result := Self;
end;

function Tk2TagBase.pm_GetChild(anIndex: Long): Ik2Tag;
  //virtual;
  {-}
begin
 Result := k2NullTag;
end;

function Tk2TagBase.pm_GetChildrenCount: Long;
  //virtual;
  {* - количество детей. }
begin
 Result := 0;
end;

procedure Tk2TagBase.Set_ChildrenCapacity(aValue: Integer);
  {-}
begin
 Assert(false);
end;

procedure Tk2TagBase.pm_SetAttr(anIndex: Long; const aValue : Ik2Tag);
  {-}
begin
 pm_SetAttrW(anIndex, nil, aValue);
end;

function Tk2TagBase.IntRef: Integer;
  //override;
  {-}
begin
 Result := GetValue;
end;

procedure Tk2TagBase.SetIntRef(out aRef: Integer);
  //override;
  {-}
begin
 aRef := GetValue;
end;

function Tk2TagBase.CloneTag: Ik2Tag;
  {-}
begin
 Result := f_Type.MakeTag;
 Result.AssignTag(Self);
end;

function Tk2TagBase.IsNull: Boolean;
  {-}
begin
 Result := false;
end;

function Tk2TagBase.IsValid: Boolean;
  {-}
begin
 Result := true;
end;

function Tk2TagBase.IsTransparent: Boolean;
  //virtual;
  {-}
begin
 Result := false;
end;

function Tk2TagBase.IsOrd: Boolean;
  //virtual;
  {-}
begin
 Result := false;
end;

function Tk2TagBase.IsStream(out theStream: IStream): Boolean;
  //virtual;
  {-}
begin
 Result := false;
end;

function Tk2TagBase.InheritsFrom(ID: Long): Bool;
  {* - проверяет наследование данного типа от типа с идентификатором ID. }
begin
 Result := f_Type.InheritsFrom(ID);
end;

function Tk2TagBase.InheritsFrom(anAtomTypeID  : Long;
                                 const Exclude : array of Long): Bool;
  //overload;
  {* - проверить наследование. }
begin
 Result := f_Type.InheritsFrom(anAtomTypeID, Exclude);
end;

function Tk2TagBase.InheritsFrom(const anIDs : array of Long): Bool;
  //overload;
  {* - проверить наследование. }
begin
 Result := f_Type.InheritsFrom(anIDs);
end;

function Tk2TagBase.AsObject: TObject;
  {-}
begin
 Result := nil;
end;

function Tk2TagBase.pm_GetAsString: AnsiString;
  //override;
  {-}
begin
 Result := f_Type.Wrapper.AsString(Self);
end;

function Tk2TagBase.pm_GetAsPCharLen: Tl3PCharLen;
  //override;
  {* - преобразовать к Tl3PCharLen. }
begin
 Result := (AsObject As Tl3CustomString).AsPCharLen;
end;

function Tk2TagBase.AssignTag(const Source  : Ik2Tag;
                              AssignMode    : Tk2AssignModes = k2_amAll;
                              const Context : Ik2Op = nil): Bool;
  //virtual;
  {-}
begin
 Result := false;
 Assert(false);
end;

function Tk2TagBase.HasSubAtom(anIndex: Long): Bool;
  //virtual;
  {-}
begin
 Result := false;
end;

function Tk2TagBase.rLong(anIndex  : Long;
                          aDefault : Long): Long;
  //overload;
  //virtual;
  {-}
begin
 Result := aDefault;
end;

function Tk2TagBase.rBool(anIndex  : Long;
                          aDefault : Boolean): Boolean;
  //virtual;
  {-}
begin
 Result := aDefault;
end;

function Tk2TagBase.rOwnAtom(anIndex: Long): Ik2Tag;
  //virtual;
  {-}
begin
 Result := k2NullTag;
end;

function Tk2TagBase.pm_GetAttr(anIndex : Long): Ik2Tag;
  //overload;
  //virtual;
  {-}
begin
 Result := k2NullTag;
end;

function Tk2TagBase.rAtomEx(const Path : array of Long;
                            theIndex   : PLong = nil): Ik2Tag;
  //overload;
  //virtual;
  {* - вернуть подтег. }
begin
 Result := k2NullTag;
end;

procedure Tk2TagBase.pm_SetAttrW(anIndex  : Integer;
                                 const aContext : Ik2Op;
                                 const aValue   : Ik2Tag);
  {* - изменить значение. }
var
 l_Prop : Tk2Prop;
begin
 if (f_Type <> nil) then
 begin
  l_Prop := Tk2CustomProperty(f_Type.Prop[anIndex]);
  if (l_Prop <> nil) then
   SetSubAtom(l_Prop, aValue, aContext);
 end;//f_Type <> nil
end;

procedure Tk2TagBase.ForceStore;
  {-}
begin
end;

function Tk2TagBase.pm_GetBoolA(anIndex  : Integer): Boolean;
  {-}
begin
 Result := rBool(anIndex, false);
end;

procedure Tk2TagBase.pm_SetBoolA(anIndex  : Integer;
                                 aValue   : Boolean);
  {-}
begin
 pm_SetBoolW(anIndex, nil, aValue);
end;

function Tk2TagBase.pm_GetIntA(anIndex  : Integer): Integer;
  {-}
begin
 Result := rLong(anIndex, 0);
end;

procedure Tk2TagBase.pm_SetIntA(anIndex  : Integer;
                                aValue   : Integer);
  {* - изменить значение. }
begin
 pm_SetIntW(anIndex, nil, aValue);
end;

procedure Tk2TagBase.pm_SetBoolW(anIndex  : Integer;
                                  const aContext : Ik2Op;
                                  aValue   : Boolean);
  {* - изменить значение. }
var
 l_Prop : Tk2CustomProperty;
begin
 l_Prop := Tk2CustomProperty(f_Type.Prop[anIndex]);
 if (l_Prop <> nil) then
  Assert(false);
end;

procedure Tk2TagBase.pm_SetIntW(anIndex        : Integer;
                                 const aContext : Ik2Op;
                                 aValue   : Integer);
  {* - изменить значение. }
var
 l_Prop : Tk2CustomProperty;
begin
 l_Prop := Tk2CustomProperty(f_Type.Prop[anIndex]);
 if (l_Prop <> nil) then
  SetIntWC(l_Prop, aContext, aValue);
end;

procedure Tk2TagBase.pm_SetObjW(anIndex  : Integer;
                                const aContext : Ik2Op;
                                aValue         : TObject);
  {-}
var
 l_Prop : Tk2Prop;
begin
 if (f_Type <> nil) then
 begin
  l_Prop := Tk2CustomProperty(f_Type.Prop[anIndex]);
  if (l_Prop <> nil) then
   SetSubAtom(l_Prop, Tk2Type(l_Prop.AtomType).ObjToTag(aValue), aContext);
 end;//f_Type <> nil
end;

procedure Tk2TagBase.SetIntWC(aProp    : Tk2CustomProperty;
                              const aContext : Ik2Op;
                              aValue         : Integer);
  //virtual;
  {* - изменить значение. }
begin
 Assert(false);
end;
  
function Tk2TagBase.pm_GetStrA(anIndex  : Integer): AnsiString;
  {-}
begin
 Result := pm_GetAttr(anIndex).AsString;
end;

procedure Tk2TagBase.pm_SetStrA(anIndex  : Integer;
                                const aValue   : AnsiString);
  {* - изменить значение. }
begin
 pm_SetStrW(anIndex, nil, aValue);
end;

function Tk2TagBase.pm_GetPCharLenA(anIndex      : Integer): Tl3PCharLen;
  {-}
begin
 Result := pm_GetAttr(anIndex).AsPCharLen;
end;

procedure Tk2TagBase.pm_SetPCharLenA(anIndex      : Integer;
                                     const aValue : Tl3PCharLen);
  {* - изменить значение. }
begin
 pm_SetPCharLenW(anIndex, nil, aValue);
end;

procedure Tk2TagBase.pm_SetStrW(anIndex  : Integer;
                                 const aContext : Ik2Op;
                                 const aValue   : AnsiString);
  {* - изменить значение. }
begin
 pm_SetPCharLenW(anIndex, aContext, l3PCharLen(aValue));
end;

procedure Tk2TagBase.pm_SetPCharLenW(anIndex  : Integer;
                                      const aContext : Ik2Op;
                                      const aValue   : Tl3WString);
  {* - изменить значение. }
var
 l_Prop : Tk2Prop;
begin
 if (f_Type <> nil) then
 begin
  l_Prop := Tk2CustomProperty(f_Type.Prop[anIndex]);
  if (l_Prop <> nil) then
   SetSubAtom(l_Prop, Tk2Type(l_Prop.AtomType).PCharLenToTag(Tl3PCharLen(aValue)), aContext);
 end;//f_Type <> nil
end;

function Tk2TagBase.cAtom(anIndex        : Long;
                          const aContext : Ik2Op = nil;
                          anAtomType: Tk2TypePrim = nil): Ik2Tag;
  //overload;
  {* - проверить существование подтега и создать его при необходимости. }
begin
 Result := cAtomEx([anIndex], aContext);
end;

function Tk2TagBase.cAtomEx(const aPath    : array of Long;
                            const aContext : Ik2Op;
                            theIndex       : PLong = nil): Ik2Tag;
  //virtual;
  {* - проверить существование подтега и создать его при необходимости. }
begin
 Result := k2NullTag;
end;

procedure Tk2TagBase.SetSubAtom(const aProp    : Tk2Prop;
                               const aSubAtom : Ik2Tag;
                               const Context  : Ik2Op);
  //virtual;
  {-}
begin
end;

procedure Tk2TagBase.AssignCloneParams(const aSource : Ik2Tag;
                                       AssignMode    : Tk2AssignModes = k2_amAll;
                                       const Context : Ik2Op = nil);
  {-}
begin
 Assert(false);
end;

procedure Tk2TagBase.IterateProperties(Action : Ik2Tag_IterateProperties_Action;
                                       All    : Bool);
  {* - перебирает все существующие свойства. }
begin
 Assert(false);
end;

{iterator} procedure Tk2TagBase.IteratePropertiesF(anAction: Ik2Tag_IterateProperties_Action;
  anAll: Boolean
  {* Перебирать все возможные свойства или только РЕАЛЬНО заданные});
var
 Hack : Pointer absolute anAction;
begin
 try
  IterateProperties(anAction, anAll);
 finally
  l3FreeLocalStub(Hack);
 end;//try..finally
end;

function Tk2TagBase.CompareWithInt(aValue: Integer;
 anIndex: Integer): Integer;
  {* Сравнивает тег с целым. }
begin
 Assert(false);
 Result := -1;
end;

function Tk2TagBase.CompareWithTag(const aTag: Ik2Tag;
 aSortIndex: Tl3SortIndex): Integer;
begin
 Assert(false);
 Result := -1;
end;

function Tk2TagBase.pm_GetTagType: Tk2TypePrim;
  //virtual;
  {-}
begin
 Result := f_Type;
end;

function Tk2TagBase.AddChild(var aChild     : Ik2Tag;
                             const aContext : Ik2Op = nil): Long;
  //virtual;
  {* - добавить ребенка. }
begin
 Result := -1;
end;

function Tk2TagBase.IndexOfChild(const aChild: Ik2Tag): Integer;
  //virtual;
  {-}
begin
 Result := -1;
end;

function Tk2TagBase.DeleteChild(Index         : Long;
                      const Context : Ik2Op = nil): Boolean;
  //overload;
  {* - удалить ребенка. }
var
 l_Child : Ik2Tag;
begin
 Result := DeleteChild(Index, Context, l_Child);
end;

function Tk2TagBase.DeleteChild(const aChild  : Ik2Tag;
                                const Context : Ik2Op = nil): Boolean;
  //overload;
  {* - удалить ребенка. }
var
 l_Index : Integer;
begin
 l_Index := IndexOfChild(aChild);
 if (l_Index >= 0) then
  Result := DeleteChild(l_Index, Context)
 else
  Result := false; 
end;

function Tk2TagBase.IterateChildren(Action : Ik2Tag_IterateChildrenF_Action;
                                    aLo    : Tl3Index = l3MinIndex;
                                    aHi    : Tl3Index = l3MaxIndex;
                                    aLoadedOnly : Boolean = false): Long;
  //overload;
  //virtual;
  {* - перебрать детей. }
begin
 Result := -1;
end;

function Tk2TagBase.IterateChildrenF(Action : Ik2Tag_IterateChildrenF_Action;
                                     aLo    : Tl3Index = l3MinIndex;
                                     aHi    : Tl3Index = l3MaxIndex;
                                     aLoadedOnly : Boolean = false): Long;
  {* - перебрать детей с освобождением заглушки. }
begin
 try
  Result := IterateChildren(Action, aLo, aHi, aLoadedOnly);
 finally
  k2FreeTIA(Action);
 end;//try..finally
end;

function Tk2TagBase.IterateChildrenBack(Action : Ik2Tag_IterateChildrenBack_Action;
                                        aHi    : Tl3Index = l3MaxIndex;
                                        aLo    : Tl3Index = l3MinIndex;
                                        aLoadedOnly : Boolean = false): Long;
  //virtual;
  {* - перебрать детей. }
begin
 Result := -1;
end;

function Tk2TagBase.IterateChildrenBackF(Action : Ik2Tag_IterateChildrenBack_Action;
                                         aHi    : Tl3Index = l3MaxIndex;
                                         aLo    : Tl3Index = l3MinIndex;
                                         aLoadedOnly : Boolean = false): Long;
  {* - перебрать детей с освобождением заглушки. }
begin
 try
  Result := IterateChildrenBack(Action, aHi, aLo, aLoadedOnly);
 finally
  k2FreeTIA(Ik2Tag_IterateChildrenF_Action(Action));
 end;//try..finally
end;

function Tk2TagBase.GetOwnInterface(const IID: TGUID; out Obj): Boolean;
  {* - возвращает интерфейс НЕПОСРЕДСТВЕННО поддерживаемый реализацией
       инструмента. }
begin
 Result := GetInterface(IID, Obj);
end;

function Tk2TagBase.GetLinkedInterface(const IID: TGUID; out Obj): Boolean;
  {-}
begin
 Result := GetOwnInterface(IID, Obj);
end;

function Tk2TagBase.QT(const IID        : TGUID;
                       out Obj          ;
                       const aProcessor : Ik2Processor): Boolean;
  {* - созвращает инструмент для работы с данным тегом. }
var
 l_Factory : Ik2TagToolFactory;
begin
 Result := false;
 Pointer(Obj) := nil;
 if (f_Type <> nil) then
 begin
  l_Factory := f_Type.ToolFactory;
  if (l_Factory <> nil) then
   try
    Result := l_Factory.QueryTool(Self, IID, Obj, aProcessor);
   finally
    l_Factory := nil;
   end;//try..finally
 end;//f_Type <> nil
end;

procedure Tk2TagBase.Write(const G : Ik2TagGenerator;
                           Flags   : Tk2StorePropertyFlags = l3_spfAll;
                           Exclude : TByteSet = []);
  //virtual;
  {* - записать тег в генератор. }
begin
 Assert(false);
end;

procedure Tk2TagBase.DoLoad;
  {-}
begin
end;

function Tk2TagBase.MarkModified: Boolean;
  {-}
begin
 Result := false;
end;

procedure Tk2TagBase.CheckSort(aProp: Tk2ArrayPropertyPrim);
  {-}
begin
end;

function Tk2TagBase.FindChild(anAtom         : Integer;
                              aValue         : Integer;
                              const aContext : Ik2Op = nil;
                              aNeedCreate    : Boolean = false;
                              theIndex       : PLong = nil): Ik2Tag;
  //virtual;
  {-}
begin
 Result := k2NullTag;
 if (theIndex <> nil) then
  theIndex^ := -1;
end;

procedure Tk2TagBase.ClearAtoms;
  {-}
begin
end;

function Tk2TagBase.Get_Owner: Ik2Tag;
  //override;
  {-}
begin
 Result := k2NullTag;
end;

procedure Tk2TagBase.Set_Owner(const aValue: Ik2Tag);
  //override;
  {-}
begin
end;

function Tk2TagBase.AsBool: Bool;
  //override;
  {* - преобразовать к Bool. }
begin
 Result := f_Type.Wrapper.AsBool(Self);
end;

constructor Tk2TagBase.Create(aValue      : Long;
                                const aType : Tk2Type);
  //reintroduce;
  {-}
begin
 inherited Create;
 f_Type := aType;
 SetValue(aValue);
end;

procedure Tk2TagBase.Cleanup;
  //override;
  {-}
begin
 SetValue(0);
 inherited;
end;

function Tk2TagBase.IsSame(const aTag: Ik2Tag): Bool;
  {* - проверяет эквивалентность двух хранилищ. }
begin
 if (aTag = nil) OR not aTag.IsValid then
  Result := false
 else
  Result := (GetValue = aTag.IntRef) AND f_Type.IsSame(aTag.TagType);
end;

function Tk2TagBase.AsLong: Long;
  //override;
  {-}
begin
 Result := f_Type.Wrapper.AsLong(Self);
end;

// start class Tk2IUnknownTag

procedure Tk2IUnknownTag.SetIntRef(out aRef: Integer);
  //override;
  {-}
begin
 aRef := 0;
 IUnknown(aRef) := f_IUnknown;
end;

function Tk2IUnknownTag.GetValue: Long;
  //override;
  {-}
begin
 Result := Long(f_IUnknown);
end;

procedure Tk2IUnknownTag.SetValue(aValue: Long);
  //override;
  {-}
begin
 f_IUnknown := IUnknown(aValue);
end;

function Tk2IUnknownTag.COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
  //override;
  {-}
begin
 Result := inherited COMQueryInterface(IID, Obj);
 if Result.Fail then
  Result := Tl3HResult_C(f_IUnknown.QueryInterface(IID.IID, Obj));
end;

// start class Tk2ObjectTag

function Tk2ObjectTag.pm_GetChild(anIndex: Long): Ik2Tag;
  //override;
  {-}
begin
 Result := pm_GetAttr(k2_tiChildren).Child[anIndex];
end;

function Tk2ObjectTag.pm_GetChildrenCount: Long;
  //override;
  {* - количество детей. }
begin
 Result := pm_GetAttr(k2_tiChildren).ChildrenCount;
end;

function Tk2ObjectTag.AsObject: TObject;
  //override;
  {-}
begin
 Result := f_Object;
end;

function Tk2ObjectTag.rLong(anIndex  : Long;
                            aDefault : Long): Long;
  //override;
  {-}
var
 l_Prop  : Tk2CustomProperty;
 l_Value : Long;
 l_Attr  : Ik2Tag;
 l_AT    : Tk2Type;
begin
 l_Prop := Tk2CustomProperty(f_Type.Prop[anIndex]);
 if (l_Prop = nil) then
  Result := aDefault
 else
 if GetAttrValue(l_Prop, l_Value, l_Attr, false) then
 begin
  if (l_Attr = nil) then
  begin
   l_AT := Tk2Type(l_Prop.AtomType);
   if l_AT.IsOrd then
    Result := l_Value
   else
    Result := l_AT.TagFromIntRef(l_Value).AsLong;
  end//l_Attr = nil
  else
   Result := l_Attr.AsLong;
 end//GetAttrValue
 else
  Result := aDefault;
end;

function Tk2ObjectTag.rBool(anIndex  : Long;
                            aDefault : Boolean): Boolean;
  //override;
  {-}
var
 l_Prop  : Tk2CustomProperty;
 l_Value : Long;
 l_Attr  : Ik2Tag;
 l_AT    : Tk2Type;
begin
 l_Prop := Tk2CustomProperty(f_Type.Prop[anIndex]);
 if GetAttrValue(l_Prop, l_Value, l_Attr, false) then
 begin
  if (l_Attr = nil) then
  begin
   l_AT := Tk2Type(l_Prop.AtomType);
   if l_AT.IsOrd then
    Result := (l_Value <> 0) 
   else
    Result := l_AT.TagFromIntRef(l_Value).AsBool;
  end//l_Attr = nil
  else
   Result := l_Attr.AsBool;
 end//GetAttrValue
 else
  Result := aDefault;
end;

function Tk2ObjectTag.rOwnAtom(anIndex: Long): Ik2Tag;
  //override;
  {-}
var
 l_Value : Long;
 l_Attr  : Ik2Tag;
 l_Prop  : Tk2CustomProperty;
begin
 l_Prop := Tk2CustomProperty(f_Type.Prop[anIndex]);
 if GetAttrValue(l_Prop, l_Value, l_Attr, true) then
 begin
  if (l_Attr = nil) then
   Result := Tk2Type(l_Prop.AtomType).TagFromIntRef(l_Value)
  else
   Result := l_Attr;
 end
 else
  Result := k2NullTag;
end;

function Tk2ObjectTag.pm_GetAttr(anIndex : Long): Ik2Tag;
  //override;
  {-}
var
 l_Value : Long;
 l_Attr  : Ik2Tag;
 l_Prop  : Tk2CustomProperty;
begin
 l_Prop := Tk2CustomProperty(f_Type.Prop[anIndex]);
 if GetAttrValue(l_Prop, l_Value, l_Attr, false) then
 begin
  if (l_Attr = nil) then
   Result := Tk2Type(l_Prop.AtomType).TagFromIntRef(l_Value)
  else
   Result := l_Attr;
 end
 else
  Result := k2NullTag;
end;

function Tk2ObjectTag.rAtomEx(const aPath : array of Long;
                              theIndex    : PLong = nil): Ik2Tag;
  //override;
  {* - вернуть подтег. }
begin
 Result := CheckAttr(aPath, nil, false, theIndex);
end;

function Tk2ObjectTag.cAtomEx(const aPath    : array of Long;
                              const aContext : Ik2Op;
                              theIndex       : PLong = nil): Ik2Tag;
  //override;
  {* - проверить существование подтега и создать его при необходимости. }
begin
 Result := CheckAttr(aPath, aContext, true, theIndex);
end;

function Tk2ObjectTag.AddChild(var aChild     : Ik2Tag;
                               const aContext : Ik2Op = nil): Long;
  //override;
  {* - добавить ребенка. }
var
 l_Path       : TLongArray;
 l_ACList     : Ik2Tag;
 l_CList      : Tk2TagList;
 l_Prop       : Tk2ArrayProperty;
begin
 l_Prop := f_Type.ArrayProp[k2_tiChildren];
 if (l_Prop = nil) then
 begin
  l_Path := f_Type.FindChildPath(aChild.TagType);
  if (l_Path = nil) then
   raise Ek2CannotAddChild.CreateFmt(k2_errNoChildren,
                                     [f_Type.AsString, aChild.TagType.AsString])
  else
   Result := cAtomEx(l_Path, aContext).AddChild(aChild, aContext);
 end//l_Prop = nil
 else
 if not l_Prop.ValidateChild(Self, aChild, aContext, High(Integer)) then
 begin
  l_Path := f_Type.FindChildPath(aChild.TagType);
  if (l_Path = nil) then
   raise Ek2CannotAddChild.CreateFmt(k2_errBadChild,
                                     [aChild.TagType.AsString, l_Prop.ChildType.AsString])
   {&Exception&}
  else
   Result := cAtomEx(l_Path, aContext).AddChild(aChild, aContext);
 end//not l_Prop.ValidateChild(Self, aChild)
 else
 begin
  with Tk2Type(aChild.TagType) do
   if HasProperty[k2_tiChildren] then
    aChild.CheckSort(ArrayProp[k2_tiChildren]);
  l_ACList := _cAttr(l_Prop, aContext);
  l_CList := l_ACList.AsObject As Tk2TagList;
  Result := l_CList.Add(aChild.Box);
  ChildAdded(l_Prop, aChild, Result, l_CList.Count, aContext);
 end;//not l_Prop.ValidateChild(Self, aChild)
end;

procedure Tk2ObjectTag.InsertChild(anIndex        : Long;
                                   var aChild     : Ik2Tag;
                                   const aContext : Ik2Op = nil);
  //override;
  {* - вставить ребенка. }
var
 l_Prop  : Tk2ArrayProperty;
 l_List  : Tk2TagList;
 l_Child : Ik2Tag;
begin
 l_Prop := f_Type.ArrayProp[k2_tiChildren];
 l_Child := aChild;
 if not l_Prop.ValidateChild(Self, l_Child, aContext, anIndex) then
  raise Ek2CannotAddChild.CreateFmt(k2_errBadChild,
                                    [l_Child.TagType.AsString,
                                     l_Prop.ChildType.AsString]);
  {&Exception&}
 l_List := _cAttr(l_Prop).AsObject As Tk2TagList;
 l_List.Insert(anIndex, l_Child.Box);
 ChildAdded(l_Prop, l_Child, anIndex, l_List.Count, aContext);
end;

function Tk2ObjectTag.IndexOfChild(const aChild: Ik2Tag): Integer;
  //override;
  {-}
begin
 Result := pm_GetAttr(k2_tiChildren).IndexOfChild(aChild);
end;

procedure Tk2ObjectTag.DeleteChildren(const Context: Ik2Op = nil);
  //override;
  {* - удалить всех детей. }

var
 AL         : Ik2Tag;
 l_Prop     : Tk2ArrayProperty;

 function DoChild(aChild: PIk2Tag; anIndex: Integer): Boolean;
 begin//
  Result := true;
  Context.Processor.NotifyDelete(AL, l_Prop, aChild^, anIndex, Context);
 end;//DoChild

var
 l_List : Tk2TagList;
begin
 l_Prop := f_Type.ArrayProp[k2_tiChildren];
 if (l_Prop <> nil) then
 begin
  AL := pm_GetAttr(l_Prop.TagIndex);
  if AL.IsValid then
  begin
   l_List := (AL.AsObject As Tk2TagList);
   if Assigned(Context) then
   begin
    if not Context.InIOProcess then
     if l_Prop.NeedMarkModified then
      Context.MarkModified(Self);
    l_List.IterateBackF(High(Tl3Index), Low(Tl3Index), l3L2IA(@DoChild));
    end;//Assigned(Context)..
   l_List.Clear;
  end;//AL.IsValid
 end;//l_Prop <> nil
end;

function Tk2ObjectTag.DeleteChild(Index         : Long;
                                  const Context : Ik2Op;
                                  out theChild  : Ik2Tag): Boolean;
  //override;
  {* - удалить ребенка. }
begin
 theChild := pm_GetChild(Index);
 Result := false;
 Assert(false);
 //Result := f_Type.ArrayProp[k2_tiChildren].DeleteChild(Self, Index, k2NullTag, Context);
end;

function Tk2ObjectTag.IterateChildren(Action : Ik2Tag_IterateChildrenF_Action;
                                      aLo    : Tl3Index = l3MinIndex;
                                      aHi    : Tl3Index = l3MaxIndex;
                                      aLoadedOnly : Boolean = false): Long;
  //override;
  {* - перебрать детей. }
begin
 Result := -1;
 Assert(false);
// Result := Attr[k2_tiChildren].IterateChildren(Action, aLo, aHi, aLoadedOnly);
end;

function Tk2ObjectTag.IterateChildrenBack(Action : Ik2Tag_IterateChildrenBack_Action;
                                          aHi    : Tl3Index = l3MaxIndex;
                                          aLo    : Tl3Index = l3MinIndex;
                                          aLoadedOnly : Boolean = false): Long;
  //override;
  {* - перебрать детей. }
begin
 Result := pm_GetAttr(k2_tiChildren).IterateChildrenBack(Action, aHi, aLo, aLoadedOnly);
end;

(*
procedure Tk2ObjectTag.Write(const G       : Ik2TagGenerator;
                             Flags         : Tk2StorePropertyFlags = l3_spfAll;
                             const Exclude : TByteSet = []);
  //override;
  {* - записать тег в генератор. }
  
 function WriteSubAtom(const aSubAtom: Ik2Tag; const aProp: Ik2Property): Bool; 

  procedure StoreAtom(const Atom : Ik2Tag;
                      anID       : Long;
                      aShared    : Boolean);
  begin//StoreAtom
   if not Atom.IsNull then begin
    if Atom.IsTransparent then
     G.AddTransparentAtom(anID)
    else
     Case Atom.TagType.TypeInfo^.Kind of
      tkEnumeration,
      tkInteger:
       G.AddIntegerAtom(anID, Atom.AsLong);
      tkString:
       G.AddStringAtom(anID, Atom.AsString);
      tkClass:
       G.AddObjectAtom(anID, Atom.AsObject, aShared);
      else
       ConvertError(Atom.TagType.Name, '<Valid Atom Type>');
     end;{Case..}
   end;{not Atom.IsNull}
  end;//StoreAtom

  function WriteChild(const aChild: Ik2Tag; ChildIndex: Long): Bool; far;
  var
   l_ValueProp : Ik2Property;
  begin{WriteChild}
   if (aProp As Ik2ArrayProperty).GetStoredChild(Self, aChild, G.Context) then
   begin
    l_ValueProp := aChild.TagType.Prop[k2_tiValue];
    if (l_ValueProp = nil) then
    begin
     G.StartChild(aChild.TagType.ID);
     try
      aChild.Write(G, Flags + l3_spfInner);
     finally
      G.Finish;
     end;//try..finally
    end//aChild.TagType.Prop[k2_tiValue] = nil
    else
     StoreAtom(aChild.Attr[k2_tiValue], -(aProp As Ik2ArrayProperty).ChildType.ID, false);
   end;//(l_Prop As Ik2ArrayProperty).GetStoredChild
   Result := true;
  end;{WriteChild}

 var
  AT  : Ik2Type;

  procedure StoreProp;
  var
   l_IStream : IStream;
   l_Stream  : TStream;
  begin{StoreProp}
   if AT.HasProperties AND
      (AT.Prop[k2_tiValue] = nil) {- это хакерская проверка для строк} then
   begin
    if (l3_spfObjects in Flags) then
    begin
     G.StartTag(aProp.TagIndex);
     try
      aSubAtom.Write(G, Flags + l3_spfInner, []);
     finally
      G.Finish;
     end;{try..finally}
    end;//l3_spfObjects in Flags
   end//AT.HasProperties
   else
   if aSubAtom.IsStream(@l_IStream) then
   begin
    try
     if (l3_spfRawData in Flags) then
     begin
      l3IStream2Stream(l_IStream, l_Stream);
      try
       G.AddStreamAtom(aProp.TagIndex, l_Stream);
      finally
       l3Free(l_Stream);
      end;//try..finally
     end;//l3_spfRawData in Flags
    finally
     l_IStream := nil;
    end;{try..finally}
   end//AT.IsRawData
   else
   if (l3_spfScalars in Flags) then
    StoreAtom(aSubAtom, aProp.TagIndex, aProp.Shared);
  end;//StoreProp

 var
  IDI    : Long;
  HProp  : Ik2Property;
 begin{WriteSubAtom}
  if not (aProp.TagIndex in Exclude) then
  begin
   AT := aProp.AtomType;
   if aProp.GetStored(Self, aSubAtom, G.Context) then
   begin
    if (aProp.TagIndex = k2_tiChildren) then
    begin
     if (l3_spfChildren in Flags) then
     begin
      G.AddIntegerAtom(k2_tiChildren, aSubAtom.ChildrenCount);
      aSubAtom.IterateChildrenF(k2L2TIA(@WriteChild));
     end;//l3_spfChildren in Flags
    end//l_Prop.TagIndex = k2_tiChildren
    else
    begin
     if aProp.Shared then
     begin
      IDI := AT.IDIndex;
      if (IDI <> k2_tiMask) then
      begin
       if (IDI = k2_tiSelfID) then
        StoreProp
       else
       begin
        HProp := AT.Prop[IDI];
        try
         AT := HProp.AtomType;
         StoreAtom(aSubAtom.Attr[IDI], aProp.TagIndex, aProp.Shared);
        except
         on Ek2ConversionError do ;
        end;{try..except}
       end;//IDI = k2_tiSelfID
      end;//IDI <> k2_tiMask
     end//l_Prop.Shared
     else
      StoreProp;
    end;//l_Prop.TagIndex = k2_tiChildren
   end;{l_Prop.GetStored(A, SubAtom}
  end;{not (aProp.TagIndex in Exclude)}
  Result := true;
 end;{WriteSubAtom}

var
 IA : Ik2Tag_IterateProperties_Action;
begin
 if (G <> nil) then
 begin
  IA := k2L2TPIA(@WriteSubAtom);
  try
   IterateProperties(IA, false);
  finally
   k2FreeTPIA(IA);
  end;//try..finally
 end;//G <> nil
end;*)

function Tk2ObjectTag.GetOwnInterface(const IID: TGUID; out Obj): Boolean;
  //override;
  {-}
begin
 Result := f_Object.GetInterface(IID, Obj);
 if not Result then
  Result := inherited GetOwnInterface(IID, Obj); 
end;

function Tk2ObjectTag.GetAttrValue(const aProp  : Tk2CustomProperty;
                                   out theValue : Long;
                                   out theAttr  : Ik2Tag;
                                   anOwnOnly    : Boolean): Boolean;
  {-}
var
 l_MI       : Long;
 l_TgO      : Ik2Tag;
 l_PropType : Tk2Type;
 l_VT       : Tl3Dictionary;
begin
 Result := false;
 if (aProp <> nil) then
 begin
  l_PropType := Tk2Type(aProp.AtomType);
  if f_Type.Wrapper.GetAtomData(Self, aProp, theValue) then
  begin
   Result := true;
   Exit;
  end;//f_Type.Wrapper.GetAtomData(Self, aProp, theValue)
  if anOwnOnly then
   Exit;
  l_MI := aProp.EmptyMapping;
  if (l_MI <> k2_tiMask) then
  begin
   l_TgO := pm_GetAttr(l_MI);
   if not l_TgO.IsSame(Self) then
   begin
    theAttr := l_TgO.Attr[aProp.TagIndex];
    if theAttr.IsNull then
     theAttr := nil
    else
    begin
     Result := true;
     Exit;
    end//IsNull
   end;//not l_TgO.IsSame(Self)
  end;//l_MI <> k2_tiMask
  theValue := aProp.DefaultValue;
  if (theValue <> l3NilLong) then begin
   if l_PropType.IsOrd then
    Result := true
   else
   begin
    theAttr := l_PropType.IntToTag(theValue);
    theValue := theAttr.AsLong;
    Result := true;
   end;//l_PropType.IsOrd
  end//l_Data <> l3NilLong
  else
  begin
   l_VT := l_PropType.ValueTable;
   if (l_VT <> nil) then
   begin
    Result := true;
    theValue := Long(l_VT.Default);
   end;//l_VT <> nil
  end;//l_Data <> l3NilLong
 end;//aProp <> nil
end;

procedure Tk2ObjectTag.DeleteMapped(aProp   : Tk2CustomProperty;
                                    const Context : Ik2Op);
  {-}
begin
end;

procedure Tk2ObjectTag.SetAtom(const aProp    : Tk2Prop;
                               const NewValue : Ik2Tag;
                               const Context  : Ik2Op;
                               aDeleteMapped  : Bool);
  {-}
var
 l_V : Tk2Values;
begin
 if aProp.ReadOnly then
  raise Ek2ReadOnlyProperty.CreateFmt(k2_errReadOnly,
                                      [aProp.AsString, f_Type.AsString])
 else
 begin
  l_V.Init(aProp, @NewValue, Self);
  try
   if aProp.DoBeforeChange(l_V, Context) then
   begin
    l_V.CheckSort;
    SetAtomPrim(aProp, l_V, Context);
    if (Context <> nil) AND aProp.NeedMarkModified
       AND not Context.InIOProcess then
     Context.MarkModified(Self);
    aProp.DoAfterChange(l_V, Context);
    if aDeleteMapped then
     DeleteMapped(aProp, Context);
   end;//..DoBeforeChange..
  finally
   l_V.Free;
  end;//try..finally
 end;//aProp.ReadOnly
end;

procedure Tk2ObjectTag.SetSubAtom(const aProp    : Tk2Prop;
                                 const aSubAtom : Ik2Tag;
                                 const Context  : Ik2Op);
  {-}
begin
 SetAtom(aProp, aSubAtom, Context, true);
end;

procedure Tk2ObjectTag.SetAtomPrim(aProp   : Tk2CustomProperty;
                                   var V         : Tk2Values;
                                   const Context : Ik2Op);
  //virtual;
  {-}
begin
 Assert(false);
end;

function Tk2ObjectTag._cAttr(const aProp    : Tk2Prop;
                             const aContext : Ik2Op = nil): Ik2Tag;
  {* - проверить существование подтега и создать его при необходимости. }
begin
 Result := rOwnAtom(aProp.TagIndex);
 if Result.IsNull then
 begin
  Result := Tk2Type(aProp.AtomType).MakeTag;
  SetSubAtom(aProp, Result, aContext);
 end;//Result.IsNull
end;

procedure Tk2ObjectTag.ChildAdded(aProp    : Tk2ArrayProperty;
                                  const aChild   : Ik2Tag;
                                  anIndex        : Long;
                                  aTotal         : Integer;
                                  const anOpPack : Ik2Op);
  {* - нотификация о добавлении "ребенка". }
begin
 aProp.DoAfterChildAdded(Self, aChild, anOpPack, anIndex, aTotal);
end;

function Tk2ObjectTag.FindChild(anAtom         : Integer;
                                aValue         : Integer;
                                const aContext : Ik2Op = nil;
                                aNeedCreate    : Boolean = false;
                                theIndex       : PLong = nil): Ik2Tag;
  //override;
  {-}
begin
 Result := pm_GetAttr(k2_tiChildren).FindChild(anAtom, aValue, aContext, aNeedCreate, theIndex);
end;

function Tk2ObjectTag.AssignTag(const Source  : Ik2Tag;
                    AssignMode    : Tk2AssignModes = k2_amAll;
                    const Context : Ik2Op = nil): Bool;
  //override;
  {-}
begin
 Result := false;
 Assert(false);
end;

procedure Tk2ObjectTag.SetIntRef(out aRef: Integer);
  //override;
  {-}
begin
 inherited;
 Assert(false);
end;

function Tk2ObjectTag.CheckAttr(const aPath    : array of Long;
                                const aContext : Ik2Op;
                                DoCheck        : Bool;
                                theIndex       : PLong = nil): Ik2Tag;
  {-}
begin
 Result := nil;
 Assert(false);
end;

function Tk2ObjectTag.GetValue: Long;
  //override;
  {-}
begin
 Result := Long(f_Object);
end;

procedure Tk2ObjectTag.SetValue(aValue: Long);
  //override;
  {-}
begin
 f_Object := TObject(aValue);
end;

function Tk2ObjectTag.COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
  //override;
  {-}
begin
 if IID.SomeOf([Il3InfoCanvas, Ik2Processor]) then
 begin
  Assert(false);
  if Supports(f_Object, IID.IID, Obj) then
   Result.SetOk
  else
   Result.SetNoInterface;
 end//IID.SomeOf([Il3InfoCanvas..
 else
 begin
  Result := inherited COMQueryInterface(IID, Obj);
  if Result.Fail then
   if Supports(f_Object, IID.IID, Obj) then
    Result.SetOk
   else
    Result.SetNoInterface;
 end;//..Il3InfoCanvas..
end;

// start class Tk2MemoryPoolTag

function Tk2MemoryPoolTag.AssignTag(const Source  : Ik2Tag;
                                    AssignMode    : Tk2AssignModes = k2_amAll;
                                    const Context : Ik2Op = nil): Bool;
  //override;
  {-}
var
 l_MP : Tl3MemoryPoolPrim;
begin
 Result := true;
 l_MP := Source.AsObject As Tl3MemoryPoolPrim;
 Tl3MemoryPoolPrim(f_Object).Write(0, l_MP.AsPointer, l_MP.Size);
end;

function Tk2MemoryPoolTag.IsStream(out theStream: IStream): Boolean;
  //override;
  {-}
begin
 Result := Supports(f_Object, IStream, theStream);
end;

procedure Tk2MemoryPoolTag.SetValue(aValue: Long);
  //override;
  {-}
begin
 l3Set(f_Object, Tk2MemoryPoolTag(aValue));
end;

procedure Tk2MemoryPoolTag.SetIntRef(out aRef: Integer);
  //override;
  {-}
begin
 TObject(aRef) := Tl3MemoryPoolPrim(f_Object).Use;
end;

// start class Tk2StreamTag

function Tk2StreamTag.IsStream(out theStream: IStream): Boolean;
  //override;
  {-}
begin
 Result := Supports(f_Object, IStream, theStream);
end;

// start class Tk2L3StreamTag

procedure Tk2L3StreamTag.SetValue(aValue: Long);
  //override;
  {-}
begin
 l3Set(f_Object, TObject(aValue));
end;

procedure Tk2L3StreamTag.SetIntRef(out aRef: Integer);
  //override;
  {-}
begin
 TObject(aRef) := Tl3Stream(f_Object).Use;
end;

function Tk2L3StreamTag.IsStream(out theStream: IStream): Boolean;
  //override;
  {-}
begin
 Result := true;
 theStream := IStream(Tl3Stream(f_Object));
end;

// start class Tk2L3ObjectTag

function Tk2L3ObjectTag.HasSubAtom(anIndex: Long): Bool;
  //override;
  {-}
begin
 Result := (anIndex = k2_tiHandle);
end;

function Tk2L3ObjectTag.GetAttrValue(const aProp  : Tk2CustomProperty;
                                     out theValue : Long;
                                     out theAttr  : Ik2Tag;
                                     anOwnOnly    : Boolean): Boolean;
  //override;
  {-}
begin
 if (aProp.TagIndex = k2_tiHandle) then
 begin
  {$IfOpt D+}
  theValue := (f_Object As Tl3Base).Handle;
  {$Else}
  theValue := Tl3Base(f_Object).Handle;
  {$EndIf}
  Result := true;
 end//aProp.TagIndex = k2_tiHandle
 else
  Result := false;
end;

// start class Tk2L3ObjectTagPrim

function Tk2L3ObjectTagPrim.IsStream(out theStream: IStream): Boolean;
  //override;
  {-}
begin
 if f_Type.IsRawData then
  Result := Supports(f_Object, IStream, theStream)
 else
  Result := false;
end;

procedure Tk2L3ObjectTagPrim.SetIntRef(out aRef: Integer);
  //override;
  {-}
begin
 TObject(aRef) := Tl3CBase(f_Object).Use;
end;

function Tk2L3ObjectTagPrim.Get_Owner: Ik2Tag;
  //override;
  {-}
begin
 Result := Tk2TypeTable(f_Type.TypeTable).ObjToTag(Tl3CBase(f_Object).Owner);
 //Result := k2Tag(Tl3CBase(f_Object).Owner);
end;

procedure Tk2L3ObjectTagPrim.Set_Owner(const aValue: Ik2Tag);
  //override;
  {-}
begin
 if (aValue <> nil) AND aValue.IsValid then
  Tl3CBase(f_Object).Owner := aValue.AsObject
 else
  Tl3CBase(f_Object).Owner := nil;
end;

procedure Tk2L3ObjectTagPrim.SetValue(aValue: Long);
  //override;
  {-}
begin
 l3Set(f_Object, TObject(aValue));
end;

// start class Tk2PersistentTag

function Tk2PersistentTag.AssignTag(const Source  : Ik2Tag;
                                    AssignMode    : Tk2AssignModes = k2_amAll;
                                    const Context : Ik2Op = nil): Bool;
  //override;
  {-}
begin
 Result := true;
 TPersistent(AsObject).Assign(Source.AsObject As TPersistent);
end;

// start class Tk2StringTag

function Tk2StringTag.COMQueryInterface(const IID: Tl3GUID; out Obj): Tl3HResult;
  //override;
  {-}
begin
 Result := inherited COMQueryInterface(IID, Obj);
 if Result.Fail then
  if (f_Object <> nil) then
   if l3IOk(Tl3PrimString(f_Object).QueryInterface(IID.IID, Obj)) then
    Result.SetOk
   else
    Result.SetNoInterface;
end;

function Tk2StringTag.IsStream(out theStream: IStream): Boolean;
  //override;
  {-}
begin
 if f_Type.IsRawData then
 begin
  if (f_Object = nil) then
   Result := false
  else
   Result := l3IOk(Tl3PrimString(f_Object).QueryInterface(IStream, theStream));
 end//f_Type.IsRawData
 else
  Result := false;
end;

procedure Tk2StringTag.SetIntRef(out aRef: Integer);
  //override;
  {-}
begin
 TObject(aRef) := Tl3PrimString(f_Object).Use;
end;

function Tk2StringTag.Get_Owner: Ik2Tag;
  //override;
  {-}
begin
 Result := Tk2TypeTable(f_Type.TypeTable).ObjToTag(Tk2HackString(f_Object).GetOwner);
 //Result := k2Tag(Tl3CBase(f_Object).Owner);
end;

procedure Tk2StringTag.Set_Owner(const aValue: Ik2Tag);
  //override;
  {-}
begin
 if (aValue <> nil) AND aValue.IsValid then
  Tk2HackString(f_Object).DoSetOwner(aValue.AsObject)
 else
  Tk2HackString(f_Object).DoSetOwner(nil);
end;

procedure Tk2StringTag.SetValue(aValue: Long);
  //override;
  {-}
begin
 l3Set(f_Object, TObject(aValue));
end;

function Tk2StringTag.GetAttrValue(const aProp  : Tk2CustomProperty;
                                   out theValue : Long;
                                   out theAttr  : Ik2Tag;
                                   anOwnOnly    : Boolean): Boolean;
  //override;
  {-}
begin
 if (aProp.TagIndex = k2_tiValue) then
 begin
  Result := true;
  theValue := Long(f_Object);
  if Tl3CustomString(theValue).Empty then
   Result := false;
   // - типа нету нас - это чтобы TevDocumentGenerator(Buffer) не терял значения TERM'ов.
 end//Prop.TagIndex = k2_tiValue
 else
  Result := inherited GetAttrValue(aProp, theValue, theAttr, anOwnOnly);
end;

procedure Tk2StringTag.SetAtomPrim(aProp   : Tk2CustomProperty;
                                   var V         : Tk2Values;
                                   const Context : Ik2Op);
  //override;
  {-}
begin
 if (aProp.TagIndex = k2_tiValue) then
 begin
  V.rOld := Self.CloneTag;
  AssignTag(V.rNew^);
 end//Prop.TagIndex = k2_tiValue
 else
  inherited;
end;

function Tk2StringTag.HasSubAtom(anIndex: Long): Bool;
  //override;
  {-}
begin
 Result := (anIndex = k2_tiValue) OR inherited HasSubAtom(anIndex);
end;

// start class Tk2ToolPrim

class function Tk2ToolPrim.StoreToOldCache: Boolean;
  //virtual;
  {-}
begin
 Result := false;
end;

class function Tk2ToolPrim.IsCacheable: Bool;
  //override;
  {-}
begin
 Result := not StoreToOldCache;
end;

procedure Tk2ToolPrim.AfterFree;
  //override;
  {-}
begin
 inherited;
 if (RefCount <= 1) AND StoreToOldCache then
  Cleanup;
end;

procedure Tk2ToolPrim.SetTag(const aTag: Ik2Tag);
begin
 DoSetTag(aTag);
end;

initialization
{!touched!}{$IfDef LogInit} WriteLn('W:\common\components\rtl\Garant\K2\k2Base.pas initialization enter'); {$EndIf}
 k2TypeBuffers := l3NewMemoryChain(Succ(Ord(High(Tk2TagID))) shl 2);

{!touched!}{$IfDef LogInit} WriteLn('W:\common\components\rtl\Garant\K2\k2Base.pas initialization leave'); {$EndIf}
end.

